# 1 "grep_single_original.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "grep_single_original.c"
# 28 "grep_single_original.c"
# 1 "./config.h" 1
# 29 "grep_single_original.c" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 367 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 368 "/usr/include/features.h" 2 3 4
# 391 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 392 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 30 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 270 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 32 "grep_single_original.c" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };
# 105 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 208 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 237 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 262 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 283 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));
# 320 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 398 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 441 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));
# 533 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 34 "grep_single_original.c" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4





# 57 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) __attribute__ ((__nothrow__ , __leaf__));
# 76 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ , __leaf__));







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));



extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));




extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));


extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int mlockall (int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern int munlockall (void) __attribute__ ((__nothrow__ , __leaf__));







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__ , __leaf__));
# 144 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);


# 36 "grep_single_original.c" 2





# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 173 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 333 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 385 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 429 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 459 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 306 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 872 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 912 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 942 "/usr/include/stdio.h" 3 4

# 42 "grep_single_original.c" 2






# 1 "system.h" 1
# 23 "system.h"
  
# 23 "system.h"
 typedef void * ptr_t;
# 35 "system.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4

# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };
# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 363 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4

# 437 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4

# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 76 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 77 "/usr/include/fcntl.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 78 "/usr/include/fcntl.h" 2 3 4
# 146 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 156 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 180 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 202 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 231 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, off_t __len);
# 248 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 270 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 292 "/usr/include/fcntl.h" 3 4

# 36 "system.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 258 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 270 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 307 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 356 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 420 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;
# 528 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));
# 546 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 601 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 703 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
# 759 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));





extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 874 "/usr/include/unistd.h" 3 4
# 1 "./getopt.h" 1 3 4
# 35 "./getopt.h" 3 4
extern char *optarg;
# 49 "./getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 81 "./getopt.h" 3 4
struct option
{

  const char *name;





  int has_arg;
  int *flag;
  int val;
};
# 106 "./getopt.h" 3 4
extern int getopt (int argc, char *const *argv, const char *shortopts);



extern int getopt_long (int argc, char *const *argv, const char *shortopts,
          const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind);


extern int _getopt_internal (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind,
        int long_only);
# 875 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 972 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 996 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1019 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1154 "/usr/include/unistd.h" 3 4

# 37 "system.h" 2







# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 58 "/usr/include/errno.h" 3 4

# 45 "system.h" 2
# 114 "system.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 321 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 711 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 751 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 774 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 811 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 898 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 950 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 955 "/usr/include/stdlib.h" 2 3 4
# 967 "/usr/include/stdlib.h" 3 4

# 115 "system.h" 2







# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 123 "system.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 126 "system.h" 2
# 141 "system.h"
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 123 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 160 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 206 "/usr/include/string.h" 3 4

# 231 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 258 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 277 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 310 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 337 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 392 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 422 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 440 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 484 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 512 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 529 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 552 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 658 "/usr/include/string.h" 3 4

# 142 "system.h" 2
# 158 "system.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));


# 150 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 347 "/usr/include/ctype.h" 3 4

# 159 "system.h" 2
# 185 "system.h"
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 186 "system.h" 2







# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 50 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));


# 151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 194 "system.h" 2
# 49 "grep_single_original.c" 2
# 1 "getopt.h" 1
# 50 "grep_single_original.c" 2
# 1 "getpagesize.h" 1
# 51 "grep_single_original.c" 2
# 1 "grep.h" 1
# 23 "grep.h"

# 23 "grep.h"
extern void fatal (const char *, int) __attribute__((noreturn));
extern char *xmalloc (size_t size);
extern char *xrealloc (char *ptr, size_t size);





extern struct matcher
{
  char *name;
  void (*compile) (char *, size_t);
  char *(*execute) (char *, size_t, char **);
} matchers[];


extern char const *matcher;



extern int match_icase;
extern int match_words;
extern int match_lines;
extern unsigned char eolbyte;
# 52 "grep_single_original.c" 2
# 1 "savedir.h" 1
# 12 "savedir.h"
char *
savedir (const char *dir, unsigned int name_size);
# 53 "grep_single_original.c" 2




struct stats
{
  struct stats *parent;
  struct stat stat;
};


static struct stats stats_base;


static int show_help;


static int show_version;


static int mmap_option;


static char const short_options[] =
"0123456789A:B:C::EFGHUVX:abcd:e:f:hiLlnqrsuvwxyZz";


static struct option long_options[] =
{
  {"after-context", 
# 82 "grep_single_original.c" 3 4
                   1
# 82 "grep_single_original.c"
                                    , 
# 82 "grep_single_original.c" 3 4
                                      ((void *)0)
# 82 "grep_single_original.c"
                                          , 'A'},
  {"basic-regexp", 
# 83 "grep_single_original.c" 3 4
                  0
# 83 "grep_single_original.c"
                             , 
# 83 "grep_single_original.c" 3 4
                               ((void *)0)
# 83 "grep_single_original.c"
                                   , 'G'},
  {"before-context", 
# 84 "grep_single_original.c" 3 4
                    1
# 84 "grep_single_original.c"
                                     , 
# 84 "grep_single_original.c" 3 4
                                       ((void *)0)
# 84 "grep_single_original.c"
                                           , 'B'},
  {"byte-offset", 
# 85 "grep_single_original.c" 3 4
                 0
# 85 "grep_single_original.c"
                            , 
# 85 "grep_single_original.c" 3 4
                              ((void *)0)
# 85 "grep_single_original.c"
                                  , 'b'},
  {"context", 
# 86 "grep_single_original.c" 3 4
             2
# 86 "grep_single_original.c"
                              , 
# 86 "grep_single_original.c" 3 4
                                ((void *)0)
# 86 "grep_single_original.c"
                                    , 'C'},
  {"count", 
# 87 "grep_single_original.c" 3 4
           0
# 87 "grep_single_original.c"
                      , 
# 87 "grep_single_original.c" 3 4
                        ((void *)0)
# 87 "grep_single_original.c"
                            , 'c'},
  {"directories", 
# 88 "grep_single_original.c" 3 4
                 1
# 88 "grep_single_original.c"
                                  , 
# 88 "grep_single_original.c" 3 4
                                    ((void *)0)
# 88 "grep_single_original.c"
                                        , 'd'},
  {"extended-regexp", 
# 89 "grep_single_original.c" 3 4
                     0
# 89 "grep_single_original.c"
                                , 
# 89 "grep_single_original.c" 3 4
                                  ((void *)0)
# 89 "grep_single_original.c"
                                      , 'E'},
  {"file", 
# 90 "grep_single_original.c" 3 4
          1
# 90 "grep_single_original.c"
                           , 
# 90 "grep_single_original.c" 3 4
                             ((void *)0)
# 90 "grep_single_original.c"
                                 , 'f'},
  {"files-with-matches", 
# 91 "grep_single_original.c" 3 4
                        0
# 91 "grep_single_original.c"
                                   , 
# 91 "grep_single_original.c" 3 4
                                     ((void *)0)
# 91 "grep_single_original.c"
                                         , 'l'},
  {"files-without-match", 
# 92 "grep_single_original.c" 3 4
                         0
# 92 "grep_single_original.c"
                                    , 
# 92 "grep_single_original.c" 3 4
                                      ((void *)0)
# 92 "grep_single_original.c"
                                          , 'L'},
  {"fixed-regexp", 
# 93 "grep_single_original.c" 3 4
                  0
# 93 "grep_single_original.c"
                             , 
# 93 "grep_single_original.c" 3 4
                               ((void *)0)
# 93 "grep_single_original.c"
                                   , 'F'},
  {"fixed-strings", 
# 94 "grep_single_original.c" 3 4
                   0
# 94 "grep_single_original.c"
                              , 
# 94 "grep_single_original.c" 3 4
                                ((void *)0)
# 94 "grep_single_original.c"
                                    , 'F'},
  {"help", 
# 95 "grep_single_original.c" 3 4
          0
# 95 "grep_single_original.c"
                     , &show_help, 1},
  {"ignore-case", 
# 96 "grep_single_original.c" 3 4
                 0
# 96 "grep_single_original.c"
                            , 
# 96 "grep_single_original.c" 3 4
                              ((void *)0)
# 96 "grep_single_original.c"
                                  , 'i'},
  {"line-number", 
# 97 "grep_single_original.c" 3 4
                 0
# 97 "grep_single_original.c"
                            , 
# 97 "grep_single_original.c" 3 4
                              ((void *)0)
# 97 "grep_single_original.c"
                                  , 'n'},
  {"line-regexp", 
# 98 "grep_single_original.c" 3 4
                 0
# 98 "grep_single_original.c"
                            , 
# 98 "grep_single_original.c" 3 4
                              ((void *)0)
# 98 "grep_single_original.c"
                                  , 'x'},
  {"mmap", 
# 99 "grep_single_original.c" 3 4
          0
# 99 "grep_single_original.c"
                     , &mmap_option, 1},
  {"no-filename", 
# 100 "grep_single_original.c" 3 4
                 0
# 100 "grep_single_original.c"
                            , 
# 100 "grep_single_original.c" 3 4
                              ((void *)0)
# 100 "grep_single_original.c"
                                  , 'h'},
  {"no-messages", 
# 101 "grep_single_original.c" 3 4
                 0
# 101 "grep_single_original.c"
                            , 
# 101 "grep_single_original.c" 3 4
                              ((void *)0)
# 101 "grep_single_original.c"
                                  , 's'},
  {"null", 
# 102 "grep_single_original.c" 3 4
          0
# 102 "grep_single_original.c"
                     , 
# 102 "grep_single_original.c" 3 4
                       ((void *)0)
# 102 "grep_single_original.c"
                           , 'Z'},
  {"null-data", 
# 103 "grep_single_original.c" 3 4
               0
# 103 "grep_single_original.c"
                          , 
# 103 "grep_single_original.c" 3 4
                            ((void *)0)
# 103 "grep_single_original.c"
                                , 'z'},
  {"quiet", 
# 104 "grep_single_original.c" 3 4
           0
# 104 "grep_single_original.c"
                      , 
# 104 "grep_single_original.c" 3 4
                        ((void *)0)
# 104 "grep_single_original.c"
                            , 'q'},
  {"recursive", 
# 105 "grep_single_original.c" 3 4
               0
# 105 "grep_single_original.c"
                          , 
# 105 "grep_single_original.c" 3 4
                            ((void *)0)
# 105 "grep_single_original.c"
                                , 'r'},
  {"regexp", 
# 106 "grep_single_original.c" 3 4
            1
# 106 "grep_single_original.c"
                             , 
# 106 "grep_single_original.c" 3 4
                               ((void *)0)
# 106 "grep_single_original.c"
                                   , 'e'},
  {"invert-match", 
# 107 "grep_single_original.c" 3 4
                  0
# 107 "grep_single_original.c"
                             , 
# 107 "grep_single_original.c" 3 4
                               ((void *)0)
# 107 "grep_single_original.c"
                                   , 'v'},
  {"silent", 
# 108 "grep_single_original.c" 3 4
            0
# 108 "grep_single_original.c"
                       , 
# 108 "grep_single_original.c" 3 4
                         ((void *)0)
# 108 "grep_single_original.c"
                             , 'q'},
  {"text", 
# 109 "grep_single_original.c" 3 4
          0
# 109 "grep_single_original.c"
                     , 
# 109 "grep_single_original.c" 3 4
                       ((void *)0)
# 109 "grep_single_original.c"
                           , 'a'},
  {"binary", 
# 110 "grep_single_original.c" 3 4
            0
# 110 "grep_single_original.c"
                       , 
# 110 "grep_single_original.c" 3 4
                         ((void *)0)
# 110 "grep_single_original.c"
                             , 'U'},
  {"unix-byte-offsets", 
# 111 "grep_single_original.c" 3 4
                       0
# 111 "grep_single_original.c"
                                  , 
# 111 "grep_single_original.c" 3 4
                                    ((void *)0)
# 111 "grep_single_original.c"
                                        , 'u'},
  {"version", 
# 112 "grep_single_original.c" 3 4
             0
# 112 "grep_single_original.c"
                        , 
# 112 "grep_single_original.c" 3 4
                          ((void *)0)
# 112 "grep_single_original.c"
                              , 'V'},
  {"with-filename", 
# 113 "grep_single_original.c" 3 4
                   0
# 113 "grep_single_original.c"
                              , 
# 113 "grep_single_original.c" 3 4
                                ((void *)0)
# 113 "grep_single_original.c"
                                    , 'H'},
  {"word-regexp", 
# 114 "grep_single_original.c" 3 4
                 0
# 114 "grep_single_original.c"
                            , 
# 114 "grep_single_original.c" 3 4
                              ((void *)0)
# 114 "grep_single_original.c"
                                  , 'w'},
  {0, 0, 0, 0}
};


int match_icase;
int match_words;
int match_lines;
unsigned char eolbyte;


static char *prog;
static char const *filename;
static int errseen;


static enum
  {
    READ_DIRECTORIES,
    RECURSE_DIRECTORIES,
    SKIP_DIRECTORIES
  } directories;

static int ck_atoi (char const *, int *);
static void usage (int) __attribute__((noreturn));
static void error (const char *, int);
static void setmatcher (char const *);
static int install_matcher (char const *);
static int prepend_args (char const *, char *, char **);
static void prepend_default_options (char const *, int *, char ***);
static char *page_alloc (size_t, char **);
static int reset (int, char const *, struct stats *);
static int fillbuf (size_t, struct stats *);
static int grepbuf (char *, char *);
static void prtext (char *, char *, int *);
static void prpending (char *);
static void prline (char *, char *, int);
static void print_offset_sep (off_t, int);
static void nlscan (char *);
static int grep (int, char const *, struct stats *);
static int grepdir (char const *, struct stats *);
static int grepfile (char const *, struct stats *);





static void (*compile) (char *, size_t);
static char *(*execute) (char *, size_t, char **);



static void
error (mesg, errnum)
     const char *mesg;
     int errnum;
{
  if (errnum)
    fprintf (
# 172 "grep_single_original.c" 3 4
            stdout
# 172 "grep_single_original.c"
                  , "%s: %s: %s\n", prog, mesg, strerror (errnum));
  else
    fprintf (
# 174 "grep_single_original.c" 3 4
            stdout
# 174 "grep_single_original.c"
                  , "%s: %s\n", prog, mesg);
  errseen = 1;
}


void
fatal (mesg, errnum)
     const char *mesg;
     int errnum;
{
  error (mesg, errnum);
  exit (2);
}


char *
xmalloc (size)
     size_t size;
{
  char *result;

  result = malloc (size);
  if (size && !result)
    fatal (gettext ("memory exhausted"), 0);
  return result;
}


char *
xrealloc (ptr, size)
     char *ptr;
     size_t size;
{
  char *result;

  if (ptr)
    result = realloc (ptr, size);
  else
    result = malloc (size);
  if (size && !result)
    fatal (gettext ("memory exhausted"), 0);
  return result;
}



static int
ck_atoi (str, out)
     char const *str;
     int *out;
{
  char const *p;
  for (p = str; *p; p++)
    if (*p < '0' || *p > '9')
      return -1;

  *out = atoi (optarg);
  return 0;
}






static char *ubuffer;
static char *buffer;
static size_t bufsalloc;
static size_t bufalloc;

static int bufdesc;
static char *bufbeg;
static char *buflim;
static size_t pagesize;
static off_t bufoffset;


static int bufmapped;
static off_t initial_bufoffset;
# 266 "grep_single_original.c"
static char *
page_alloc (size, up)
     size_t size;
     char **up;
{
  size_t asize = size + pagesize - 1;
  if (size <= asize)
    {

      char *p = *up ? realloc (*up, asize) : malloc (asize);



      if (p)
 {

   *up = p;



   return zzz ((size_t) (p) % (pagesize) == 0 zzz ? (p) zzz : (p) + ((pagesize) - (size_t) (p) % (pagesize)));
 }
    }
  return 
# 289 "grep_single_original.c" 3 4
        ((void *)0)
# 289 "grep_single_original.c"
            ;
}



static int
reset (fd, file, stats)
     int fd;
     char const *file;
     struct stats *stats;
{
  if (pagesize)
    bufsalloc = zzz ((size_t) (bufalloc / 5) % (pagesize) == 0 zzz ? (bufalloc / 5) zzz : (bufalloc / 5) + ((pagesize) - (size_t) (bufalloc / 5) % (pagesize)));
  else
    {
      size_t ubufsalloc;
      pagesize = getpagesize ();
      if (pagesize == 0)
 abort ();

      ubufsalloc = ((8192) > (pagesize) ? (8192) : (pagesize));



      bufsalloc = zzz ((size_t) (ubufsalloc) % (pagesize) == 0 zzz ? (ubufsalloc) zzz : (ubufsalloc) + ((pagesize) - (size_t) (ubufsalloc) % (pagesize)));
      bufalloc = 5 * bufsalloc;



      if (bufsalloc < ubufsalloc

   || bufalloc / 5 != bufsalloc



   || bufalloc + 1 < bufalloc
   || ! (buffer = page_alloc (bufalloc + 1, &ubuffer)))
 fatal (gettext ("memory exhausted"), 0);
    }

  buflim = buffer;
  bufdesc = fd;

  if (fstat (fd, &stats->stat) != 0)
    {
      error ("fstat", 
# 334 "grep_single_original.c" 3 4
                     (*__errno_location ())
# 334 "grep_single_original.c"
                          );
      return 0;
    }
  if (directories == SKIP_DIRECTORIES && 
# 337 "grep_single_original.c" 3 4
                                        ((((
# 337 "grep_single_original.c"
                                        stats->stat.st_mode
# 337 "grep_single_original.c" 3 4
                                        )) & 0170000) == (0040000))
# 337 "grep_single_original.c"
                                                                     )
    return 0;
  if (
# 339 "grep_single_original.c" 3 4
     ((((
# 339 "grep_single_original.c"
     stats->stat.st_mode
# 339 "grep_single_original.c" 3 4
     )) & 0170000) == (0100000))
# 339 "grep_single_original.c"
                                  )
    {
      if (file)
 bufoffset = 0;
      else
 {
   bufoffset = lseek (fd, 0, 
# 345 "grep_single_original.c" 3 4
                            1
# 345 "grep_single_original.c"
                                    );
   if (bufoffset < 0)
     {
       error ("lseek", 
# 348 "grep_single_original.c" 3 4
                      (*__errno_location ())
# 348 "grep_single_original.c"
                           );
       return 0;
     }
 }

      initial_bufoffset = bufoffset;

      bufmapped = mmap_option && bufoffset % pagesize == 0;




    }
  else
    {

      bufmapped = 0;

    }
  return 1;
}





static int
fillbuf (save, stats)
     size_t save;
     struct stats *stats;
{
  size_t fillsize = 0;
  int cc = 1;
  size_t readsize;



  size_t saved_offset = buflim - ubuffer - save;


  if (bufsalloc < save)



    {
      size_t aligned_save = zzz ((size_t) (save) % (pagesize) == 0 zzz ? (save) zzz : (save) + ((pagesize) - (size_t) (save) % (pagesize)));
      size_t maxalloc = (size_t) -1;
      size_t newalloc;

      if (
# 397 "grep_single_original.c" 3 4
         ((((
# 397 "grep_single_original.c"
         stats->stat.st_mode
# 397 "grep_single_original.c" 3 4
         )) & 0170000) == (0100000))
# 397 "grep_single_original.c"
                                      )
 {



   off_t to_be_read = stats->stat.st_size - bufoffset;
   size_t slop = to_be_read % pagesize;
   off_t aligned_to_be_read = to_be_read + (slop ? pagesize - slop : 0);
   off_t maxalloc_off = aligned_save + aligned_to_be_read;
   if (0 <= maxalloc_off && maxalloc_off == (size_t) maxalloc_off)
     maxalloc = maxalloc_off;
 }



      while (bufsalloc < save)
 if (bufsalloc < bufsalloc * 2)
   bufsalloc *= 2;
 else
   {
     bufsalloc = aligned_save;
     break;
   }



      newalloc = 5 * bufsalloc;
      if (maxalloc < newalloc)
 {



   newalloc = maxalloc;
   bufsalloc = aligned_save;
 }





      if (bufsalloc < save || newalloc < save
   || (newalloc == save && newalloc != maxalloc)
   || (bufalloc < newalloc
       && ! (buffer
      = page_alloc ((bufalloc = newalloc) + 1, &ubuffer))))
 fatal (gettext ("memory exhausted"), 0);
    }







  bufbeg = buffer + bufsalloc - save;
  memmove (bufbeg, ubuffer + saved_offset, save);
  readsize = bufsalloc - bufalloc;



  if (bufmapped)
    {
      size_t mmapsize = readsize;



      if (stats->stat.st_size - bufoffset < mmapsize)
 {
   mmapsize = stats->stat.st_size - bufoffset;
   mmapsize -= mmapsize % pagesize;
 }

      if (mmapsize
   && (mmap ((caddr_t) (buffer + bufsalloc), mmapsize,
      
# 471 "grep_single_original.c" 3 4
     0x1 
# 471 "grep_single_original.c"
               | 
# 471 "grep_single_original.c" 3 4
                 0x2
# 471 "grep_single_original.c"
                           , 
# 471 "grep_single_original.c" 3 4
                             0x02 
# 471 "grep_single_original.c"
                                         | 
# 471 "grep_single_original.c" 3 4
                                           0x10
# 471 "grep_single_original.c"
                                                    ,
      bufdesc, bufoffset)
       != (caddr_t) -1))
 {



   fillsize = mmapsize;
 }
      else
 {





   bufmapped = 0;
   if (bufoffset != initial_bufoffset
       && lseek (bufdesc, bufoffset, 
# 489 "grep_single_original.c" 3 4
                                    0
# 489 "grep_single_original.c"
                                            ) < 0)
     {
       error ("lseek", 
# 491 "grep_single_original.c" 3 4
                      (*__errno_location ())
# 491 "grep_single_original.c"
                           );
       cc = 0;
     }
 }
    }



  if (! fillsize)
    {
      ssize_t bytesread;
      while ((bytesread = read (bufdesc, buffer + bufsalloc, readsize)) < 0
      && 
# 503 "grep_single_original.c" 3 4
        (*__errno_location ()) 
# 503 "grep_single_original.c"
              == 
# 503 "grep_single_original.c" 3 4
                 4
# 503 "grep_single_original.c"
                      )
 continue;
      if (bytesread < 0)
 cc = 0;
      else
 fillsize = bytesread;
    }

  bufoffset += fillsize;
# 532 "grep_single_original.c"
  buflim = buffer + bufsalloc + fillsize;
  return cc;
}


static int always_text;
static int filename_mask;
static int out_quiet;
static int out_invert;
static int out_file;
static int out_line;
static int out_byte;
static int out_before;
static int out_after;
static int count_matches;
static int list_files;
static int no_filenames;
static int suppress_errors;


static off_t totalcc;
static char *lastnl;
static char *lastout;


static off_t totalnl;
static int pending;
static int done_on_match;





static void
nlscan (lim)
     char *lim;
{
  char *beg;
  for (beg = lastnl; (beg = memchr (beg, eolbyte, lim - beg)); beg++)
    totalnl++;

  lastnl = lim;



}

static void
print_offset_sep (pos, sep)
     off_t pos;
     int sep;
{



  char buf[sizeof pos * 8];
  char *p = buf + sizeof buf - 1;
  *p = sep;

  do
    *--p = '0' + pos % 10;
  while ((pos /= 10) != 0);

  fwrite (p, 1, buf + sizeof buf - p, 
# 595 "grep_single_original.c" 3 4
                                     stdout
# 595 "grep_single_original.c"
                                           );
}

static void
prline (beg, lim, sep)
     char *beg;
     char *lim;
     int sep;
{
  if (out_file)

    printf ("%s%c", filename, sep & filename_mask);



  if (out_line)
    {
      nlscan (beg);
      print_offset_sep (++totalnl, sep);
      lastnl = lim;
    }
  if (out_byte)
    {
      off_t pos = totalcc + (beg - bufbeg);



      print_offset_sep (pos, sep);
    }
  fwrite (beg, 1, lim - beg, 
# 624 "grep_single_original.c" 3 4
                            stdout
# 624 "grep_single_original.c"
                                  );
  if (ferror (
# 625 "grep_single_original.c" 3 4
             stdout
# 625 "grep_single_original.c"
                   ))
    error (gettext ("writing output"), 
# 626 "grep_single_original.c" 3 4
                               (*__errno_location ())
# 626 "grep_single_original.c"
                                    );
  lastout = lim;
}


static void
prpending (lim)
     char *lim;
{
  char *nl;

  if (!lastout)
    lastout = bufbeg;
  while (pending > 0 && lastout < lim)
    {
      --pending;
      if ((nl = memchr (lastout, eolbyte, lim - lastout)) != 0)
 ++nl;
      else
 nl = lim;
      prline (lastout, nl, '-');
    }
}



static void
prtext (beg, lim, nlinesp)
     char *beg;
     char *lim;
     int *nlinesp;
{
  static int used;
  char *bp, *p, *nl;
  char eol = eolbyte;
  int i, n;

  if (!out_quiet && pending > 0)
    prpending (beg);

  p = beg;

  if (!out_quiet)
    {


      bp = lastout ? lastout : bufbeg;
      for (i = 0; i < out_before; ++i)
 if (p > bp)
   do
     --p;
   while (p > bp && p[-1] != eol);



      if ((out_before || out_after) && used && p != lastout)
 puts ("--");

      while (p < beg)
 {
   nl = memchr (p, eol, beg - p);
   prline (p, nl + 1, '-');
   p = nl + 1;
 }
    }

  if (nlinesp)
    {

      for (n = 0; p < lim; ++n)
 {
   if ((nl = memchr (p, eol, lim - p)) != 0)
     ++nl;
   else
     nl = lim;
   if (!out_quiet)
     prline (p, nl, ':');
   p = nl;
 }
      *nlinesp = n;
    }
  else
    if (!out_quiet)
      prline (beg, lim, ':');


  pending = out_quiet ? 0 : out_after;



  used = 1;
}




static int
grepbuf (beg, lim)
     char *beg;
     char *lim;
{
  int nlines, n;
  register char *p, *b;
  char *endp;
  char eol = eolbyte;

  nlines = 0;
  p = beg;
  while ((b = (*execute)(p, lim - p, &endp)) != 0)
    {

      if (b == lim && ((b > beg && b[-1] == eol) || b == beg))
 break;
      if (!out_invert)
 {
   prtext (b, endp, (int *) 0);
   nlines += 1;
   if (done_on_match)
     return nlines;
 }
      else if (p < b)
 {
   prtext (p, b, &n);
   nlines += n;
 }
      p = endp;
    }
  if (out_invert && p < lim)
    {
      prtext (p, lim, &n);
      nlines += n;
    }
  return nlines;
}




static int
grep (fd, file, stats)
     int fd;
     char const *file;
     struct stats *stats;
{
  int nlines, i;
  int not_text;
  size_t residue, save;
  char *beg, *lim;
  char eol = eolbyte;

  if (!reset (fd, file, stats))
    return 0;

  if (file && directories == RECURSE_DIRECTORIES
      && 
# 780 "grep_single_original.c" 3 4
        ((((
# 780 "grep_single_original.c"
        stats->stat.st_mode
# 780 "grep_single_original.c" 3 4
        )) & 0170000) == (0040000))
# 780 "grep_single_original.c"
                                     )
    {


      if (close (fd) != 0)
 error (file, 
# 785 "grep_single_original.c" 3 4
             (*__errno_location ())
# 785 "grep_single_original.c"
                  );
      return grepdir (file, stats) - 2;
    }

  totalcc = 0;
  lastout = 0;
  totalnl = 0;
  pending = 0;

  nlines = 0;
  residue = 0;
  save = 0;

  if (! fillbuf (save, stats))
    {
      if (! (((
# 800 "grep_single_original.c" 3 4
            (*__errno_location ())
# 800 "grep_single_original.c"
            ) == 
# 800 "grep_single_original.c" 3 4
            21
# 800 "grep_single_original.c"
            ) && suppress_errors))
 error (filename, 
# 801 "grep_single_original.c" 3 4
                 (*__errno_location ())
# 801 "grep_single_original.c"
                      );
      return nlines;
    }

  not_text = (! (always_text | out_quiet)
       && memchr (bufbeg, eol ? '\0' : '\200', buflim - bufbeg));
  done_on_match += not_text;
  out_quiet += not_text;

  for (;;)
    {
      lastnl = bufbeg;
      if (lastout)
 lastout = bufbeg;
      if (buflim - bufbeg == save)
 break;
      beg = bufbeg + save - residue;
      for (lim = buflim; lim > beg && lim[-1] != eol; --lim)
 ;
      residue = buflim - lim;
      if (beg < lim)
 {
   nlines += grepbuf (beg, lim);
   if (pending)
     prpending (lim);
   if (nlines && done_on_match && !out_invert)
     goto finish_grep;
 }
      i = 0;
      beg = lim;
      while (i < out_before && beg > bufbeg && beg != lastout)
 {
   ++i;
   do
     --beg;
   while (beg > bufbeg && beg[-1] != eol);
 }
      if (beg != lastout)
 lastout = 0;
      save = residue + lim - beg;
      totalcc += buflim - bufbeg - save;
      if (out_line)
 nlscan (beg);
      if (! fillbuf (save, stats))
 {
   if (! (((
# 846 "grep_single_original.c" 3 4
         (*__errno_location ())
# 846 "grep_single_original.c"
         ) == 
# 846 "grep_single_original.c" 3 4
         21
# 846 "grep_single_original.c"
         ) && suppress_errors))
     error (filename, 
# 847 "grep_single_original.c" 3 4
                     (*__errno_location ())
# 847 "grep_single_original.c"
                          );
   goto finish_grep;
 }
    }
  if (residue)
    {
      nlines += grepbuf (bufbeg + save - residue, buflim);
      if (pending)
 prpending (buflim);
    }

 finish_grep:
  done_on_match -= not_text;
  out_quiet -= not_text;
  if ((not_text & ~out_quiet) && nlines != 0)
    printf (gettext ("Binary file %s matches\n"), filename);
  return nlines;
}

static int
grepfile (file, stats)
     char const *file;
     struct stats *stats;
{
  int desc;
  int count;
  int status;

  if (! file)
    {
      desc = 0;
      filename = gettext ("(standard input)");
    }
  else
    {

      while ((desc = open (file, 
# 883 "grep_single_original.c" 3 4
                                00
# 883 "grep_single_original.c"
                                        )) < 0 && 
# 883 "grep_single_original.c" 3 4
                                                  (*__errno_location ()) 
# 883 "grep_single_original.c"
                                                        == 
# 883 "grep_single_original.c" 3 4
                                                           4
# 883 "grep_single_original.c"
                                                                )




 continue;

      if (desc < 0)
 {
   int e = 
# 892 "grep_single_original.c" 3 4
          (*__errno_location ())
# 892 "grep_single_original.c"
               ;

   if (((e) == 
# 894 "grep_single_original.c" 3 4
      21
# 894 "grep_single_original.c"
      ) && directories == RECURSE_DIRECTORIES)
     {
       if (stat (file, &stats->stat) != 0)
  {
    error (file, 
# 898 "grep_single_original.c" 3 4
                (*__errno_location ())
# 898 "grep_single_original.c"
                     );
    return 1;
  }

       return grepdir (file, stats);
     }

   if (!suppress_errors)
     {
       if (directories == SKIP_DIRECTORIES)
  switch (e)
    {

    case 
# 911 "grep_single_original.c" 3 4
        21
# 911 "grep_single_original.c"
              :
      return 1;

    case 
# 914 "grep_single_original.c" 3 4
        13
# 914 "grep_single_original.c"
              :


      if (stat (file, &stats->stat) == 0
   && 
# 918 "grep_single_original.c" 3 4
     ((((
# 918 "grep_single_original.c"
     stats->stat.st_mode
# 918 "grep_single_original.c" 3 4
     )) & 0170000) == (0040000))
# 918 "grep_single_original.c"
                                  )
        return 1;
      break;
    }

       error (file, e);
     }

   return 1;
 }

      filename = file;
    }
# 939 "grep_single_original.c"
  count = grep (desc, file, stats);
  if (count < 0)
    status = count + 2;
  else
    {
      if (count_matches)
 {
   if (out_file)
     printf ("%s%c", filename, ':' & filename_mask);
   printf ("%d\n", count);
 }


      status = !count;
      if (list_files == 1 - 2 * status)
 printf ("%s%c", filename, '\n' & filename_mask);






      if (file)
 while (close (desc) != 0)
   if (
# 963 "grep_single_original.c" 3 4
      (*__errno_location ()) 
# 963 "grep_single_original.c"
            != 
# 963 "grep_single_original.c" 3 4
               4
# 963 "grep_single_original.c"
                    )
     {
       error (file, 
# 965 "grep_single_original.c" 3 4
                   (*__errno_location ())
# 965 "grep_single_original.c"
                        );
       break;
     }
    }

  return status;
}

static int
grepdir (dir, stats)
     char const *dir;
     struct stats *stats;
{
  int status = 1;
  struct stats *ancestor;
  char *name_space;

  for (ancestor = stats; (ancestor = ancestor->parent) != 0; )

    if (ancestor->stat.st_ino == stats->stat.st_ino
 && ancestor->stat.st_dev == stats->stat.st_dev)




      {
 if (!suppress_errors)
   fprintf (
# 992 "grep_single_original.c" 3 4
           stdout
# 992 "grep_single_original.c"
                 , gettext ("%s: warning: %s: %s\n"), prog, dir,
     gettext ("recursive directory loop"));
 return 1;
      }

  name_space = savedir (dir, (unsigned) stats->stat.st_size);

  if (! name_space)
    {
      if (
# 1001 "grep_single_original.c" 3 4
         (*__errno_location ())
# 1001 "grep_single_original.c"
              )
 {
   if (!suppress_errors)
     error (dir, 
# 1004 "grep_single_original.c" 3 4
                (*__errno_location ())
# 1004 "grep_single_original.c"
                     );
 }
      else
 fatal (gettext ("Memory exhausted"), 0);
    }
  else
    {
      size_t dirlen = strlen (dir);
      int needs_slash = ! (dirlen == 0
      || ((dir[dirlen - 1]) == '/'));
      char *file = 
# 1014 "grep_single_original.c" 3 4
                  ((void *)0)
# 1014 "grep_single_original.c"
                      ;
      char *namep = name_space;
      struct stats child;
      child.parent = stats;
      out_file += !no_filenames;
      while (*namep)
 {
   size_t namelen = strlen (namep);
   file = xrealloc (file, dirlen + 1 + namelen + 1);
   strcpy (file, dir);
   file[dirlen] = '/';
   strcpy (file + dirlen + needs_slash, namep);
   namep += namelen + 1;
   status &= grepfile (file, &child);
 }
      out_file -= !no_filenames;
      if (file)
        free (file);
      free (name_space);
    }

  return status;
}

static void
usage(status)
int status;
{
  if (status != 0)
    {
      fprintf (
# 1044 "grep_single_original.c" 3 4
              stdout
# 1044 "grep_single_original.c"
                    , gettext ("Usage: %s [OPTION]... PATTERN [FILE]...\n"), prog);
      fprintf (
# 1045 "grep_single_original.c" 3 4
              stdout
# 1045 "grep_single_original.c"
                    , gettext ("Try `%s --help' for more information.\n"), prog);
    }
  else
    {
      printf (gettext ("Usage: %s [OPTION]... PATTERN [FILE] ...\n"), prog);
      printf (gettext ("zzzSearch for PATTERN in each FILE or standard input.\nzzzExample: %s -i 'hello.*world' menu.h main.c\nzzz\nzzzRegexp selection and interpretation:\n")



                                        , prog);
      printf (gettext ("zzz  -E, --extended-regexp     PATTERN is an extended regular expression\nzzz  -F, --fixed-strings       PATTERN is a set of newline-separated strings\nzzz  -G, --basic-regexp        PATTERN is a basic regular expression\n")


                                                                     );
      printf (gettext ("zzz  -e, --regexp=PATTERN      use PATTERN as a regular expression\nzzz  -f, --file=FILE           obtain PATTERN from FILE\nzzz  -i, --ignore-case         ignore case distinctions\nzzz  -w, --word-regexp         force PATTERN to match only whole words\nzzz  -x, --line-regexp         force PATTERN to match only whole lines\nzzz  -z, --null-data           a data line ends in 0 byte, not newline\n")





                                                                       );
      printf (gettext ("zzz\nzzzMiscellaneous:\nzzz  -s, --no-messages         suppress error messages\nzzz  -v, --invert-match        select non-matching lines\nzzz  -V, --version             print version information and exit\nzzz      --help                display this help and exit\nzzz      --mmap                use memory-mapped input if possible\n")






                                                                   );
      printf (gettext ("zzz\nzzzOutput control:\nzzz  -b, --byte-offset         print the byte offset with output lines\nzzz  -n, --line-number         print line number with output lines\nzzz  -H, --with-filename       print the filename for each match\nzzz  -h, --no-filename         suppress the prefixing filename on output\nzzz  -q, --quiet, --silent     suppress all normal output\nzzz  -a, --text                do not suppress binary output\nzzz  -d, --directories=ACTION  how to handle directories\nzzz                            ACTION is 'read', 'recurse', or 'skip'.\nzzz  -r, --recursive           equivalent to --directories=recurse.\nzzz  -L, --files-without-match only print FILE names containing no match\nzzz  -l, --files-with-matches  only print FILE names containing matches\nzzz  -c, --count               only print a count of matching lines per FILE\nzzz  -Z, --null                print 0 byte after FILE name\n")
# 1089 "grep_single_original.c"
                                                            );
      printf (gettext ("zzz\nzzzContext control:\nzzz  -B, --before-context=NUM  print NUM lines of leading context\nzzz  -A, --after-context=NUM   print NUM lines of trailing context\nzzz  -C, --context[=NUM]       print NUM (default 2) lines of output context\nzzz                            unless overridden by -A or -B\nzzz  -NUM                      same as --context=NUM\nzzz  -U, --binary              do not strip CR characters at EOL (MSDOS)\nzzz  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\nzzz\nzzz`egrep' means `grep -E'.  `fgrep' means `grep -F'.\nzzzWith no FILE, or when FILE is -, read standard input.  If less than\nzzztwo FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\nzzzand 2 if trouble.\n")
# 1104 "grep_single_original.c"
                     );
      printf (gettext ("\nReport bugs to <bug-gnu-utils@gnu.org>.\n"));
    }
  exit (status);
}


static void
setmatcher (m)
     char const *m;
{
  if (matcher && strcmp (matcher, m) != 0)
    fatal (gettext ("conflicting matchers specified"), 0);
  matcher = m;
}



static int
install_matcher (name)
     char const *name;
{
  int i;




  for (i = 0; matchers[i].name; ++i)
    if (strcmp (name, matchers[i].name) == 0)
      {
 compile = matchers[i].compile;
 execute = matchers[i].execute;
# 1161 "grep_single_original.c"
 return 1;
      }
  return 0;
}






static int
prepend_args (options, buf, argv)
     char const *options;
     char *buf;
     char **argv;
{
  char const *o = options;
  char *b = buf;
  int n = 0;

  for (;;)
    {
      while ((1 && 
# 1183 "grep_single_original.c" 3 4
            ((*__ctype_b_loc ())[(int) ((
# 1183 "grep_single_original.c"
            (unsigned char) *o
# 1183 "grep_single_original.c" 3 4
            ))] & (unsigned short int) _ISspace)
# 1183 "grep_single_original.c"
            ))
 o++;
      if (!*o)
 return n;
      if (argv)
 argv[n] = b;
      n++;

      do
 if ((*b++ = *o++) == '\\' && *o)
   b[-1] = *o++;
      while (*o && ! (1 && 
# 1194 "grep_single_original.c" 3 4
                    ((*__ctype_b_loc ())[(int) ((
# 1194 "grep_single_original.c"
                    (unsigned char) *o
# 1194 "grep_single_original.c" 3 4
                    ))] & (unsigned short int) _ISspace)
# 1194 "grep_single_original.c"
                    ));

      *b++ = '\0';
    }
}




static void
prepend_default_options (options, pargc, pargv)
     char const *options;
     int *pargc;
     char ***pargv;
{
  if (options)
    {
      char *buf = xmalloc (strlen (options) + 1);
      int prepended = prepend_args (options, buf, (char **) 
# 1212 "grep_single_original.c" 3 4
                                                           ((void *)0)
# 1212 "grep_single_original.c"
                                                               );
      int argc = *pargc;
      char * const *argv = *pargv;
      char **pp = (char **) xmalloc ((prepended + argc + 1) * sizeof *pp);
      *pargc = prepended + argc;
      *pargv = pp;
      *pp++ = *argv++;
      pp += prepend_args (options, buf, pp);
      while ((*pp++ = *argv++))
 continue;
    }
}

int
main (argc, argv)
     int argc;
     char *argv[];
{
  char *keys;
  size_t keycc, oldcc, keyalloc;
  int with_filenames;
  int opt, cc, status;
  unsigned digit_args_val, default_context;
  FILE *fp;
  extern char *optarg;
  extern int optind;

  ;

  argv[0] = "target3";

  prog = argv[0];
  if (prog && strrchr (prog, '/'))
    prog = strrchr (prog, '/') + 1;
# 1272 "grep_single_original.c"
  keys = 
# 1272 "grep_single_original.c" 3 4
        ((void *)0)
# 1272 "grep_single_original.c"
            ;
  keycc = 0;
  with_filenames = 0;
  eolbyte = '\n';
  filename_mask = ~0;


  out_after = out_before = -1;

  default_context = 0;

  digit_args_val = 0;




  setlocale (
# 1288 "grep_single_original.c" 3 4
            6
# 1288 "grep_single_original.c"
                  , "");


  bindtextdomain ("grep", "/nfs/spectre/u4/jin/research/experiments/grep/docs/grep_2.4/lib/locale");
  textdomain ("grep");


  prepend_default_options (getenv ("GREP_OPTIONS"), &argc, &argv);

  while ((opt = getopt_long (argc, argv, short_options, long_options, 
# 1297 "grep_single_original.c" 3 4
                                                                     ((void *)0)
# 1297 "grep_single_original.c"
                                                                         ))
  != -1)
    switch (opt)
      {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
 digit_args_val = 10 * digit_args_val + opt - '0';
 default_context = digit_args_val;
 break;
      case 'A':
 if (optarg)
   {
     if (ck_atoi (optarg, &out_after))
       fatal (gettext ("invalid context length argument"), 0);
   }
 break;
      case 'B':
 if (optarg)
   {
     if (ck_atoi (optarg, &out_before))
       fatal (gettext ("invalid context length argument"), 0);
   }
 break;
      case 'C':


 if (optarg)
   {
     if (ck_atoi (optarg, &default_context))
       fatal (gettext ("invalid context length argument"), 0);
   }
 else
   default_context = 2;
 break;
      case 'E':
 setmatcher ("egrep");
 break;
      case 'F':
 setmatcher ("fgrep");
 break;
      case 'G':
 setmatcher ("grep");
 break;
      case 'H':
 with_filenames = 1;
 break;
      case 'U':



 break;
      case 'u':



 break;
      case 'V':
 show_version = 1;
 break;
      case 'X':
 setmatcher (optarg);
 break;
      case 'a':
 always_text = 1;
 break;
      case 'b':
 out_byte = 1;
 break;
      case 'c':
 out_quiet = 1;
 count_matches = 1;
 break;
      case 'd':
 if (strcmp (optarg, "read") == 0)
   directories = READ_DIRECTORIES;
 else if (strcmp (optarg, "skip") == 0)
   directories = SKIP_DIRECTORIES;
 else if (strcmp (optarg, "recurse") == 0)
   directories = RECURSE_DIRECTORIES;
 else
   fatal (gettext ("unknown directories method"), 0);
 break;
      case 'e':
 cc = strlen (optarg);
 keys = xrealloc (keys, keycc + cc + 1);
 strcpy (&keys[keycc], optarg);
 keycc += cc;
 keys[keycc++] = '\n';
 break;
      case 'f':
 fp = strcmp (optarg, "-") != 0 ? fopen (optarg, "r") : 
# 1395 "grep_single_original.c" 3 4
                                                       stdin
# 1395 "grep_single_original.c"
                                                            ;
 if (!fp)
   fatal (optarg, 
# 1397 "grep_single_original.c" 3 4
                 (*__errno_location ())
# 1397 "grep_single_original.c"
                      );
 for (keyalloc = 1; keyalloc <= keycc + 1; keyalloc *= 2)
   ;
 keys = xrealloc (keys, keyalloc);
 oldcc = keycc;
 while (!feof (fp)
        && (cc = fread (keys + keycc, 1, keyalloc - 1 - keycc, fp)) > 0)
   {
     keycc += cc;
     if (keycc == keyalloc - 1)
       keys = xrealloc (keys, keyalloc *= 2);
   }
 if (fp != 
# 1409 "grep_single_original.c" 3 4
          stdin
# 1409 "grep_single_original.c"
               )
   fclose(fp);

 if (oldcc != keycc && keys[keycc - 1] != '\n')
   keys[keycc++] = '\n';
 break;
      case 'h':
 no_filenames = 1;
 break;
      case 'i':
      case 'y':
 match_icase = 1;
 break;
      case 'L':


 out_quiet = 1;
 list_files = -1;
 done_on_match = 1;
 break;
      case 'l':
 out_quiet = 1;
 list_files = 1;
 done_on_match = 1;
 break;
      case 'n':
 out_line = 1;
 break;
      case 'q':
 done_on_match = 1;
 out_quiet = 1;
 break;
      case 'r':
 directories = RECURSE_DIRECTORIES;
 break;
      case 's':
 suppress_errors = 1;
 break;
      case 'v':
 out_invert = 1;
 break;
      case 'w':
 match_words = 1;
 break;
      case 'x':
 match_lines = 1;
 break;
      case 'Z':
 filename_mask = 0;
 break;
      case 'z':
 eolbyte = '\0';
 break;
      case 0:

 break;
      default:
 usage (2);
 break;
      }

  if (out_after < 0)
    out_after = default_context;
  if (out_before < 0)
    out_before = default_context;

  if (! matcher)
    matcher = "grep";

  if (show_version)
    {
      printf (gettext ("%s (GNU grep) %s\n"), matcher, "2.4");
      printf ("\n");
      printf (gettext ("zzzCopyright (C) 1988, 1992-1998, 1999 Free Software Foundation, Inc.\n")
                                                                      );
      printf (gettext ("zzzThis is free software; see the source for copying conditions. There is NO\nzzzwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n")

                                                                               );
      printf ("\n");
      exit (0);
    }

  if (show_help)
    usage (0);

  if (keys)
    {
      if (keycc == 0)

        out_invert ^= 1;
      else

        --keycc;
    }
  else
    if (optind < argc)
      {
 keys = argv[optind++];
 keycc = strlen (keys);
      }
    else
      usage (2);

  if (!install_matcher (matcher) && !install_matcher ("default"))
    abort ();

  (*compile)(keys, keycc);

  if ((argc - optind > 1 && !no_filenames) || with_filenames)
    out_file = 1;
# 1528 "grep_single_original.c"
  if (optind < argc)
    {
 status = 1;
 do
 {
   char *file = argv[optind];
   status &= grepfile (strcmp (file, "-") == 0 ? (char *) 
# 1534 "grep_single_original.c" 3 4
                                                         ((void *)0) 
# 1534 "grep_single_original.c"
                                                              : file,
         &stats_base);
 }
 while ( ++optind < argc);
    }
  else
    status = grepfile ((char *) 
# 1540 "grep_single_original.c" 3 4
                               ((void *)0)
# 1540 "grep_single_original.c"
                                   , &stats_base);

  if (fclose (
# 1542 "grep_single_original.c" 3 4
             stdout
# 1542 "grep_single_original.c"
                   ) == 
# 1542 "grep_single_original.c" 3 4
                        (-1)
# 1542 "grep_single_original.c"
                           )
    error (gettext ("writing output"), 
# 1543 "grep_single_original.c" 3 4
                               (*__errno_location ())
# 1543 "grep_single_original.c"
                                    );

  exit (errseen ? 2 : status);
}
# 1574 "grep_single_original.c"
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4




# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 1575 "grep_single_original.c" 2
# 1657 "grep_single_original.c"
# 1 "regex.h" 1
# 44 "regex.h"

# 44 "regex.h"
typedef long int s_reg_t;
typedef unsigned long int active_reg_t;






typedef unsigned long int reg_syntax_t;
# 167 "regex.h"
extern reg_syntax_t re_syntax_options;
# 283 "regex.h"
typedef enum
{




  REG_NOERROR = 0,
  REG_NOMATCH,



  REG_BADPAT,
  REG_ECOLLATE,
  REG_ECTYPE,
  REG_EESCAPE,
  REG_ESUBREG,
  REG_EBRACK,
  REG_EPAREN,
  REG_EBRACE,
  REG_BADBR,
  REG_ERANGE,
  REG_ESPACE,
  REG_BADRPT,


  REG_EEND,
  REG_ESIZE,
  REG_ERPAREN
} reg_errcode_t;
# 323 "regex.h"
struct re_pattern_buffer
{




  unsigned char *buffer;


  unsigned long int allocated;


  unsigned long int used;


  reg_syntax_t syntax;




  char *fastmap;





  char * translate;


  size_t re_nsub;






  unsigned can_be_null : 1;
# 368 "regex.h"
  unsigned regs_allocated : 2;



  unsigned fastmap_accurate : 1;



  unsigned no_sub : 1;



  unsigned not_bol : 1;


  unsigned not_eol : 1;


  unsigned newline_anchor : 1;


};

typedef struct re_pattern_buffer regex_t;


typedef int regoff_t;




struct re_registers
{
  unsigned num_regs;
  regoff_t *start;
  regoff_t *end;
};
# 418 "regex.h"
typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
} regmatch_t;
# 444 "regex.h"
extern reg_syntax_t __re_set_syntax (reg_syntax_t syntax);
extern reg_syntax_t re_set_syntax (reg_syntax_t syntax);




extern const char *__re_compile_pattern
  (const char *pattern, size_t length, struct re_pattern_buffer *buffer)
                                               ;
extern const char *re_compile_pattern
  (const char *pattern, size_t length, struct re_pattern_buffer *buffer)
                                               ;





extern int __re_compile_fastmap (struct re_pattern_buffer *buffer);
extern int re_compile_fastmap (struct re_pattern_buffer *buffer);







extern int __re_search
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs)
                                                                         ;
extern int re_search
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs)
                                                                         ;




extern int __re_search_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, int range, struct re_registers *regs, int stop)

                                                                        ;
extern int re_search_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, int range, struct re_registers *regs, int stop)

                                                                        ;




extern int __re_match
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs)
                                                               ;
extern int re_match
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs)
                                                               ;



extern int __re_match_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, struct re_registers *regs, int stop)

                                                             ;
extern int re_match_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, struct re_registers *regs, int stop)

                                                             ;
# 523 "regex.h"
extern void __re_set_registers
  (struct re_pattern_buffer *buffer, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends)
                                                                  ;
extern void re_set_registers
  (struct re_pattern_buffer *buffer, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends)
                                                                  ;
# 539 "regex.h"
extern int __regcomp (regex_t *__preg, const char *__pattern, int __cflags)
                  ;
extern int regcomp (regex_t *__preg, const char *__pattern, int __cflags)
                       ;

extern int __regexec (const regex_t *__preg, const char *__string, size_t __nmatch, regmatch_t __pmatch[], int __eflags)

                                         ;
extern int regexec (const regex_t *__preg, const char *__string, size_t __nmatch, regmatch_t __pmatch[], int __eflags)

                                              ;

extern size_t __regerror (int __errcode, const regex_t *__preg, char *__errbuf, size_t __errbuf_size)
                                              ;
extern size_t regerror (int __errcode, const regex_t *__preg, char *__errbuf, size_t __errbuf_size)
                                            ;

extern void __regfree (regex_t *__preg);
extern void regfree (regex_t *__preg);
# 1658 "grep_single_original.c" 2
# 1 "dfa.h" 1
# 57 "dfa.h"
typedef int charclass[(((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))];





typedef enum
{
  END = -1,







  EMPTY = (1 << 8),


  BACKREF,






  BEGLINE,



  ENDLINE,



  BEGWORD,



  ENDWORD,



  LIMWORD,



  NOTLIMWORD,



  QMARK,



  STAR,



  PLUS,



  REPMN,



  CAT,




  OR,


  ORTOP,


  LPAREN,


  RPAREN,

  CSET


} token;
# 201 "dfa.h"
typedef struct
{
  unsigned strchr;
  unsigned constraint;
} position;


typedef struct
{
  position *elems;
  int nelem;
} position_set;




typedef struct
{
  int hash;
  position_set elems;
  char newline;
  char letter;
  char backref;
  unsigned char constraint;
  int first_end;
} dfa_state;



struct dfamust
{
  int exact;
  char *must;
  struct dfamust *next;
};


struct dfa
{

  charclass *charclasses;
  int cindex;
  int calloc;


  token *tokens;
  int tindex;
  int talloc;
  int depth;


  int nleaves;
  int nregexps;



  dfa_state *states;
  int sindex;
  int salloc;


  position_set *follows;






  int searchflag;
# 278 "dfa.h"
  int tralloc;

  int trcount;

  int **trans;




  int **realtrans;

  int **fails;

  int *success;

  int *newlines;






  struct dfamust *musts;


};
# 326 "dfa.h"
extern void dfasyntax (reg_syntax_t, int, int);




extern void dfacomp (char *, size_t, struct dfa *, int);
# 345 "dfa.h"
extern char *dfaexec (struct dfa *, char *, char *, int, int *, int *);


extern void dfafree (struct dfa *);




extern void dfainit (struct dfa *);


extern void dfaparse (char *, size_t, struct dfa *);



extern void dfaanalyze (struct dfa *, int);



extern void dfastate (int, struct dfa *, int []);







extern void dfaerror (const char *);
# 1659 "grep_single_original.c" 2
# 1668 "grep_single_original.c"
static void dfamust (struct dfa *dfa);

static ptr_t xcalloc (size_t n, size_t s);
static ptr_t xmalloc_1 (size_t n);
static ptr_t xrealloc_1 (ptr_t p, size_t n);



static int tstbit (int b, charclass c);
static void setbit (int b, charclass c);
static void clrbit (int b, charclass c);
static void copyset (charclass src, charclass dst);
static void zeroset (charclass s);
static void notset (charclass s);
static int equal (charclass s1, charclass s2);
static int charclass_index (charclass s);
static int looking_at (const char *s);
static token lex (void);
static void addtok (token t);
static void atom (void);
static int nsubtoks (int tindex);
static void copytoks (int tindex, int ntokens);
static void closure (void);
static void branch (void);
static void regexp (int toplevel);
static void copy (position_set *src, position_set *dst);
static void insert (position p, position_set *s);
static void merge (position_set *s1, position_set *s2, position_set *m);
static void delete (position p, position_set *s);
static int state_index (struct dfa *d, position_set *s, int newline, int letter)
                              ;
static void build_state (int s, struct dfa *d);
static void build_state_zero (struct dfa *d);
static char *icatalloc (char *old, char *new);
static char *icpyalloc (char *string);
static char *istrstr (char *lookin, char *lookfor);
static void ifree (char *cp);
static void freelist (char **cpp);
static char **enlist (char **cpp, char *new, size_t len);
static char **comsubs (char *left, char *right);
static char **addlists (char **old, char **new);
static char **inboth (char **left, char **right);

static ptr_t
xcalloc(n, s)
     size_t n;
     size_t s;
{
  ptr_t r = calloc(n, s);

  if (!r)
    dfaerror(gettext ("Memory exhausted"));
  return r;
}

static ptr_t
xmalloc_1(n)
     size_t n;
{
  ptr_t r = malloc(n);

  ;
  if (!r)
    dfaerror(gettext ("Memory exhausted"));
  return r;
}

static ptr_t
xrealloc_1(p, n)
     ptr_t p;
     size_t n;
{
  ptr_t r = realloc(p, n);

  ;
  if (!r)
    dfaerror(gettext ("Memory exhausted"));
  return r;
}
# 1802 "grep_single_original.c"
static int
tstbit(b, c)
     int b;
     charclass c;
{
  return c[b / (8 * sizeof (int))] & 1 << b % (8 * sizeof (int));
}

static void
setbit(b, c)
     int b;
     charclass c;
{
  c[b / (8 * sizeof (int))] |= 1 << b % (8 * sizeof (int));
}

static void
clrbit(b, c)
     int b;
     charclass c;
{
  c[b / (8 * sizeof (int))] &= ~(1 << b % (8 * sizeof (int)));
}

static void
copyset(src, dst)
     charclass src;
     charclass dst;
{
  int i;

  for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i)
    dst[i] = src[i];
}

static void
zeroset(s)
     charclass s;
{
  int i;

  for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i)
    s[i] = 0;
}

static void
notset(s)
     charclass s;
{
  int i;

  for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i)
    s[i] = ~s[i];
}

static int
equal(s1, s2)
     charclass s1;
     charclass s2;
{
  int i;

  for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i)
    if (s1[i] != s2[i])
      return 0;
  return 1;
}


static struct dfa *dfa;


static int
charclass_index(s)
     charclass s;
{
  int i;

  for (i = 0; i < dfa->cindex; ++i)
    if (equal(s, dfa->charclasses[i]))
      return i;
  zzz if ((dfa->cindex) >= (dfa->calloc)) zzz { zzz while ((dfa->cindex) >= (dfa->calloc)) zzz (dfa->calloc) *= 2; zzz ((dfa->charclasses) = (charclass *) xrealloc_1((ptr_t) (dfa->charclasses), (dfa->calloc) * sizeof (charclass))); zzz };
  ++dfa->cindex;
  copyset(s, dfa->charclasses[i]);
  return i;
}


static reg_syntax_t syntax_bits, syntax_bits_set;


static int case_fold;


static unsigned char eolbyte_1;


void
dfasyntax(bits, fold, eol)
     reg_syntax_t bits;
     int fold;
     int eol;
{
  syntax_bits_set = 1;
  syntax_bits = bits;
  case_fold = fold;
  eolbyte_1 = eol;
}






static char *lexstart;
static char *lexptr;
static int lexleft;
static token lasttok;
static int laststart;

static int parens;
static int minrep, maxrep;
# 1943 "grep_single_original.c"
static int is_alpha(int c) { return 
# 1943 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1943 "grep_single_original.c"
c
# 1943 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISalpha)
# 1943 "grep_single_original.c"
; }
static int is_upper(int c) { return 
# 1944 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1944 "grep_single_original.c"
c
# 1944 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISupper)
# 1944 "grep_single_original.c"
; }
static int is_lower(int c) { return 
# 1945 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1945 "grep_single_original.c"
c
# 1945 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISlower)
# 1945 "grep_single_original.c"
; }
static int is_digit(int c) { return 
# 1946 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1946 "grep_single_original.c"
c
# 1946 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISdigit)
# 1946 "grep_single_original.c"
; }
static int is_xdigit(int c) { return 
# 1947 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1947 "grep_single_original.c"
c
# 1947 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISxdigit)
# 1947 "grep_single_original.c"
; }
static int is_space(int c) { return 
# 1948 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1948 "grep_single_original.c"
c
# 1948 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISspace)
# 1948 "grep_single_original.c"
; }
static int is_punct(int c) { return 
# 1949 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1949 "grep_single_original.c"
c
# 1949 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISpunct)
# 1949 "grep_single_original.c"
; }
static int is_alnum(int c) { return 
# 1950 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1950 "grep_single_original.c"
c
# 1950 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISalnum)
# 1950 "grep_single_original.c"
; }
static int is_print(int c) { return 
# 1951 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1951 "grep_single_original.c"
c
# 1951 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISprint)
# 1951 "grep_single_original.c"
; }
static int is_graph(int c) { return 
# 1952 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1952 "grep_single_original.c"
c
# 1952 "grep_single_original.c" 3 4
))] & (unsigned short int) _ISgraph)
# 1952 "grep_single_original.c"
; }
static int is_cntrl(int c) { return 
# 1953 "grep_single_original.c" 3 4
((*__ctype_b_loc ())[(int) ((
# 1953 "grep_single_original.c"
c
# 1953 "grep_single_original.c" 3 4
))] & (unsigned short int) _IScntrl)
# 1953 "grep_single_original.c"
; }

static int is_blank(c)
int c;
{
   return (c == ' ' || c == '\t');
}




static struct {
  const char *name;
  int (*pred) (int);
} prednames[] = {
  { ":alpha:]", is_alpha },
  { ":upper:]", is_upper },
  { ":lower:]", is_lower },
  { ":digit:]", is_digit },
  { ":xdigit:]", is_xdigit },
  { ":space:]", is_space },
  { ":punct:]", is_punct },
  { ":alnum:]", is_alnum },
  { ":print:]", is_print },
  { ":graph:]", is_graph },
  { ":cntrl:]", is_cntrl },
  { ":blank:]", is_blank },
  { 0 }
};




static int
looking_at(s)
     const char *s;
{
  size_t len;

  len = strlen(s);
  if (lexleft < len)
    return 0;
  return strncmp(s, lexptr, len) == 0;
}

static token
lex()
{
  token c, c1, c2;
  int backslash = 0, invert;
  charclass ccl;
  int i;







  for (i = 0; i < 2; ++i)
    {
      zzz { zzz if (! lexleft) zzz if (0 != 0) zzz dfaerror(0); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
      switch (c)
 {
 case '\\':
   if (backslash)
     goto normal_char;
   if (lexleft == 0)
     dfaerror(gettext ("Unfinished \\ escape"));
   backslash = 1;
   break;

 case '^':
   if (backslash)
     goto normal_char;
   if (syntax_bits & (((((unsigned long int) 1) << 1) << 1) << 1)
       || lasttok == END
       || lasttok == LPAREN
       || lasttok == OR)
     return lasttok = BEGLINE;
   goto normal_char;

 case '$':
   if (backslash)
     goto normal_char;
   if (syntax_bits & (((((unsigned long int) 1) << 1) << 1) << 1)
       || lexleft == 0
       || (syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
    ? lexleft > 0 && *lexptr == ')'
    : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
       || (syntax_bits & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
    ? lexleft > 0 && *lexptr == '|'
    : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
       || ((syntax_bits & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
           && lexleft > 0 && *lexptr == '\n'))
     return lasttok = ENDLINE;
   goto normal_char;

 case '1':
 case '2':
 case '3':
 case '4':
 case '5':
 case '6':
 case '7':
 case '8':
 case '9':
   if (backslash && !(syntax_bits & ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     {
       laststart = 0;
       return lasttok = BACKREF;
     }
   goto normal_char;

 case '`':
   if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     return lasttok = BEGLINE;
   goto normal_char;

 case '\'':
   if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     return lasttok = ENDLINE;
   goto normal_char;

 case '<':
   if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     return lasttok = BEGWORD;
   goto normal_char;

 case '>':
   if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     return lasttok = ENDWORD;
   goto normal_char;

 case 'b':
   if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     return lasttok = LIMWORD;
   goto normal_char;

 case 'B':
   if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     return lasttok = NOTLIMWORD;
   goto normal_char;

 case '?':
   if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
     goto normal_char;
   if (backslash != ((syntax_bits & (((unsigned long int) 1) << 1)) != 0))
     goto normal_char;
   if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
     goto normal_char;
   return lasttok = QMARK;

 case '*':
   if (backslash)
     goto normal_char;
   if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
     goto normal_char;
   return lasttok = STAR;

 case '+':
   if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
     goto normal_char;
   if (backslash != ((syntax_bits & (((unsigned long int) 1) << 1)) != 0))
     goto normal_char;
   if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
     goto normal_char;
   return lasttok = PLUS;

 case '{':
   if (!(syntax_bits & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     goto normal_char;
   if (backslash != ((syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
     goto normal_char;
   if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
     goto normal_char;

   if (syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
     {


       int lo = -1, hi = -1;
       char const *p = lexptr;
       char const *lim = p + lexleft;
       for (; p != lim && 
# 2137 "grep_single_original.c" 3 4
                          ((*__ctype_b_loc ())[(int) ((
# 2137 "grep_single_original.c"
                          *p
# 2137 "grep_single_original.c" 3 4
                          ))] & (unsigned short int) _ISdigit)
# 2137 "grep_single_original.c"
                                      ; p++)
  lo = (lo < 0 ? 0 : lo * 10) + *p - '0';
       if (p != lim && *p == ',')

  while (++p != lim && 
# 2141 "grep_single_original.c" 3 4
                      ((*__ctype_b_loc ())[(int) ((
# 2141 "grep_single_original.c"
                      *p
# 2141 "grep_single_original.c" 3 4
                      ))] & (unsigned short int) _ISdigit)
# 2141 "grep_single_original.c"
                                  )
    hi = (hi < 0 ? 0 : hi * 10) + *p - '0';




       else
  hi = lo;

       if (p == lim || *p != '}'
    || lo < 0 || (0x7fff) < hi || (0 <= hi && hi < lo))
  goto normal_char;





     }

   minrep = 0;




   zzz { zzz if (! lexleft) zzz if (gettext ("unfinished repeat count") != 0) zzz dfaerror(gettext ("unfinished repeat count")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
   if (
# 2166 "grep_single_original.c" 3 4
      ((*__ctype_b_loc ())[(int) ((
# 2166 "grep_single_original.c"
      c
# 2166 "grep_single_original.c" 3 4
      ))] & (unsigned short int) _ISdigit)
# 2166 "grep_single_original.c"
                )
     {
       minrep = c - '0';
       for (;;)
  {
    zzz { zzz if (! lexleft) zzz if (gettext ("unfinished repeat count") != 0) zzz dfaerror(gettext ("unfinished repeat count")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
    if (!
# 2172 "grep_single_original.c" 3 4
        ((*__ctype_b_loc ())[(int) ((
# 2172 "grep_single_original.c"
        c
# 2172 "grep_single_original.c" 3 4
        ))] & (unsigned short int) _ISdigit)
# 2172 "grep_single_original.c"
                  )
      break;
    minrep = 10 * minrep + c - '0';
  }
     }

   else



     dfaerror(gettext ("malformed repeat count"));
   if (c == ',')
     {
       zzz { zzz if (! lexleft) zzz if (gettext ("unfinished repeat count") != 0) zzz dfaerror(gettext ("unfinished repeat count")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
       if (! 
# 2186 "grep_single_original.c" 3 4
            ((*__ctype_b_loc ())[(int) ((
# 2186 "grep_single_original.c"
            c
# 2186 "grep_single_original.c" 3 4
            ))] & (unsigned short int) _ISdigit)
# 2186 "grep_single_original.c"
                       )
  maxrep = -1;
       else
  {
    maxrep = c - '0';
    for (;;)
      {
        zzz { zzz if (! lexleft) zzz if (gettext ("unfinished repeat count") != 0) zzz dfaerror(gettext ("unfinished repeat count")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
        if (! 
# 2194 "grep_single_original.c" 3 4
             ((*__ctype_b_loc ())[(int) ((
# 2194 "grep_single_original.c"
             c
# 2194 "grep_single_original.c" 3 4
             ))] & (unsigned short int) _ISdigit)
# 2194 "grep_single_original.c"
                        )
   break;
        maxrep = 10 * maxrep + c - '0';
      }
    if (0 <= maxrep && maxrep < minrep)
      dfaerror (gettext ("malformed repeat count"));
  }
     }
   else
     maxrep = minrep;
   if (!(syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     {
       if (c != '\\')
  dfaerror(gettext ("malformed repeat count"));
       zzz { zzz if (! lexleft) zzz if (gettext ("unfinished repeat count") != 0) zzz dfaerror(gettext ("unfinished repeat count")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
     }
   if (c != '}')
     dfaerror(gettext ("malformed repeat count"));
   laststart = 0;
   return lasttok = REPMN;

 case '|':
   if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
     goto normal_char;
   if (backslash != ((syntax_bits & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
     goto normal_char;
   laststart = 1;
   return lasttok = OR;

 case '\n':
   if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
       || backslash
       || !(syntax_bits & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     goto normal_char;
   laststart = 1;
   return lasttok = OR;

 case '(':
   if (backslash != ((syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
     goto normal_char;
   ++parens;
   laststart = 1;
   return lasttok = LPAREN;

 case ')':
   if (backslash != ((syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
     goto normal_char;
   if (parens == 0 && syntax_bits & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
     goto normal_char;
   --parens;
   laststart = 0;
   return lasttok = RPAREN;

 case '.':
   if (backslash)
     goto normal_char;
   zeroset(ccl);
   notset(ccl);
   if (!(syntax_bits & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     clrbit(eolbyte_1, ccl);
   if (syntax_bits & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
     clrbit('\0', ccl);
   laststart = 0;
   return lasttok = CSET + charclass_index(ccl);

 case 'w':
 case 'W':
   if (!backslash || (syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
     goto normal_char;
   zeroset(ccl);
   for (c2 = 0; c2 < (1 << 8); ++c2)
     if ((
# 2265 "grep_single_original.c" 3 4
        ((*__ctype_b_loc ())[(int) ((
# 2265 "grep_single_original.c"
        c2
# 2265 "grep_single_original.c" 3 4
        ))] & (unsigned short int) _ISalnum) 
# 2265 "grep_single_original.c"
        || (c2) == '_'))
       setbit(c2, ccl);
   if (c == 'W')
     notset(ccl);
   laststart = 0;
   return lasttok = CSET + charclass_index(ccl);

 case '[':
   if (backslash)
     goto normal_char;
   zeroset(ccl);
   zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
   if (c == '^')
     {
       zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
       invert = 1;
     }
   else
     invert = 0;
   do
     {






       if (c == '[' && (syntax_bits & ((((unsigned long int) 1) << 1) << 1)))
  for (c1 = 0; prednames[c1].name; ++c1)
    if (looking_at(prednames[c1].name))
      {
   int (*pred)() = prednames[c1].pred;
   if (case_fold
       && (pred == is_upper || pred == is_lower))
    pred = is_alpha;

        for (c2 = 0; c2 < (1 << 8); ++c2)
   if ((*pred)(c2))
     setbit(c2, ccl);
        lexptr += strlen(prednames[c1].name);
        lexleft -= strlen(prednames[c1].name);
        zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c1) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
        goto skip;
      }
       if (c == '\\' && (syntax_bits & ((unsigned long int) 1)))
  zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
       zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c1) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
       if (c1 == '-')
  {
    zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c2) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
    if (c2 == ']')
      {


        --lexptr;
        ++lexleft;
        c2 = c;
      }
    else
      {
        if (c2 == '\\'
     && (syntax_bits & ((unsigned long int) 1)))
   zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c2) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
        zzz { zzz if (! lexleft) zzz if (gettext ("Unbalanced [") != 0) zzz dfaerror(gettext ("Unbalanced [")); zzz else zzz return lasttok = END; zzz (c1) = (unsigned char) *lexptr++; zzz --lexleft; zzz };
      }
  }
       else
  c2 = c;
       while (c <= c2)
  {
    setbit(c, ccl);
    if (case_fold)
      if (
# 2337 "grep_single_original.c" 3 4
         ((*__ctype_b_loc ())[(int) ((
# 2337 "grep_single_original.c"
         c
# 2337 "grep_single_original.c" 3 4
         ))] & (unsigned short int) _ISupper)
# 2337 "grep_single_original.c"
                   )
        setbit(tolower(c), ccl);
      else if (
# 2339 "grep_single_original.c" 3 4
              ((*__ctype_b_loc ())[(int) ((
# 2339 "grep_single_original.c"
              c
# 2339 "grep_single_original.c" 3 4
              ))] & (unsigned short int) _ISlower)
# 2339 "grep_single_original.c"
                        )
        setbit(toupper(c), ccl);
    ++c;
  }
     skip:
       ;
     }
   while ((c = c1) != ']');
   if (invert)
     {
       notset(ccl);
       if (syntax_bits & ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  clrbit(eolbyte_1, ccl);
     }
   laststart = 0;
   return lasttok = CSET + charclass_index(ccl);

 default:
 normal_char:
   laststart = 0;
   if (case_fold && 
# 2359 "grep_single_original.c" 3 4
                   ((*__ctype_b_loc ())[(int) ((
# 2359 "grep_single_original.c"
                   c
# 2359 "grep_single_original.c" 3 4
                   ))] & (unsigned short int) _ISalpha)
# 2359 "grep_single_original.c"
                             )
     {
       zeroset(ccl);
       setbit(c, ccl);
       if (
# 2363 "grep_single_original.c" 3 4
          ((*__ctype_b_loc ())[(int) ((
# 2363 "grep_single_original.c"
          c
# 2363 "grep_single_original.c" 3 4
          ))] & (unsigned short int) _ISupper)
# 2363 "grep_single_original.c"
                    )
  setbit(tolower(c), ccl);
       else
  setbit(toupper(c), ccl);
       return lasttok = CSET + charclass_index(ccl);
     }
   return c;
 }
    }



  abort();
  return END;
}



static token tok;
static int depth;







static void
addtok(t)
     token t;
{
  zzz if ((dfa->tindex) >= (dfa->talloc)) zzz { zzz while ((dfa->tindex) >= (dfa->talloc)) zzz (dfa->talloc) *= 2; zzz ((dfa->tokens) = (token *) xrealloc_1((ptr_t) (dfa->tokens), (dfa->talloc) * sizeof (token))); zzz };
  dfa->tokens[dfa->tindex++] = t;

  switch (t)
    {
    case QMARK:
    case STAR:
    case PLUS:
      break;

    case CAT:
    case OR:
    case ORTOP:
      --depth;
      break;

    default:
      ++dfa->nleaves;
    case EMPTY:
      ++depth;
      break;
    }
  if (depth > dfa->depth)
    dfa->depth = depth;
}
# 2450 "grep_single_original.c"
static void
atom()
{
  if ((tok >= 0 && tok < (1 << 8)) || tok >= CSET || tok == BACKREF
      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
    {
      addtok(tok);
      tok = lex();
    }
  else if (tok == LPAREN)
    {
      tok = lex();
      regexp(0);
      if (tok != RPAREN)
 dfaerror(gettext ("Unbalanced ("));
      tok = lex();
    }
  else
    addtok(EMPTY);
}


static int
nsubtoks(tindex)
int tindex;
{
  int ntoks1;

  switch (dfa->tokens[tindex - 1])
    {
    default:
      return 1;
    case QMARK:
    case STAR:
    case PLUS:
      return 1 + nsubtoks(tindex - 1);
    case CAT:
    case OR:
    case ORTOP:
      ntoks1 = nsubtoks(tindex - 1);
      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
    }
}


static void
copytoks(tindex, ntokens)
     int tindex, ntokens;
{
  int i;

  for (i = 0; i < ntokens; ++i)
    addtok(dfa->tokens[tindex + i]);
}

static void
closure()
{
  int tindex, ntokens, i;

  atom();
  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
    if (tok == REPMN)
      {
 ntokens = nsubtoks(dfa->tindex);
 tindex = dfa->tindex - ntokens;

 if (maxrep < 0)



   addtok(PLUS);
 if (minrep == 0)
   addtok(QMARK);
 for (i = 1; i < minrep; ++i)
   {
     copytoks(tindex, ntokens);
     addtok(CAT);
   }
 for (; i < maxrep; ++i)
   {
     copytoks(tindex, ntokens);
     addtok(QMARK);
     addtok(CAT);
   }
 tok = lex();
      }
    else
      {
 addtok(tok);
 tok = lex();
      }
}

static void
branch()
{
  closure();
  while (tok != RPAREN && tok != OR && tok >= 0)
    {
      closure();
      addtok(CAT);
    }
}

static void
regexp(toplevel)
     int toplevel;
{
  branch();
  while (tok == OR)
    {
      tok = lex();
      branch();
      if (toplevel)
 addtok(ORTOP);
      else
 addtok(OR);
    }
}




void
dfaparse(s, len, d)
     char *s;
     size_t len;
     struct dfa *d;

{
  dfa = d;
  lexstart = lexptr = s;
  lexleft = len;
  lasttok = END;
  laststart = 1;
  parens = 0;

  if (! syntax_bits_set)
    dfaerror(gettext ("No syntax specified"));

  tok = lex();
  depth = d->depth;

  regexp(1);

  if (tok != END)
    dfaerror(gettext ("Unbalanced )"));

  addtok(END - d->nregexps);
  addtok(CAT);

  if (d->nregexps)
    addtok(ORTOP);

  ++d->nregexps;
}




static void
copy(src, dst)
     position_set *src;
     position_set *dst;
{
  int i;

  for (i = 0; i < src->nelem; ++i)
    dst->elems[i] = src->elems[i];
  dst->nelem = src->nelem;
}





static void
insert(p, s)
     position p;
     position_set *s;
{
  int i;
  position t1, t2;

  for (i = 0; i < s->nelem && p.strchr < s->elems[i].strchr; ++i)
    continue;
  if (i < s->nelem && p.strchr == s->elems[i].strchr)
    s->elems[i].constraint |= p.constraint;
  else
    {
      t1 = p;
      ++s->nelem;
      while (i < s->nelem)
 {
   t2 = s->elems[i];
   s->elems[i++] = t1;
   t1 = t2;
 }
    }
}



static void
merge(s1, s2, m)
     position_set *s1;
     position_set *s2;
     position_set *m;
{
  int i = 0, j = 0;

  m->nelem = 0;
  while (i < s1->nelem && j < s2->nelem)
    if (s1->elems[i].strchr > s2->elems[j].strchr)
      m->elems[m->nelem++] = s1->elems[i++];
    else if (s1->elems[i].strchr < s2->elems[j].strchr)
      m->elems[m->nelem++] = s2->elems[j++];
    else
      {
 m->elems[m->nelem] = s1->elems[i++];
 m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
      }
  while (i < s1->nelem)
    m->elems[m->nelem++] = s1->elems[i++];
  while (j < s2->nelem)
    m->elems[m->nelem++] = s2->elems[j++];
}


static void
delete(p, s)
     position p;
     position_set *s;
{
  int i;

  for (i = 0; i < s->nelem; ++i)
    if (p.strchr == s->elems[i].strchr)
      break;
  if (i < s->nelem)
    for (--s->nelem; i < s->nelem; ++i)
      s->elems[i] = s->elems[i + 1];
}





static int
state_index(d, s, newline, letter)
     struct dfa *d;
     position_set *s;
     int newline;
     int letter;
{
  int hash = 0;
  int constraint;
  int i, j;

  newline = newline ? 1 : 0;
  letter = letter ? 1 : 0;

  for (i = 0; i < s->nelem; ++i)
    hash ^= s->elems[i].strchr + s->elems[i].constraint;


  for (i = 0; i < d->sindex; ++i)
    {
      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
   || newline != d->states[i].newline || letter != d->states[i].letter)
 continue;
      for (j = 0; j < s->nelem; ++j)
 if (s->elems[j].constraint
     != d->states[i].elems.elems[j].constraint
     || s->elems[j].strchr != d->states[i].elems.elems[j].strchr)
   break;
      if (j == s->nelem)
 return i;
    }


  zzz if ((d->sindex) >= (d->salloc)) zzz { zzz while ((d->sindex) >= (d->salloc)) zzz (d->salloc) *= 2; zzz ((d->states) = (dfa_state *) xrealloc_1((ptr_t) (d->states), (d->salloc) * sizeof (dfa_state))); zzz };
  d->states[i].hash = hash;
  ((d->states[i].elems.elems) = (position *) xmalloc_1((s->nelem) * sizeof (position)));
  copy(s, &d->states[i].elems);
  d->states[i].newline = newline;
  d->states[i].letter = letter;
  d->states[i].backref = 0;
  d->states[i].constraint = 0;
  d->states[i].first_end = 0;
  for (j = 0; j < s->nelem; ++j)
    if (d->tokens[s->elems[j].strchr] < 0)
      {
 constraint = s->elems[j].constraint;
 if ((((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0))))
     || (((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0))))
     || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0))))
     || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))))
   d->states[i].constraint |= constraint;
 if (! d->states[i].first_end)
   d->states[i].first_end = d->tokens[s->elems[j].strchr];
      }
    else if (d->tokens[s->elems[j].strchr] == BACKREF)
      {
 d->states[i].constraint = 0xff;
 d->states[i].backref = 1;
      }

  ++d->sindex;

  return i;
}






static void epsclosure (position_set *s, struct dfa *d);

static void
epsclosure(s, d)
     position_set *s;
     struct dfa *d;
{
  int i, j;
  int *visited;
  position p, old;

  ((visited) = (int *) xmalloc_1((d->tindex) * sizeof (int)));
  for (i = 0; i < d->tindex; ++i)
    visited[i] = 0;

  for (i = 0; i < s->nelem; ++i)
    if (d->tokens[s->elems[i].strchr] >= (1 << 8)
 && d->tokens[s->elems[i].strchr] != BACKREF
 && d->tokens[s->elems[i].strchr] < CSET)
      {
 old = s->elems[i];
 p.constraint = old.constraint;
 delete(s->elems[i], s);
 if (visited[old.strchr])
   {
     --i;
     continue;
   }
 visited[old.strchr] = 1;
 switch (d->tokens[old.strchr])
   {
   case BEGLINE:
     p.constraint &= 0xcf;
     break;
   case ENDLINE:
     p.constraint &= 0xaf;
     break;
   case BEGWORD:
     p.constraint &= 0xf2;
     break;
   case ENDWORD:
     p.constraint &= 0xf4;
     break;
   case LIMWORD:
     p.constraint &= 0xf6;
     break;
   case NOTLIMWORD:
     p.constraint &= 0xf9;
     break;
   default:
     break;
   }
 for (j = 0; j < d->follows[old.strchr].nelem; ++j)
   {
     p.strchr = d->follows[old.strchr].elems[j].strchr;
     insert(p, s);
   }

 i = -1;
      }

  free(visited);
}
# 2886 "grep_single_original.c"
void
dfaanalyze(d, searchflag)
     struct dfa *d;
     int searchflag;
{
  int *nullable;
  int *nfirstpos;
  position *firstpos;
  int *nlastpos;
  position *lastpos;
  int *nalloc;
  position_set tmp;
  position_set merged;
  int wants_newline;
  int *o_nullable;
  int *o_nfirst, *o_nlast;
  position *o_firstpos, *o_lastpos;
  int i, j;
  position *pos;
# 2916 "grep_single_original.c"
  d->searchflag = searchflag;

  ((nullable) = (int *) xmalloc_1((d->depth) * sizeof (int)));
  o_nullable = nullable;
  ((nfirstpos) = (int *) xmalloc_1((d->depth) * sizeof (int)));
  o_nfirst = nfirstpos;
  ((firstpos) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
  o_firstpos = firstpos, firstpos += d->nleaves;
  ((nlastpos) = (int *) xmalloc_1((d->depth) * sizeof (int)));
  o_nlast = nlastpos;
  ((lastpos) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
  o_lastpos = lastpos, lastpos += d->nleaves;
  ((nalloc) = (int *) xmalloc_1((d->tindex) * sizeof (int)));
  for (i = 0; i < d->tindex; ++i)
    nalloc[i] = 0;
  ((merged.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));

  ((d->follows) = (position_set *) xcalloc((size_t)(d->tindex), sizeof (position_set)));

  for (i = 0; i < d->tindex; ++i)



    switch (d->tokens[i])
      {
      case EMPTY:

 *nullable++ = 1;


 *nfirstpos++ = *nlastpos++ = 0;
 break;

      case STAR:
      case PLUS:


 tmp.nelem = nfirstpos[-1];
 tmp.elems = firstpos;
 pos = lastpos;
 for (j = 0; j < nlastpos[-1]; ++j)
   {
     merge(&tmp, &d->follows[pos[j].strchr], &merged);
     zzz if ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) zzz { zzz while ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) zzz (nalloc[pos[j].strchr]) *= 2; zzz ((d->follows[pos[j].strchr].elems) = (position *) xrealloc_1((ptr_t) (d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof (position))); zzz }
                                            ;
     copy(&merged, &d->follows[pos[j].strchr]);
   }

      case QMARK:

 if (d->tokens[i] != PLUS)
   nullable[-1] = 1;
 break;

      case CAT:


 tmp.nelem = nfirstpos[-1];
 tmp.elems = firstpos;
 pos = lastpos + nlastpos[-1];
 for (j = 0; j < nlastpos[-2]; ++j)
   {
     merge(&tmp, &d->follows[pos[j].strchr], &merged);
     zzz if ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) zzz { zzz while ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) zzz (nalloc[pos[j].strchr]) *= 2; zzz ((d->follows[pos[j].strchr].elems) = (position *) xrealloc_1((ptr_t) (d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof (position))); zzz }
                                            ;
     copy(&merged, &d->follows[pos[j].strchr]);
   }



 if (nullable[-2])
   nfirstpos[-2] += nfirstpos[-1];
 else
   firstpos += nfirstpos[-1];
 --nfirstpos;



 if (nullable[-1])
   nlastpos[-2] += nlastpos[-1];
 else
   {
     pos = lastpos + nlastpos[-2];
     for (j = nlastpos[-1] - 1; j >= 0; --j)
       pos[j] = lastpos[j];
     lastpos += nlastpos[-2];
     nlastpos[-2] = nlastpos[-1];
   }
 --nlastpos;


 nullable[-2] = nullable[-1] && nullable[-2];
 --nullable;
 break;

      case OR:
      case ORTOP:

 nfirstpos[-2] += nfirstpos[-1];
 --nfirstpos;


 nlastpos[-2] += nlastpos[-1];
 --nlastpos;


 nullable[-2] = nullable[-1] || nullable[-2];
 --nullable;
 break;

      default:





 *nullable++ = d->tokens[i] == BACKREF;


 *nfirstpos++ = *nlastpos++ = 1;
 --firstpos, --lastpos;
 firstpos->strchr = lastpos->strchr = i;
 firstpos->constraint = lastpos->constraint = 0xff;


 nalloc[i] = 1;
 ((d->follows[i].elems) = (position *) xmalloc_1((nalloc[i]) * sizeof (position)));
 break;
      }
# 3069 "grep_single_original.c"
  for (i = 0; i < d->tindex; ++i)
    if (d->tokens[i] < (1 << 8) || d->tokens[i] == BACKREF
 || d->tokens[i] >= CSET)
      {
# 3084 "grep_single_original.c"
 copy(&d->follows[i], &merged);
 epsclosure(&merged, d);
 if (d->follows[i].nelem < merged.nelem)
   ((d->follows[i].elems) = (position *) xrealloc_1((ptr_t) (d->follows[i].elems), (merged.nelem) * sizeof (position)));
 copy(&merged, &d->follows[i]);
      }



  merged.nelem = 0;
  for (i = 0; i < nfirstpos[-1]; ++i)
    insert(firstpos[i], &merged);
  epsclosure(&merged, d);


  wants_newline = 0;
  for (i = 0; i < merged.nelem; ++i)
    if ((((merged.elems[i].constraint) & 0xc0) >> 2 != ((merged.elems[i].constraint) & 0x30)))
      wants_newline = 1;


  d->salloc = 1;
  d->sindex = 0;
  ((d->states) = (dfa_state *) xmalloc_1((d->salloc) * sizeof (dfa_state)));
  state_index(d, &merged, wants_newline, 0);

  free(o_nullable);
  free(o_nfirst);
  free(o_firstpos);
  free(o_nlast);
  free(o_lastpos);
  free(nalloc);
  free(merged.elems);
}
# 3149 "grep_single_original.c"
void
dfastate(s, d, trans)
     int s;
     struct dfa *d;
     int trans[];
{
  position_set grps[(1 << 8)];
  charclass labels[(1 << 8)];
  int ngrps = 0;
  position pos;
  charclass matches;
  int matchesf;
  charclass intersect;
  int intersectf;
  charclass leftovers;
  int leftoversf;
  static charclass letters;
  static charclass newline;
  position_set follows;
  position_set tmp;
  int state;
  int wants_newline;
  int state_newline;
  int wants_letter;
  int state_letter;
  static int initialized;
  int i, j, k;


  if (! initialized)
    {
      initialized = 1;
      for (i = 0; i < (1 << 8); ++i)
 if ((
# 3182 "grep_single_original.c" 3 4
    ((*__ctype_b_loc ())[(int) ((
# 3182 "grep_single_original.c"
    i
# 3182 "grep_single_original.c" 3 4
    ))] & (unsigned short int) _ISalnum) 
# 3182 "grep_single_original.c"
    || (i) == '_'))
   setbit(i, letters);
      setbit(eolbyte_1, newline);
    }

  zeroset(matches);

  for (i = 0; i < d->states[s].elems.nelem; ++i)
    {
      pos = d->states[s].elems.elems[i];
      if (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8))
 setbit(d->tokens[pos.strchr], matches);
      else if (d->tokens[pos.strchr] >= CSET)
 copyset(d->charclasses[d->tokens[pos.strchr] - CSET], matches);
      else
 continue;



      if (pos.constraint != 0xFF)
 {
   if (! ((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4))
                              )
     clrbit(eolbyte_1, matches);
   if (! ((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4))
                              )
     for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j)
       matches[j] &= newline[j];
   if (! ((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0)))
                            )
     for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j)
       matches[j] &= ~letters[j];
   if (! ((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0)))
                            )
     for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j)
       matches[j] &= letters[j];


   for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))) && !matches[j]; ++j)
     continue;
   if (j == (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))))
     continue;
 }

      for (j = 0; j < ngrps; ++j)
 {



   if (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8)
       && !tstbit(d->tokens[pos.strchr], labels[j]))
     continue;



   intersectf = 0;
   for (k = 0; k < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++k)
     (intersect[k] = matches[k] & labels[j][k]) ? (intersectf = 1) : 0;
   if (! intersectf)
     continue;


   leftoversf = matchesf = 0;
   for (k = 0; k < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++k)
     {

       int match = matches[k], label = labels[j][k];

       (leftovers[k] = ~match & label) ? (leftoversf = 1) : 0;
       (matches[k] = match & ~label) ? (matchesf = 1) : 0;
     }


   if (leftoversf)
     {
       copyset(leftovers, labels[ngrps]);
       copyset(intersect, labels[j]);
       ((grps[ngrps].elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
       copy(&grps[j], &grps[ngrps]);
       ++ngrps;
     }



   grps[j].elems[grps[j].nelem++] = pos;



   if (! matchesf)
     break;
 }



      if (j == ngrps)
 {
   copyset(matches, labels[ngrps]);
   zeroset(matches);
   ((grps[ngrps].elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
   grps[ngrps].nelem = 1;
   grps[ngrps].elems[0] = pos;
   ++ngrps;
 }
    }

  ((follows.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
  ((tmp.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));




  if (d->searchflag)
    {
      wants_newline = 0;
      wants_letter = 0;
      for (i = 0; i < d->states[0].elems.nelem; ++i)
 {
   if ((((d->states[0].elems.elems[i].constraint) & 0xc0) >> 2 != ((d->states[0].elems.elems[i].constraint) & 0x30)))
     wants_newline = 1;
   if ((((d->states[0].elems.elems[i].constraint) & 0x0c) >> 2 != ((d->states[0].elems.elems[i].constraint) & 0x03)))
     wants_letter = 1;
 }
      copy(&d->states[0].elems, &follows);
      state = state_index(d, &follows, 0, 0);
      if (wants_newline)
 state_newline = state_index(d, &follows, 1, 0);
      else
 state_newline = state;
      if (wants_letter)
 state_letter = state_index(d, &follows, 0, 1);
      else
 state_letter = state;
      for (i = 0; i < (1 << 8); ++i)
 trans[i] = ((
# 3315 "grep_single_original.c" 3 4
            ((*__ctype_b_loc ())[(int) ((
# 3315 "grep_single_original.c"
            i
# 3315 "grep_single_original.c" 3 4
            ))] & (unsigned short int) _ISalnum) 
# 3315 "grep_single_original.c"
            || (i) == '_')) ? state_letter : state;
      trans[eolbyte_1] = state_newline;
    }
  else
    for (i = 0; i < (1 << 8); ++i)
      trans[i] = -1;

  for (i = 0; i < ngrps; ++i)
    {
      follows.nelem = 0;



      for (j = 0; j < grps[i].nelem; ++j)
 for (k = 0; k < d->follows[grps[i].elems[j].strchr].nelem; ++k)
   insert(d->follows[grps[i].elems[j].strchr].elems[k], &follows);



      if (d->searchflag)
 for (j = 0; j < d->states[0].elems.nelem; ++j)
   insert(d->states[0].elems.elems[j], &follows);


      wants_newline = 0;
      if (tstbit(eolbyte_1, labels[i]))
 for (j = 0; j < follows.nelem; ++j)
   if ((((follows.elems[j].constraint) & 0xc0) >> 2 != ((follows.elems[j].constraint) & 0x30)))
     wants_newline = 1;

      wants_letter = 0;
      for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j)
 if (labels[i][j] & letters[j])
   break;
      if (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))))
 for (j = 0; j < follows.nelem; ++j)
   if ((((follows.elems[j].constraint) & 0x0c) >> 2 != ((follows.elems[j].constraint) & 0x03)))
     wants_letter = 1;


      state = state_index(d, &follows, 0, 0);
      if (wants_newline)
 state_newline = state_index(d, &follows, 1, 0);
      else
 state_newline = state;
      if (wants_letter)
 state_letter = state_index(d, &follows, 0, 1);
      else
 state_letter = state;


      for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j)
 for (k = 0; k < (8 * sizeof (int)); ++k)
   if (labels[i][j] & 1 << k)
     {
       int c = j * (8 * sizeof (int)) + k;

       if (c == eolbyte_1)
  trans[c] = state_newline;
       else if ((
# 3374 "grep_single_original.c" 3 4
               ((*__ctype_b_loc ())[(int) ((
# 3374 "grep_single_original.c"
               c
# 3374 "grep_single_original.c" 3 4
               ))] & (unsigned short int) _ISalnum) 
# 3374 "grep_single_original.c"
               || (c) == '_'))
  trans[c] = state_letter;
       else if (c < (1 << 8))
  trans[c] = state;
     }
    }

  for (i = 0; i < ngrps; ++i)
    free(grps[i].elems);
  free(follows.elems);
  free(tmp.elems);
}
# 3394 "grep_single_original.c"
static void
build_state(s, d)
     int s;
     struct dfa *d;
{
  int *trans;
  int i;





  if (d->trcount >= 1024)
    {
      for (i = 0; i < d->tralloc; ++i)
 if (d->trans[i])
   {
     free((ptr_t) d->trans[i]);
     d->trans[i] = 
# 3412 "grep_single_original.c" 3 4
                  ((void *)0)
# 3412 "grep_single_original.c"
                      ;
   }
 else if (d->fails[i])
   {
     free((ptr_t) d->fails[i]);
     d->fails[i] = 
# 3417 "grep_single_original.c" 3 4
                  ((void *)0)
# 3417 "grep_single_original.c"
                      ;
   }
      d->trcount = 0;
    }

  ++d->trcount;


  d->success[s] = 0;
  if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))))
            )
    d->success[s] |= 4;
  if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0))))
            )
    d->success[s] |= 2;
  if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))))
            )
    d->success[s] |= 1;

  ((trans) = (int *) xmalloc_1(((1 << 8)) * sizeof (int)));
  dfastate(s, d, trans);




  for (i = 0; i < (1 << 8); ++i)
    if (trans[i] >= d->tralloc)
      {
 int oldalloc = d->tralloc;

 while (trans[i] >= d->tralloc)
   d->tralloc *= 2;
 ((d->realtrans) = (int * *) xrealloc_1((ptr_t) (d->realtrans), (d->tralloc + 1) * sizeof (int *)));
 d->trans = d->realtrans + 1;
 ((d->fails) = (int * *) xrealloc_1((ptr_t) (d->fails), (d->tralloc) * sizeof (int *)));
 ((d->success) = (int *) xrealloc_1((ptr_t) (d->success), (d->tralloc) * sizeof (int)));
 ((d->newlines) = (int *) xrealloc_1((ptr_t) (d->newlines), (d->tralloc) * sizeof (int)));
 while (oldalloc < d->tralloc)
   {
     d->trans[oldalloc] = 
# 3456 "grep_single_original.c" 3 4
                         ((void *)0)
# 3456 "grep_single_original.c"
                             ;
     d->fails[oldalloc++] = 
# 3457 "grep_single_original.c" 3 4
                           ((void *)0)
# 3457 "grep_single_original.c"
                               ;
   }
      }



  d->newlines[s] = trans[eolbyte_1];
  trans[eolbyte_1] = -1;

  if (((*d).states[s].constraint))
    d->fails[s] = trans;
  else
    d->trans[s] = trans;
}

static void
build_state_zero(d)
     struct dfa *d;
{
  d->tralloc = 1;
  d->trcount = 0;
  ((d->realtrans) = (int * *) xcalloc((size_t)(d->tralloc + 1), sizeof (int *)));
  d->trans = d->realtrans + 1;
  ((d->fails) = (int * *) xcalloc((size_t)(d->tralloc), sizeof (int *)));
  ((d->success) = (int *) xmalloc_1((d->tralloc) * sizeof (int)));
  ((d->newlines) = (int *) xmalloc_1((d->tralloc) * sizeof (int)));
  build_state(0, d);
}
# 3499 "grep_single_original.c"
char *
dfaexec(d, begin, end, newline, count, backref)
     struct dfa *d;
     char *begin;
     char *end;
     int newline;
     int *count;
     int *backref;
{
  register int s, s1, tmp;
  register unsigned char *p;
  register int **trans, *t;

  register unsigned char eol = eolbyte_1;
  static int sbit[(1 << 8)];
  static int sbit_init;

  if (! sbit_init)
    {
      int i;

      sbit_init = 1;
      for (i = 0; i < (1 << 8); ++i)
 sbit[i] = ((
# 3522 "grep_single_original.c" 3 4
           ((*__ctype_b_loc ())[(int) ((
# 3522 "grep_single_original.c"
           i
# 3522 "grep_single_original.c" 3 4
           ))] & (unsigned short int) _ISalnum) 
# 3522 "grep_single_original.c"
           || (i) == '_')) ? 2 : 1;
      sbit[eol] = 4;
    }

  if (! d->tralloc)
    build_state_zero(d);

  s = s1 = 0;
  p = (unsigned char *) begin;
  trans = d->trans;
  *end = eol;

  for (;;)
    {
      while ((t = trans[s]) != 0) {
 s1 = t[*p++];
        if ((t = trans[s1]) == 0) {
           tmp = s ; s = s1 ; s1 = tmp ;
           break;
        }
 s = t[*p++];
      }

      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
 {
   if (d->success[s] & sbit[*p])
     {
       if (backref)
  *backref = (d->states[s].backref != 0);
       return (char *) p;
     }

   s1 = s;
   s = d->fails[s][*p++];
   continue;
 }


      if (count && (char *) p <= end && p[-1] == eol)
 ++*count;


      if ((char *) p > end)
 return 
# 3565 "grep_single_original.c" 3 4
       ((void *)0)
# 3565 "grep_single_original.c"
           ;

      if (s >= 0)
 {
   build_state(s, d);
   trans = d->trans;
   continue;
 }

      if (p[-1] == eol && newline)
 {
   s = d->newlines[s1];
   continue;
 }

      s = 0;
    }
}



void
dfainit(d)
     struct dfa *d;
{
  d->calloc = 1;
  ((d->charclasses) = (charclass *) xmalloc_1((d->calloc) * sizeof (charclass)));
  d->cindex = 0;

  d->talloc = 1;
  ((d->tokens) = (token *) xmalloc_1((d->talloc) * sizeof (token)));
  d->tindex = d->depth = d->nleaves = d->nregexps = 0;

  d->searchflag = 0;
  d->tralloc = 0;

  d->musts = 0;
}


void
dfacomp(s, len, d, searchflag)
     char *s;
     size_t len;
     struct dfa *d;
     int searchflag;
{
  if (case_fold)
    {
      char *lcopy;
      int i;

      lcopy = malloc(len);
      if (!lcopy)
 dfaerror(gettext ("out of memory"));


      case_fold = 0;
      for (i = 0; i < len; ++i)
 if (
# 3624 "grep_single_original.c" 3 4
    ((*__ctype_b_loc ())[(int) ((
# 3624 "grep_single_original.c"
    (unsigned char) s[i]
# 3624 "grep_single_original.c" 3 4
    ))] & (unsigned short int) _ISupper)
# 3624 "grep_single_original.c"
                                  )
   lcopy[i] = tolower ((unsigned char) s[i]);
 else
   lcopy[i] = s[i];

      dfainit(d);
      dfaparse(lcopy, len, d);
      free(lcopy);
      dfamust(d);
      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
      case_fold = 1;
      dfaparse(s, len, d);
      dfaanalyze(d, searchflag);
    }
  else
    {
        dfainit(d);
        dfaparse(s, len, d);
 dfamust(d);
        dfaanalyze(d, searchflag);
    }
}


void
dfafree(d)
     struct dfa *d;
{
  int i;
  struct dfamust *dm, *ndm;

  free((ptr_t) d->charclasses);
  free((ptr_t) d->tokens);
  for (i = 0; i < d->sindex; ++i)
    free((ptr_t) d->states[i].elems.elems);
  free((ptr_t) d->states);
  for (i = 0; i < d->tindex; ++i)
    if (d->follows[i].elems)
      free((ptr_t) d->follows[i].elems);
  free((ptr_t) d->follows);
  for (i = 0; i < d->tralloc; ++i)
    if (d->trans[i])
      free((ptr_t) d->trans[i]);
    else if (d->fails[i])
      free((ptr_t) d->fails[i]);
  if (d->realtrans) free((ptr_t) d->realtrans);
  if (d->fails) free((ptr_t) d->fails);
  if (d->newlines) free((ptr_t) d->newlines);
  if (d->success) free((ptr_t) d->success);
  for (dm = d->musts; dm; dm = ndm)
    {
      ndm = dm->next;
      free(dm->must);
      free((ptr_t) dm);
    }
}
# 3761 "grep_single_original.c"
static char *
icatalloc(old, new)
     char *old;
     char *new;
{
  char *result;
  size_t oldsize, newsize;

  newsize = (new == 
# 3769 "grep_single_original.c" 3 4
                   ((void *)0)
# 3769 "grep_single_original.c"
                       ) ? 0 : strlen(new);
  if (old == 
# 3770 "grep_single_original.c" 3 4
            ((void *)0)
# 3770 "grep_single_original.c"
                )
    oldsize = 0;
  else if (newsize == 0)
    return old;
  else oldsize = strlen(old);
  if (old == 
# 3775 "grep_single_original.c" 3 4
            ((void *)0)
# 3775 "grep_single_original.c"
                )
    result = (char *) malloc(newsize + 1);
  else
    result = (char *) realloc((void *) old, oldsize + newsize + 1);
  if (result != 
# 3779 "grep_single_original.c" 3 4
               ((void *)0) 
# 3779 "grep_single_original.c"
                    && new != 
# 3779 "grep_single_original.c" 3 4
                              ((void *)0)
# 3779 "grep_single_original.c"
                                  )
    (void) strcpy(result + oldsize, new);
  return result;
}

static char *
icpyalloc(string)
     char *string;
{
  return icatalloc((char *) 
# 3788 "grep_single_original.c" 3 4
                           ((void *)0)
# 3788 "grep_single_original.c"
                               , string);
}

static char *
istrstr(lookin, lookfor)
     char *lookin;
     char *lookfor;
{
  char *cp;
  size_t len;

  len = strlen(lookfor);
  for (cp = lookin; *cp != '\0'; ++cp)
    if (strncmp(cp, lookfor, len) == 0)
      return cp;
  return 
# 3803 "grep_single_original.c" 3 4
        ((void *)0)
# 3803 "grep_single_original.c"
            ;
}

static void
ifree(cp)
     char *cp;
{
  if (cp != 
# 3810 "grep_single_original.c" 3 4
           ((void *)0)
# 3810 "grep_single_original.c"
               )
    free(cp);
}

static void
freelist(cpp)
     char **cpp;
{
  int i;

  if (cpp == 
# 3820 "grep_single_original.c" 3 4
            ((void *)0)
# 3820 "grep_single_original.c"
                )
    return;
  for (i = 0; cpp[i] != 
# 3822 "grep_single_original.c" 3 4
                       ((void *)0)
# 3822 "grep_single_original.c"
                           ; ++i)
    {
      free(cpp[i]);
      cpp[i] = 
# 3825 "grep_single_original.c" 3 4
              ((void *)0)
# 3825 "grep_single_original.c"
                  ;
    }
}

static char **
enlist(cpp, new, len)
     char **cpp;
     char *new;
     size_t len;
{
  int i, j;

  if (cpp == 
# 3837 "grep_single_original.c" 3 4
            ((void *)0)
# 3837 "grep_single_original.c"
                )
    return 
# 3838 "grep_single_original.c" 3 4
          ((void *)0)
# 3838 "grep_single_original.c"
              ;
  if ((new = icpyalloc(new)) == 
# 3839 "grep_single_original.c" 3 4
                               ((void *)0)
# 3839 "grep_single_original.c"
                                   )
    {
      freelist(cpp);
      return 
# 3842 "grep_single_original.c" 3 4
            ((void *)0)
# 3842 "grep_single_original.c"
                ;
    }
  new[len] = '\0';

  for (i = 0; cpp[i] != 
# 3846 "grep_single_original.c" 3 4
                       ((void *)0)
# 3846 "grep_single_original.c"
                           ; ++i)
    if (istrstr(cpp[i], new) != 
# 3847 "grep_single_original.c" 3 4
                               ((void *)0)
# 3847 "grep_single_original.c"
                                   )
      {
 free(new);
 return cpp;
      }

  j = 0;
  while (cpp[j] != 
# 3854 "grep_single_original.c" 3 4
                  ((void *)0)
# 3854 "grep_single_original.c"
                      )
    if (istrstr(new, cpp[j]) == 
# 3855 "grep_single_original.c" 3 4
                               ((void *)0)
# 3855 "grep_single_original.c"
                                   )
      ++j;
    else
      {
 free(cpp[j]);
 if (--i == j)
   break;
 cpp[j] = cpp[i];
 cpp[i] = 
# 3863 "grep_single_original.c" 3 4
         ((void *)0)
# 3863 "grep_single_original.c"
             ;
      }

  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
  if (cpp == 
# 3867 "grep_single_original.c" 3 4
            ((void *)0)
# 3867 "grep_single_original.c"
                )
    return 
# 3868 "grep_single_original.c" 3 4
          ((void *)0)
# 3868 "grep_single_original.c"
              ;
  cpp[i] = new;
  cpp[i + 1] = 
# 3870 "grep_single_original.c" 3 4
              ((void *)0)
# 3870 "grep_single_original.c"
                  ;
  return cpp;
}




static char **
comsubs(left, right)
     char *left;
     char *right;
{
  char **cpp;
  char *lcp;
  char *rcp;
  size_t i, len;

  if (left == 
# 3887 "grep_single_original.c" 3 4
             ((void *)0) 
# 3887 "grep_single_original.c"
                  || right == 
# 3887 "grep_single_original.c" 3 4
                              ((void *)0)
# 3887 "grep_single_original.c"
                                  )
    return 
# 3888 "grep_single_original.c" 3 4
          ((void *)0)
# 3888 "grep_single_original.c"
              ;
  cpp = (char **) malloc(sizeof *cpp);
  if (cpp == 
# 3890 "grep_single_original.c" 3 4
            ((void *)0)
# 3890 "grep_single_original.c"
                )
    return 
# 3891 "grep_single_original.c" 3 4
          ((void *)0)
# 3891 "grep_single_original.c"
              ;
  cpp[0] = 
# 3892 "grep_single_original.c" 3 4
          ((void *)0)
# 3892 "grep_single_original.c"
              ;
  for (lcp = left; *lcp != '\0'; ++lcp)
    {
      len = 0;
      rcp = strchr(right, *lcp);
      while (rcp != 
# 3897 "grep_single_original.c" 3 4
                   ((void *)0)
# 3897 "grep_single_original.c"
                       )
 {
   for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
     continue;
   if (i > len)
     len = i;
   rcp = strchr(rcp + 1, *lcp);
 }
      if (len == 0)
 continue;
      if ((cpp = enlist(cpp, lcp, len)) == 
# 3907 "grep_single_original.c" 3 4
                                          ((void *)0)
# 3907 "grep_single_original.c"
                                              )
 break;
    }
  return cpp;
}

static char **
addlists(old, new)
char **old;
char **new;
{
  int i;

  if (old == 
# 3920 "grep_single_original.c" 3 4
            ((void *)0) 
# 3920 "grep_single_original.c"
                 || new == 
# 3920 "grep_single_original.c" 3 4
                           ((void *)0)
# 3920 "grep_single_original.c"
                               )
    return 
# 3921 "grep_single_original.c" 3 4
          ((void *)0)
# 3921 "grep_single_original.c"
              ;
  for (i = 0; new[i] != 
# 3922 "grep_single_original.c" 3 4
                       ((void *)0)
# 3922 "grep_single_original.c"
                           ; ++i)
    {
      old = enlist(old, new[i], strlen(new[i]));
      if (old == 
# 3925 "grep_single_original.c" 3 4
                ((void *)0)
# 3925 "grep_single_original.c"
                    )
 break;
    }
  return old;
}



static char **
inboth(left, right)
     char **left;
     char **right;
{
  char **both;
  char **temp;
  int lnum, rnum;

  if (left == 
# 3942 "grep_single_original.c" 3 4
             ((void *)0) 
# 3942 "grep_single_original.c"
                  || right == 
# 3942 "grep_single_original.c" 3 4
                              ((void *)0)
# 3942 "grep_single_original.c"
                                  )
    return 
# 3943 "grep_single_original.c" 3 4
          ((void *)0)
# 3943 "grep_single_original.c"
              ;
  both = (char **) malloc(sizeof *both);
  if (both == 
# 3945 "grep_single_original.c" 3 4
             ((void *)0)
# 3945 "grep_single_original.c"
                 )
    return 
# 3946 "grep_single_original.c" 3 4
          ((void *)0)
# 3946 "grep_single_original.c"
              ;
  both[0] = 
# 3947 "grep_single_original.c" 3 4
           ((void *)0)
# 3947 "grep_single_original.c"
               ;
  for (lnum = 0; left[lnum] != 
# 3948 "grep_single_original.c" 3 4
                              ((void *)0)
# 3948 "grep_single_original.c"
                                  ; ++lnum)
    {
      for (rnum = 0; right[rnum] != 
# 3950 "grep_single_original.c" 3 4
                                   ((void *)0)
# 3950 "grep_single_original.c"
                                       ; ++rnum)
 {
   temp = comsubs(left[lnum], right[rnum]);
   if (temp == 
# 3953 "grep_single_original.c" 3 4
              ((void *)0)
# 3953 "grep_single_original.c"
                  )
     {
       freelist(both);
       return 
# 3956 "grep_single_original.c" 3 4
             ((void *)0)
# 3956 "grep_single_original.c"
                 ;
     }
   both = addlists(both, temp);
   freelist(temp);
   free(temp);
   if (both == 
# 3961 "grep_single_original.c" 3 4
              ((void *)0)
# 3961 "grep_single_original.c"
                  )
     return 
# 3962 "grep_single_original.c" 3 4
           ((void *)0)
# 3962 "grep_single_original.c"
               ;
 }
    }
  return both;
}

typedef struct
{
  char **in;
  char *left;
  char *right;
  char *is;
} must;

static void
resetmust(mp)
must *mp;
{
  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
  freelist(mp->in);
}

static void
dfamust(dfa)
struct dfa *dfa;
{
  must *musts;
  must *mp;
  char *result;
  int ri;
  int i;
  int exact;
  token t;
  static must must0;
  struct dfamust *dm;
  static char empty_string[] = "";

  result = empty_string;
  exact = 0;
  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
  if (musts == 
# 4002 "grep_single_original.c" 3 4
              ((void *)0)
# 4002 "grep_single_original.c"
                  )
    return;
  mp = musts;
  for (i = 0; i <= dfa->tindex; ++i)
    mp[i] = must0;
  for (i = 0; i <= dfa->tindex; ++i)
    {
      mp[i].in = (char **) malloc(sizeof *mp[i].in);
      mp[i].left = malloc(2);
      mp[i].right = malloc(2);
      mp[i].is = malloc(2);
      if (mp[i].in == 
# 4013 "grep_single_original.c" 3 4
                     ((void *)0) 
# 4013 "grep_single_original.c"
                          || mp[i].left == 
# 4013 "grep_single_original.c" 3 4
                                           ((void *)0) 
# 4013 "grep_single_original.c"
                                                ||
   mp[i].right == 
# 4014 "grep_single_original.c" 3 4
                 ((void *)0) 
# 4014 "grep_single_original.c"
                      || mp[i].is == 
# 4014 "grep_single_original.c" 3 4
                                     ((void *)0)
# 4014 "grep_single_original.c"
                                         )
 goto done;
      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
      mp[i].in[0] = 
# 4017 "grep_single_original.c" 3 4
                   ((void *)0)
# 4017 "grep_single_original.c"
                       ;
    }
# 4028 "grep_single_original.c"
  for (ri = 0; ri < dfa->tindex; ++ri)
    {
      switch (t = dfa->tokens[ri])
 {
 case LPAREN:
 case RPAREN:
   goto done;
 case EMPTY:
 case BEGLINE:
 case ENDLINE:
 case BEGWORD:
 case ENDWORD:
 case LIMWORD:
 case NOTLIMWORD:
 case BACKREF:
   resetmust(mp);
   break;
 case STAR:
 case QMARK:
   if (mp <= musts)
     goto done;
   --mp;
   resetmust(mp);
   break;
 case OR:
 case ORTOP:
   if (mp < &musts[2])
     goto done;
   {
     char **new;
     must *lmp;
     must *rmp;
     int j, ln, rn, n;

     rmp = --mp;
     lmp = --mp;

     if (strcmp(lmp->is, rmp->is) != 0)
       lmp->is[0] = '\0';

     i = 0;
     while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
       ++i;
     lmp->left[i] = '\0';

     ln = strlen(lmp->right);
     rn = strlen(rmp->right);
     n = ln;
     if (n > rn)
       n = rn;
     for (i = 0; i < n; ++i)
       if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
  break;
     for (j = 0; j < i; ++j)
       lmp->right[j] = lmp->right[(ln - i) + j];
     lmp->right[j] = '\0';
     new = inboth(lmp->in, rmp->in);
     if (new == 
# 4085 "grep_single_original.c" 3 4
               ((void *)0)
# 4085 "grep_single_original.c"
                   )
       goto done;
     freelist(lmp->in);
     free((char *) lmp->in);
     lmp->in = new;
   }
   break;
 case PLUS:
   if (mp <= musts)
     goto done;
   --mp;
   mp->is[0] = '\0';
   break;
 case END:
   if (mp != &musts[1])
     goto done;
   for (i = 0; musts[0].in[i] != 
# 4101 "grep_single_original.c" 3 4
                                ((void *)0)
# 4101 "grep_single_original.c"
                                    ; ++i)
     if (strlen(musts[0].in[i]) > strlen(result))
       result = musts[0].in[i];
   if (strcmp(result, musts[0].is) == 0)
     exact = 1;
   goto done;
 case CAT:
   if (mp < &musts[2])
     goto done;
   {
     must *lmp;
     must *rmp;

     rmp = --mp;
     lmp = --mp;



     lmp->in = addlists(lmp->in, rmp->in);
     if (lmp->in == 
# 4120 "grep_single_original.c" 3 4
                   ((void *)0)
# 4120 "grep_single_original.c"
                       )
       goto done;
     if (lmp->right[0] != '\0' &&
  rmp->left[0] != '\0')
       {
  char *tp;

  tp = icpyalloc(lmp->right);
  if (tp == 
# 4128 "grep_single_original.c" 3 4
           ((void *)0)
# 4128 "grep_single_original.c"
               )
    goto done;
  tp = icatalloc(tp, rmp->left);
  if (tp == 
# 4131 "grep_single_original.c" 3 4
           ((void *)0)
# 4131 "grep_single_original.c"
               )
    goto done;
  lmp->in = enlist(lmp->in, tp,
     strlen(tp));
  free(tp);
  if (lmp->in == 
# 4136 "grep_single_original.c" 3 4
                ((void *)0)
# 4136 "grep_single_original.c"
                    )
    goto done;
       }

     if (lmp->is[0] != '\0')
       {
  lmp->left = icatalloc(lmp->left,
          rmp->left);
  if (lmp->left == 
# 4144 "grep_single_original.c" 3 4
                  ((void *)0)
# 4144 "grep_single_original.c"
                      )
    goto done;
       }

     if (rmp->is[0] == '\0')
       lmp->right[0] = '\0';
     lmp->right = icatalloc(lmp->right, rmp->right);
     if (lmp->right == 
# 4151 "grep_single_original.c" 3 4
                      ((void *)0)
# 4151 "grep_single_original.c"
                          )
       goto done;

     if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
       {
  lmp->is = icatalloc(lmp->is, rmp->is);
  if (lmp->is == 
# 4157 "grep_single_original.c" 3 4
                ((void *)0)
# 4157 "grep_single_original.c"
                    )
    goto done;
       }
     else
       lmp->is[0] = '\0';
   }
   break;
 default:
   if (t < END)
     {

       goto done;
     }
   else if (t == '\0')
     {

       goto done;
     }
   else if (t >= CSET)
     {

       resetmust(mp);
     }
   else
     {

       resetmust(mp);
       mp->is[0] = mp->left[0] = mp->right[0] = t;
       mp->is[1] = mp->left[1] = mp->right[1] = '\0';
       mp->in = enlist(mp->in, mp->is, (size_t)1);
       if (mp->in == 
# 4187 "grep_single_original.c" 3 4
                    ((void *)0)
# 4187 "grep_single_original.c"
                        )
  goto done;
     }
   break;
 }
# 4202 "grep_single_original.c"
      ++mp;
    }
 done:
  if (strlen(result))
    {
      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
      dm->exact = exact;
      dm->must = malloc(strlen(result) + 1);
      strcpy(dm->must, result);
      dm->next = dfa->musts;
      dfa->musts = dm;
    }
  mp = musts;
  for (i = 0; i <= dfa->tindex; ++i)
    {
      freelist(mp[i].in);
      ifree((char *) mp[i].in);
      ifree(mp[i].left);
      ifree(mp[i].right);
      ifree(mp[i].is);
    }
  free((char *) mp);
}
# 4263 "grep_single_original.c"
# 1 "kwset.h" 1
# 23 "kwset.h"
struct kwsmatch
{
  int strchr;
  char *beg[1];
  size_t size[1];
};

typedef ptr_t kwset_t;





extern kwset_t kwsalloc (char *);




extern char *kwsincr (kwset_t, char *, size_t);



extern char *kwsprep (kwset_t);







extern char *kwsexec (kwset_t, char *, size_t, struct kwsmatch *);


extern void kwsfree (kwset_t);
# 4264 "grep_single_original.c" 2
# 1 "obstack.h" 1
# 161 "obstack.h"
struct _obstack_chunk
{
  char *limit;
  struct _obstack_chunk *prev;
  char contents[4];
};

struct obstack
{
  long chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  ptrdiff_t temp;
  int alignment_mask;




  struct _obstack_chunk *(*chunkfun) (void *, long);
  void (*freefun) (void *, struct _obstack_chunk *);
  void *extra_arg;





  unsigned use_extra_arg:1;
  unsigned maybe_empty_object:1;



  unsigned alloc_failed:1;


};




extern void _obstack_newchunk (struct obstack *, int);
extern void _obstack_free (struct obstack *, void *);
extern int _obstack_begin (struct obstack *, int, int,
       void *(*) (long), void (*) (void *));
extern int _obstack_begin_1 (struct obstack *, int, int,
        void *(*) (void *, long),
        void (*) (void *, void *), void *);
extern int _obstack_memory_used (struct obstack *);
# 223 "obstack.h"
void obstack_init (struct obstack *obstack);

void * obstack_alloc (struct obstack *obstack, int size);

void * obstack_copy (struct obstack *obstack, void *address, int size);
void * obstack_copy0 (struct obstack *obstack, void *address, int size);

void obstack_free (struct obstack *obstack, void *block);

void obstack_blank (struct obstack *obstack, int size);

void obstack_grow (struct obstack *obstack, void *data, int size);
void obstack_grow0 (struct obstack *obstack, void *data, int size);

void obstack_1grow (struct obstack *obstack, int data_char);
void obstack_ptr_grow (struct obstack *obstack, void *data);
void obstack_int_grow (struct obstack *obstack, int data);

void * obstack_finish (struct obstack *obstack);

int obstack_object_size (struct obstack *obstack);

int obstack_room (struct obstack *obstack);
void obstack_make_room (struct obstack *obstack, int size);
void obstack_1grow_fast (struct obstack *obstack, int data_char);
void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
void obstack_int_grow_fast (struct obstack *obstack, int data);
void obstack_blank_fast (struct obstack *obstack, int size);

void * obstack_base (struct obstack *obstack);
void * obstack_next_free (struct obstack *obstack);
int obstack_alignment_mask (struct obstack *obstack);
int obstack_chunk_size (struct obstack *obstack);
int obstack_memory_used (struct obstack *obstack);
# 267 "obstack.h"
extern void (*obstack_alloc_failed_handler) (void);





extern int obstack_exit_failure;
# 4265 "grep_single_original.c" 2


extern char *xmalloc();
# 4277 "grep_single_original.c"
struct tree
{
  struct tree *llink;
  struct tree *rlink;
  struct trie *trie;
  unsigned char label;
  char balance;
};


struct trie
{
  unsigned int accepting;
  struct tree *links;
  struct trie *parent;
  struct trie *next;
  struct trie *fail;
  int depth;
  int shift;
  int maxshift;
};


struct kwset
{
  struct obstack obstack;
  int words;
  struct trie *trie;
  int mind;
  int maxd;
  unsigned char delta[(
# 4307 "grep_single_original.c" 3 4
                     (0x7f * 2 + 1) 
# 4307 "grep_single_original.c"
                     + 1)];
  struct trie *next[(
# 4308 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 4308 "grep_single_original.c"
                   + 1)];
  char *target;
  int mind2;
  char *trans;
};


static void enqueue (struct tree *, struct trie **);
static void treefails (register struct tree *, struct trie *, struct trie *);
static void treedelta (register struct tree *,register unsigned int, unsigned char *);
static int hasevery (register struct tree *, register struct tree *);
static void treenext (struct tree *, struct trie **);
static char * bmexec (kwset_t, char *, size_t);
static char * cwexec (kwset_t, char *, size_t, struct kwsmatch *);



kwset_t
kwsalloc(trans)
     char *trans;
{
  struct kwset *kwset;

  kwset = (struct kwset *) xmalloc(sizeof (struct kwset));
  if (!kwset)
    return 0;

  _obstack_begin ((&kwset->obstack), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
  kwset->words = 0;
  kwset->trie
    = (struct trie *) __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((sizeof (struct trie))); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); });
  if (!kwset->trie)
    {
      kwsfree((kwset_t) kwset);
      return 0;
    }
  kwset->trie->accepting = 0;
  kwset->trie->links = 0;
  kwset->trie->parent = 0;
  kwset->trie->next = 0;
  kwset->trie->fail = 0;
  kwset->trie->depth = 0;
  kwset->trie->shift = 0;
  kwset->mind = 0x7fffffff;
  kwset->maxd = -1;
  kwset->target = 0;
  kwset->trans = trans;

  return (kwset_t) kwset;
}



char *
kwsincr(kws, text, len)
     kwset_t kws;
     char *text;
     size_t len;
{
  struct kwset *kwset;
  register struct trie *trie;
  register unsigned char label;
  register struct tree *link;
  register int depth;
  struct tree *links[12];
  enum { L, R } dirs[12];
  struct tree *t, *r, *l, *rl, *lr;

  kwset = (struct kwset *) kws;
  trie = kwset->trie;
  text += len;



  while (len--)
    {
      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;




      link = trie->links;
      links[0] = (struct tree *) &trie->links;
      dirs[0] = L;
      depth = 1;

      while (link && label != link->label)
 {
   links[depth] = link;
   if (label < link->label)
     dirs[depth++] = L, link = link->llink;
   else
     dirs[depth++] = R, link = link->rlink;
 }




      if (!link)
 {
   link = (struct tree *) __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((sizeof (struct tree))); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); })
                                 ;
   if (!link)
     return gettext ("memory exhausted");
   link->llink = 0;
   link->rlink = 0;
   link->trie = (struct trie *) __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((sizeof (struct trie))); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); })
                                ;
   if (!link->trie)
     return gettext ("memory exhausted");
   link->trie->accepting = 0;
   link->trie->links = 0;
   link->trie->parent = trie;
   link->trie->next = 0;
   link->trie->fail = 0;
   link->trie->depth = trie->depth + 1;
   link->trie->shift = 0;
   link->label = label;
   link->balance = 0;


   if (dirs[--depth] == L)
     links[depth]->llink = link;
   else
     links[depth]->rlink = link;


   while (depth && !links[depth]->balance)
     {
       if (dirs[depth] == L)
  --links[depth]->balance;
       else
  ++links[depth]->balance;
       --depth;
     }


   if (depth && ((dirs[depth] == L && --links[depth]->balance)
   || (dirs[depth] == R && ++links[depth]->balance)))
     {
       switch (links[depth]->balance)
  {
  case (char) -2:
    switch (dirs[depth + 1])
      {
      case L:
        r = links[depth], t = r->llink, rl = t->rlink;
        t->rlink = r, r->llink = rl;
        t->balance = r->balance = 0;
        break;
      case R:
        r = links[depth], l = r->llink, t = l->rlink;
        rl = t->rlink, lr = t->llink;
        t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
        l->balance = t->balance != 1 ? 0 : -1;
        r->balance = t->balance != (char) -1 ? 0 : 1;
        t->balance = 0;
        break;
      default:
        abort ();
      }
    break;
  case 2:
    switch (dirs[depth + 1])
      {
      case R:
        l = links[depth], t = l->rlink, lr = t->llink;
        t->llink = l, l->rlink = lr;
        t->balance = l->balance = 0;
        break;
      case L:
        l = links[depth], r = l->rlink, t = r->llink;
        lr = t->llink, rl = t->rlink;
        t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
        l->balance = t->balance != 1 ? 0 : -1;
        r->balance = t->balance != (char) -1 ? 0 : 1;
        t->balance = 0;
        break;
      default:
        abort ();
      }
    break;
  default:
    abort ();
  }

       if (dirs[depth - 1] == L)
  links[depth - 1]->llink = t;
       else
  links[depth - 1]->rlink = t;
     }
 }

      trie = link->trie;
    }



  if (!trie->accepting)
    trie->accepting = 1 + 2 * kwset->words;
  ++kwset->words;


  if (trie->depth < kwset->mind)
    kwset->mind = trie->depth;
  if (trie->depth > kwset->maxd)
    kwset->maxd = trie->depth;

  return 0;
}



static void
enqueue(tree, last)
     struct tree *tree;
     struct trie **last;
{
  if (!tree)
    return;
  enqueue(tree->llink, last);
  enqueue(tree->rlink, last);
  (*last) = (*last)->next = tree->trie;
}




static void
treefails(tree, fail, recourse)
     register struct tree *tree;
     struct trie *fail;
     struct trie *recourse;
{
  register struct tree *link;

  if (!tree)
    return;

  treefails(tree->llink, fail, recourse);
  treefails(tree->rlink, fail, recourse);



  while (fail)
    {
      link = fail->links;
      while (link && tree->label != link->label)
 if (tree->label < link->label)
   link = link->llink;
 else
   link = link->rlink;
      if (link)
 {
   tree->trie->fail = link->trie;
   return;
 }
      fail = fail->fail;
    }

  tree->trie->fail = recourse;
}



static void
treedelta(tree, depth, delta)
     register struct tree *tree;
     register unsigned int depth;
     unsigned char delta[];
{
  if (!tree)
    return;
  treedelta(tree->llink, depth, delta);
  treedelta(tree->rlink, depth, delta);
  if (depth < delta[tree->label])
    delta[tree->label] = depth;
}


static int
hasevery(a, b)
     register struct tree *a;
     register struct tree *b;
{
  if (!b)
    return 1;
  if (!hasevery(a, b->llink))
    return 0;
  if (!hasevery(a, b->rlink))
    return 0;
  while (a && b->label != a->label)
    if (b->label < a->label)
      a = a->llink;
    else
      a = a->rlink;
  return !!a;
}



static void
treenext(tree, next)
     struct tree *tree;
     struct trie *next[];
{
  if (!tree)
    return;
  treenext(tree->llink, next);
  treenext(tree->rlink, next);
  next[tree->label] = tree->trie;
}



char *
kwsprep(kws)
     kwset_t kws;
{
  register struct kwset *kwset;
  register int i;
  register struct trie *curr, *fail;
  register char *trans;
  unsigned char delta[(
# 4631 "grep_single_original.c" 3 4
                     (0x7f * 2 + 1) 
# 4631 "grep_single_original.c"
                     + 1)];
  struct trie *last, *next[(
# 4632 "grep_single_original.c" 3 4
                          (0x7f * 2 + 1) 
# 4632 "grep_single_original.c"
                          + 1)];

  kwset = (struct kwset *) kws;




  if (kwset->mind < 256)
    for (i = 0; i < (
# 4640 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 4640 "grep_single_original.c"
                   + 1); ++i)
      delta[i] = kwset->mind;
  else
    for (i = 0; i < (
# 4643 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 4643 "grep_single_original.c"
                   + 1); ++i)
      delta[i] = 255;



  if (kwset->words == 1 && kwset->trans == 0)
    {

      kwset->target = __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((kwset->mind)); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); });
      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
 {
   kwset->target[i] = curr->links->label;
   curr = curr->links->trie;
 }

      for (i = 0; i < kwset->mind; ++i)
 delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
      kwset->mind2 = kwset->mind;


      for (i = 0; i < kwset->mind - 1; ++i)
 if (kwset->target[i] == kwset->target[kwset->mind - 1])
   kwset->mind2 = kwset->mind - (i + 1);
    }
  else
    {


      for (curr = last = kwset->trie; curr; curr = curr->next)
 {

   enqueue(curr->links, &last);

   curr->shift = kwset->mind;
   curr->maxshift = kwset->mind;


   treedelta(curr->links, curr->depth, delta);


   treefails(curr->links, curr->fail, kwset->trie);



   for (fail = curr->fail; fail; fail = fail->fail)
     {



       if (!hasevery(fail->links, curr->links))
  if (curr->depth - fail->depth < fail->shift)
    fail->shift = curr->depth - fail->depth;




       if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
  fail->maxshift = curr->depth - fail->depth;
     }
 }



      for (curr = kwset->trie->next; curr; curr = curr->next)
 {
   if (curr->maxshift > curr->parent->maxshift)
     curr->maxshift = curr->parent->maxshift;
   if (curr->shift > curr->maxshift)
     curr->shift = curr->maxshift;
 }



      for (i = 0; i < (
# 4716 "grep_single_original.c" 3 4
                     (0x7f * 2 + 1) 
# 4716 "grep_single_original.c"
                     + 1); ++i)
 next[i] = 0;
      treenext(kwset->trie->links, next);

      if ((trans = kwset->trans) != 0)
 for (i = 0; i < (
# 4721 "grep_single_original.c" 3 4
                (0x7f * 2 + 1) 
# 4721 "grep_single_original.c"
                + 1); ++i)
   kwset->next[i] = next[(unsigned char) trans[i]];
      else
 for (i = 0; i < (
# 4724 "grep_single_original.c" 3 4
                (0x7f * 2 + 1) 
# 4724 "grep_single_original.c"
                + 1); ++i)
   kwset->next[i] = next[i];
    }


  if ((trans = kwset->trans) != 0)
    for (i = 0; i < (
# 4730 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 4730 "grep_single_original.c"
                   + 1); ++i)
      kwset->delta[i] = delta[(unsigned char) trans[i]];
  else
    for (i = 0; i < (
# 4733 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 4733 "grep_single_original.c"
                   + 1); ++i)
      kwset->delta[i] = delta[i];

  return 0;
}




static char *
bmexec(kws, text, size)
     kwset_t kws;
     char *text;
     size_t size;
{
  struct kwset *kwset;
  register unsigned char *d1;
  register char *ep, *sp, *tp;
  register int d, gc, i, len, md2;

  kwset = (struct kwset *) kws;
  len = kwset->mind;

  if (len == 0)
    return text;
  if (len > size)
    return 0;
  if (len == 1)
    return memchr(text, kwset->target[0], size);

  d1 = kwset->delta;
  sp = kwset->target + len;
  gc = ((unsigned char) (sp[-2]));
  md2 = kwset->mind2;
  tp = text + len;


  if (size > 12 * len)

    for (ep = text + size - 11 * len;;)
      {
 while (tp <= ep)
   {
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     if (d == 0)
       goto found;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     if (d == 0)
       goto found;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     if (d == 0)
       goto found;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
     d = d1[((unsigned char) (tp[-1]))], tp += d;
   }
 break;
      found:
 if (((unsigned char) (tp[-2])) == gc)
   {
     for (i = 3; i <= len && ((unsigned char) (tp[-i])) == ((unsigned char) (sp[-i])); ++i)
       ;
     if (i > len)
       return tp - len;
   }
 tp += md2;
      }



  ep = text + size;
  d = d1[((unsigned char) (tp[-1]))];
  while (d <= ep - tp)
    {
      d = d1[((unsigned char) ((tp += d)[-1]))];
      if (d != 0)
 continue;
      if (((unsigned char) (tp[-2])) == gc)
 {
   for (i = 3; i <= len && ((unsigned char) (tp[-i])) == ((unsigned char) (sp[-i])); ++i)
     ;
   if (i > len)
     return tp - len;
 }
      d = md2;
    }

  return 0;
}


static char *
cwexec(kws, text, len, kwsmatch)
     kwset_t kws;
     char *text;
     size_t len;
     struct kwsmatch *kwsmatch;
{
  struct kwset *kwset;
  struct trie **next, *trie, *accept;
  char *beg, *lim, *mch, *lmch;
  register unsigned char c, *delta;
  register int d;
  register char *end, *qlim;
  register struct tree *tree;
  register char *trans;






  kwset = (struct kwset *) kws;
  if (len < kwset->mind)
    return 0;
  next = kwset->next;
  delta = kwset->delta;
  trans = kwset->trans;
  lim = text + len;
  end = text;
  if ((d = kwset->mind) != 0)
    mch = 0;
  else
    {
      mch = text, accept = kwset->trie;
      goto match;
    }

  if (len >= 4 * kwset->mind)
    qlim = lim - 4 * kwset->mind;
  else
    qlim = 0;

  while (lim - end >= d)
    {
      if (qlim && end <= qlim)
 {
   end += d - 1;
   while ((d = delta[c = *end]) && end < qlim)
     {
       end += d;
       end += delta[(unsigned char) *end];
       end += delta[(unsigned char) *end];
     }
   ++end;
 }
      else
 d = delta[c = (end += d)[-1]];
      if (d)
 continue;
      beg = end - 1;
      trie = next[c];
      if (trie->accepting)
 {
   mch = beg;
   accept = trie;
 }
      d = trie->shift;
      while (beg > text)
 {
   c = trans ? trans[(unsigned char) *--beg] : *--beg;
   tree = trie->links;
   while (tree && c != tree->label)
     if (c < tree->label)
       tree = tree->llink;
     else
       tree = tree->rlink;
   if (tree)
     {
       trie = tree->trie;
       if (trie->accepting)
  {
    mch = beg;
    accept = trie;
  }
     }
   else
     break;
   d = trie->shift;
 }
      if (mch)
 goto match;
    }
  return 0;

 match:



  if (lim - mch > kwset->maxd)
    lim = mch + kwset->maxd;
  lmch = 0;
  d = 1;
  while (lim - end >= d)
    {
      if ((d = delta[c = (end += d)[-1]]) != 0)
 continue;
      beg = end - 1;
      if (!(trie = next[c]))
 {
   d = 1;
   continue;
 }
      if (trie->accepting && beg <= mch)
 {
   lmch = beg;
   accept = trie;
 }
      d = trie->shift;
      while (beg > text)
 {
   c = trans ? trans[(unsigned char) *--beg] : *--beg;
   tree = trie->links;
   while (tree && c != tree->label)
     if (c < tree->label)
       tree = tree->llink;
     else
       tree = tree->rlink;
   if (tree)
     {
       trie = tree->trie;
       if (trie->accepting && beg <= mch)
  {
    lmch = beg;
    accept = trie;
  }
     }
   else
     break;
   d = trie->shift;
 }
      if (lmch)
 {
   mch = lmch;
   goto match;
 }
      if (!d)
 d = 1;
    }

  if (kwsmatch)
    {
      kwsmatch->strchr = accept->accepting / 2;
      kwsmatch->beg[0] = mch;
      kwsmatch->size[0] = accept->depth;
    }
  return mch;
}
# 4993 "grep_single_original.c"
char *
kwsexec(kws, text, size, kwsmatch)
     kwset_t kws;
     char *text;
     size_t size;
     struct kwsmatch *kwsmatch;
{
  struct kwset *kwset;
  char *ret;

  kwset = (struct kwset *) kws;
  if (kwset->words == 1 && kwset->trans == 0)
    {
      ret = bmexec(kws, text, size);
      if (kwsmatch != 0 && ret != 0)
 {
   kwsmatch->strchr = 0;
   kwsmatch->beg[0] = ret;
   kwsmatch->size[0] = kwset->mind;
 }
      return ret;
    }
  else
    return cwexec(kws, text, size, kwsmatch);
}


void
kwsfree(kws)
     kwset_t kws;
{
  struct kwset *kwset;

  kwset = (struct kwset *) kws;
  __extension__ ({ struct obstack *__o = (&kwset->obstack); void *__obj = (0); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = __obj; else (obstack_free) (__o, __obj); });
  free(kws);
}
# 5077 "grep_single_original.c"
# 1 "/usr/include/gnu-versions.h" 1 3 4
# 5078 "grep_single_original.c" 2
# 5693 "grep_single_original.c"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 5694 "grep_single_original.c" 2
# 5922 "grep_single_original.c"
static char re_syntax_table[256];

static void
init_syntax_once ()
{
    register int c;
    static int done = 0;

    if (done)
 return;
    (memset (re_syntax_table, '\0', sizeof re_syntax_table), (re_syntax_table));


    for (c = 0; c < 256; c++)

 if ((1 && 
# 5937 "grep_single_original.c" 3 4
    ((*__ctype_b_loc ())[(int) ((
# 5937 "grep_single_original.c"
    c
# 5937 "grep_single_original.c" 3 4
    ))] & (unsigned short int) _ISalnum)
# 5937 "grep_single_original.c"
    ))




     re_syntax_table[c] = 1;

    re_syntax_table['_'] = 1;

    done = 1;
}
# 6053 "grep_single_original.c"
typedef char boolean;



static int re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct re_registers *regs, int stop)




               ;






typedef enum
{
  no_op = 0,


  succeed,


  exactn,


  anychar,







  charset,



  charset_not,
# 6101 "grep_single_original.c"
  start_memory,
# 6110 "grep_single_original.c"
  stop_memory,



  duplicate,


  begline,


  endline,



  begbuf,


  endbuf,


  jump,


  jump_past_alt,



  on_failure_jump,



  on_failure_keep_string_jump,



  pop_failure_jump,
# 6154 "grep_single_original.c"
  maybe_pop_jump,






  dummy_failure_jump,



  push_dummy_failure,



  succeed_n,



  jump_n,




  set_number_at,

  wordchar,
  notwordchar,

  wordbeg,
  wordend,

  wordbound,
  notwordbound
# 6201 "grep_single_original.c"
} re_opcode_t;
# 6658 "grep_single_original.c"
reg_syntax_t re_syntax_options;
# 6668 "grep_single_original.c"
reg_syntax_t
re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = re_syntax_options;

  re_syntax_options = syntax;






  return ret;
}
# 6692 "grep_single_original.c"
static const char *re_error_msgid[] =
  {
    "Success",
    "No match",
    "Invalid regular expression",
    "Invalid collation character",
    "Invalid character class name",
    "Trailing backslash",
    "Invalid back reference",
    "Unmatched [ or [^",
    "Unmatched ( or \\(",
    "Unmatched \\{",
    "Invalid content of \\{\\}",
    "Invalid range end",
    "Memory exhausted",
    "Invalid preceding regular expression",
    "Premature end of regular expression",
    "Regular expression too big",
    "Unmatched ) or \\)",
  };
# 6798 "grep_single_original.c"
int re_max_failures = 20000;




union fail_stack_elt
{
  unsigned char *pointer;
  int integer;
};

typedef union fail_stack_elt fail_stack_elt_t;

typedef struct
{
  fail_stack_elt_t *stack;
  unsigned size;
  unsigned avail;
} fail_stack_type;
# 7131 "grep_single_original.c"
typedef union
{
  fail_stack_elt_t word;
  struct
  {



    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
  } bits;
} register_info_type;
# 7173 "grep_single_original.c"
static char reg_unset_dummy;





static reg_errcode_t regex_compile (const char *pattern, size_t size, reg_syntax_t syntax, struct re_pattern_buffer *bufp)

                                           ;
static void store_op1 (re_opcode_t op, unsigned char *loc, int arg);
static void store_op2 (re_opcode_t op, unsigned char *loc, int arg1, int arg2)
                         ;
static void insert_op1 (re_opcode_t op, unsigned char *loc, int arg, unsigned char *end)
                                   ;
static void insert_op2 (re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end)
                                              ;
static boolean at_begline_loc_p (const char *pattern, const char *p, reg_syntax_t syntax)
                             ;
static boolean at_endline_loc_p (const char *p, const char *pend, reg_syntax_t syntax)
                             ;
static reg_errcode_t compile_range (const char **p_ptr, const char *pend, char *translate, reg_syntax_t syntax, unsigned char *b)



                             ;
# 7344 "grep_single_original.c"
typedef unsigned regnum_t;







typedef long pattern_offset_t;

typedef struct
{
  pattern_offset_t begalt_offset;
  pattern_offset_t fixup_alt_jump;
  pattern_offset_t inner_group_offset;
  pattern_offset_t laststart_offset;
  regnum_t regnum;
} compile_stack_elt_t;


typedef struct
{
  compile_stack_elt_t *stack;
  unsigned size;
  unsigned avail;
} compile_stack_type;
# 7480 "grep_single_original.c"
static boolean group_in_compile_stack (compile_stack_type compile_stack, regnum_t regnum)

                        ;
# 7506 "grep_single_original.c"
static reg_errcode_t
regex_compile (pattern, size, syntax, bufp)
     const char *pattern;
     size_t size;
     reg_syntax_t syntax;
     struct re_pattern_buffer *bufp;
{



  register unsigned char c, c1;


  const char *p1;


  register unsigned char *b;


  compile_stack_type compile_stack;


  const char *p = pattern;
  const char *pend = pattern + size;


  char * translate = bufp->translate;





  unsigned char *pending_exact = 0;




  unsigned char *laststart = 0;


  unsigned char *begalt;



  const char *beg_interval;




  unsigned char *fixup_alt_jump = 0;




  regnum_t regnum = 0;
# 7575 "grep_single_original.c"
  compile_stack.stack = ((compile_stack_elt_t *) xmalloc ((32) * sizeof (compile_stack_elt_t)));
  if (compile_stack.stack == 
# 7576 "grep_single_original.c" 3 4
                            ((void *)0)
# 7576 "grep_single_original.c"
                                )
    return REG_ESPACE;

  compile_stack.size = 32;
  compile_stack.avail = 0;


  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;




  bufp->used = 0;


  bufp->re_nsub = 0;



   init_syntax_once ();


  if (bufp->allocated == 0)
    {
      if (bufp->buffer)
 {


          ((bufp->buffer) = (unsigned char *) realloc (bufp->buffer, (32) * sizeof (unsigned char)));
        }
      else
        {
          bufp->buffer = ((unsigned char *) xmalloc ((32) * sizeof (unsigned char)));
        }
      if (!bufp->buffer) zzz return (free (compile_stack.stack), REG_ESPACE);

      bufp->allocated = 32;
    }

  begalt = b = bufp->buffer;


  while (p != pend)
    {
      zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);

      switch (c)
        {
        case '^':
          {
            if (
                   p == pattern + 1

                || syntax & (((((unsigned long int) 1) << 1) << 1) << 1)

                || at_begline_loc_p (pattern, p, syntax))
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7634 "grep_single_original.c" 3 4
             ((void *)0)
# 7634 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (begline); zzz } while (0);
            else
              goto normal_char;
          }
          break;


        case '$':
          {
            if (
                   p == pend

                || syntax & (((((unsigned long int) 1) << 1) << 1) << 1)

                || at_endline_loc_p (p, pend, syntax))
               zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7649 "grep_single_original.c" 3 4
              ((void *)0)
# 7649 "grep_single_original.c"
              ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (endline); zzz } while (0);
             else
               goto normal_char;
           }
           break;


 case '+':
        case '?':
          if ((syntax & (((unsigned long int) 1) << 1))
              || (syntax & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            goto normal_char;
        handle_plus:
        case '*':

          if (!laststart)
            {
              if (syntax & (((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1))
                zzz return (free (compile_stack.stack), REG_BADRPT);
              else if (!(syntax & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)))
                goto normal_char;
            }

          {

            boolean keep_string_p = 0;


            char zero_times_ok = 0, many_times_ok = 0;






            for (;;)
              {
                zero_times_ok |= c != '+';
                many_times_ok |= c != '?';

                if (p == pend)
                  break;

                zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);

                if (c == '*'
                    || (!(syntax & (((unsigned long int) 1) << 1)) && (c == '+' || c == '?')))
                  ;

                else if (syntax & (((unsigned long int) 1) << 1) && c == '\\')
                  {
                    if (p == pend) zzz return (free (compile_stack.stack), REG_EESCAPE);

                    zzz do {if (p == pend) return REG_EEND; zzz c1 = (unsigned char) *p++; zzz if (translate) c1 = (unsigned char) translate[c1]; zzz } while (0);
                    if (!(c1 == '+' || c1 == '?'))
                      {
                        p--;
                        p--;
                        break;
                      }

                    c = c1;
                  }
                else
                  {
                    p--;
                    break;
                  }


               }



            if (!laststart)
              break;



            if (many_times_ok)
              {
# 7739 "grep_single_original.c"
                ;


                zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7742 "grep_single_original.c" 3 4
               ((void *)0)
# 7742 "grep_single_original.c"
               ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);






                if (zzz (translate ? (char) translate[(unsigned char) (*(p - 2))] : (*(p - 2))) == zzz (translate ? (char) translate[(unsigned char) ('.')] : ('.'))
      && zero_times_ok
                    && p < pend && zzz (translate ? (char) translate[(unsigned char) (*p)] : (*p)) == zzz (translate ? (char) translate[(unsigned char) ('\n')] : ('\n'))
                    && !(syntax & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)))
                  {
                    zzz store_op1 (jump, b, (int) ((laststart) - (b) - 3));
                    keep_string_p = 1;
                  }
                else

                  zzz store_op1 (maybe_pop_jump, b, (int) ((laststart - 3) - (b) - 3));


                b += 3;
              }



            zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7767 "grep_single_original.c" 3 4
           ((void *)0)
# 7767 "grep_single_original.c"
           ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);
            zzz insert_op1 (keep_string_p ? on_failure_keep_string_jump : on_failure_jump, laststart, (int) ((b + 3) - (laststart) - 3), b)

                                          ;
            pending_exact = 0;
            b += 3;

            if (!zero_times_ok)
              {





                zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7781 "grep_single_original.c" 3 4
               ((void *)0)
# 7781 "grep_single_original.c"
               ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);
                zzz insert_op1 (dummy_failure_jump, laststart, (int) ((laststart + 6) - (laststart) - 3), b);
                b += 3;
              }
            }
   break;


 case '.':
          laststart = b;
          zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7791 "grep_single_original.c" 3 4
         ((void *)0)
# 7791 "grep_single_original.c"
         ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (anychar); zzz } while (0);
          break;


        case '[':
          {
            boolean had_char_class = 0;

            if (p == pend) zzz return (free (compile_stack.stack), REG_EBRACK);



     zzz while ((unsigned long) (b - bufp->buffer + (34)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7803 "grep_single_original.c" 3 4
    ((void *)0)
# 7803 "grep_single_original.c"
    ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);

            laststart = b;



            zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7809 "grep_single_original.c" 3 4
           ((void *)0)
# 7809 "grep_single_original.c"
           ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (*p == '^' ? charset_not : charset); zzz } while (0);
            if (*p == '^')
              p++;


            p1 = p;


            zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 7817 "grep_single_original.c" 3 4
           ((void *)0)
# 7817 "grep_single_original.c"
           ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) ((1 << 8) / 8); zzz } while (0);


            (memset (b, '\0', (1 << 8) / 8), (b));


            if ((re_opcode_t) b[-2] == charset_not
                && (syntax & ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
              zzz (b[((unsigned char) ('\n')) / 8] zzz |= 1 << (((unsigned char) '\n') % 8));


            for (;;)
              {
                if (p == pend) zzz return (free (compile_stack.stack), REG_EBRACK);

                zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);


                if ((syntax & ((unsigned long int) 1)) && c == '\\')
                  {
                    if (p == pend) zzz return (free (compile_stack.stack), REG_EESCAPE);

                    zzz do {if (p == pend) return REG_EEND; zzz c1 = (unsigned char) *p++; zzz if (translate) c1 = (unsigned char) translate[c1]; zzz } while (0);
                    zzz (b[((unsigned char) (c1)) / 8] zzz |= 1 << (((unsigned char) c1) % 8));
                    continue;
                  }




                if (c == ']' && p != p1 + 1)
                  break;



                if (had_char_class && c == '-' && *p != ']')
                  zzz return (free (compile_stack.stack), REG_ERANGE);





                if (c == '-'
                    && !(p - 2 >= pattern && p[-2] == '[')
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']')
                  {
                    reg_errcode_t ret
                      = compile_range (&p, pend, translate, syntax, b);
                    if (ret != REG_NOERROR) zzz return (free (compile_stack.stack), ret);
                  }

                else if (p[0] == '-' && p[1] != ']')
                  {
                    reg_errcode_t ret;


                    zzz do {if (p == pend) return REG_EEND; zzz c1 = (unsigned char) *p++; zzz if (translate) c1 = (unsigned char) translate[c1]; zzz } while (0);

                    ret = compile_range (&p, pend, translate, syntax, b);
                    if (ret != REG_NOERROR) zzz return (free (compile_stack.stack), ret);
                  }




                else if (syntax & ((((unsigned long int) 1) << 1) << 1) && c == '[' && *p == ':')
                  {
                    char str[6 + 1];

                    zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);
                    c1 = 0;


                    if (p == pend) zzz return (free (compile_stack.stack), REG_EBRACK);

                    for (;;)
                      {
                        zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);
                        if ((c == ':' && *p == ']') || p == pend)
                          break;
   if (c1 < 6)
     str[c1++] = c;
   else

     str[0] = '\0';
                      }
                    str[c1] = '\0';




                    if (c == ':' && *p == ']')
                      {
# 7944 "grep_single_original.c"
                        int ch;
                        boolean is_alnum = ((strcmp (str, "alnum") == 0));
                        boolean is_alpha = ((strcmp (str, "alpha") == 0));
                        boolean is_blank = ((strcmp (str, "blank") == 0));
                        boolean is_cntrl = ((strcmp (str, "cntrl") == 0));
                        boolean is_digit = ((strcmp (str, "digit") == 0));
                        boolean is_graph = ((strcmp (str, "graph") == 0));
                        boolean is_lower = ((strcmp (str, "lower") == 0));
                        boolean is_print = ((strcmp (str, "print") == 0));
                        boolean is_punct = ((strcmp (str, "punct") == 0));
                        boolean is_space = ((strcmp (str, "space") == 0));
                        boolean is_upper = ((strcmp (str, "upper") == 0));
                        boolean is_xdigit = ((strcmp (str, "xdigit") == 0));

                        if (!zzz (((strcmp (str, "alpha") == 0)) || ((strcmp (str, "upper") == 0)) zzz || ((strcmp (str, "lower") == 0)) || ((strcmp (str, "digit") == 0)) zzz || ((strcmp (str, "alnum") == 0)) || ((strcmp (str, "xdigit") == 0)) zzz || ((strcmp (str, "space") == 0)) || ((strcmp (str, "print") == 0)) zzz || ((strcmp (str, "punct") == 0)) || ((strcmp (str, "graph") == 0)) zzz || ((strcmp (str, "cntrl") == 0)) || ((strcmp (str, "blank") == 0))))
     zzz return (free (compile_stack.stack), REG_ECTYPE);



                        zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);

                        if (p == pend) zzz return (free (compile_stack.stack), REG_EBRACK);

                        for (ch = 0; ch < 1 << 8; ch++)
                          {


                            if ( (is_alnum && (1 && 
# 7971 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7971 "grep_single_original.c"
                                                ch
# 7971 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISalnum)
# 7971 "grep_single_original.c"
                                                ))
                                || (is_alpha && (1 && 
# 7972 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7972 "grep_single_original.c"
                                                ch
# 7972 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISalpha)
# 7972 "grep_single_original.c"
                                                ))
                                || (is_blank && (1 && 
# 7973 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7973 "grep_single_original.c"
                                                ch
# 7973 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISblank)
# 7973 "grep_single_original.c"
                                                ))
                                || (is_cntrl && (1 && 
# 7974 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7974 "grep_single_original.c"
                                                ch
# 7974 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _IScntrl)
# 7974 "grep_single_original.c"
                                                )))
         zzz (b[((unsigned char) (ch)) / 8] zzz |= 1 << (((unsigned char) ch) % 8));
       if ( (is_digit && (1 && 
# 7976 "grep_single_original.c" 3 4
                           ((*__ctype_b_loc ())[(int) ((
# 7976 "grep_single_original.c"
                           ch
# 7976 "grep_single_original.c" 3 4
                           ))] & (unsigned short int) _ISdigit)
# 7976 "grep_single_original.c"
                           ))
                                || (is_graph && (1 && 
# 7977 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7977 "grep_single_original.c"
                                                ch
# 7977 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISgraph)
# 7977 "grep_single_original.c"
                                                ))
                                || (is_lower && (1 && 
# 7978 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7978 "grep_single_original.c"
                                                ch
# 7978 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISlower)
# 7978 "grep_single_original.c"
                                                ))
                                || (is_print && (1 && 
# 7979 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7979 "grep_single_original.c"
                                                ch
# 7979 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISprint)
# 7979 "grep_single_original.c"
                                                )))
         zzz (b[((unsigned char) (ch)) / 8] zzz |= 1 << (((unsigned char) ch) % 8));
       if ( (is_punct && (1 && 
# 7981 "grep_single_original.c" 3 4
                           ((*__ctype_b_loc ())[(int) ((
# 7981 "grep_single_original.c"
                           ch
# 7981 "grep_single_original.c" 3 4
                           ))] & (unsigned short int) _ISpunct)
# 7981 "grep_single_original.c"
                           ))
                                || (is_space && (1 && 
# 7982 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7982 "grep_single_original.c"
                                                ch
# 7982 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISspace)
# 7982 "grep_single_original.c"
                                                ))
                                || (is_upper && (1 && 
# 7983 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7983 "grep_single_original.c"
                                                ch
# 7983 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISupper)
# 7983 "grep_single_original.c"
                                                ))
                                || (is_xdigit && (1 && 
# 7984 "grep_single_original.c" 3 4
                                                ((*__ctype_b_loc ())[(int) ((
# 7984 "grep_single_original.c"
                                                ch
# 7984 "grep_single_original.c" 3 4
                                                ))] & (unsigned short int) _ISxdigit)
# 7984 "grep_single_original.c"
                                                )))
         zzz (b[((unsigned char) (ch)) / 8] zzz |= 1 << (((unsigned char) ch) % 8));
       if ( translate && (is_upper || is_lower)
    && ((1 && 
# 7987 "grep_single_original.c" 3 4
       ((*__ctype_b_loc ())[(int) ((
# 7987 "grep_single_original.c"
       ch
# 7987 "grep_single_original.c" 3 4
       ))] & (unsigned short int) _ISupper)
# 7987 "grep_single_original.c"
       ) || (1 && 
# 7987 "grep_single_original.c" 3 4
                       ((*__ctype_b_loc ())[(int) ((
# 7987 "grep_single_original.c"
                       ch
# 7987 "grep_single_original.c" 3 4
                       ))] & (unsigned short int) _ISlower)
# 7987 "grep_single_original.c"
                       )))
         zzz (b[((unsigned char) (ch)) / 8] zzz |= 1 << (((unsigned char) ch) % 8));
                          }
                        had_char_class = 1;

                      }
                    else
                      {
                        c1++;
                        while (c1--)
                          p--;
                        zzz (b[((unsigned char) ('[')) / 8] zzz |= 1 << (((unsigned char) '[') % 8));
                        zzz (b[((unsigned char) (':')) / 8] zzz |= 1 << (((unsigned char) ':') % 8));
                        had_char_class = 0;
                      }
                  }
                else
                  {
                    had_char_class = 0;
                    zzz (b[((unsigned char) (c)) / 8] zzz |= 1 << (((unsigned char) c) % 8));
                  }
              }



            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
              b[-1]--;
            b += b[-1];
          }
          break;


 case '(':
          if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto handle_open;
          else
            goto normal_char;


        case ')':
          if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto handle_close;
          else
            goto normal_char;


        case '\n':
          if (syntax & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto handle_alt;
          else
            goto normal_char;


 case '|':
          if (syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto handle_alt;
          else
            goto normal_char;


        case '{':
           if (syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
             goto handle_interval;
           else
             goto normal_char;


        case '\\':
          if (p == pend) zzz return (free (compile_stack.stack), REG_EESCAPE);




          zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz } while (0);

          switch (c)
            {
            case '(':
              if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                goto normal_backslash;

            handle_open:
              bufp->re_nsub++;
              regnum++;

              if ((compile_stack.avail == compile_stack.size))
                {
                  ((compile_stack.stack) = (compile_stack_elt_t *) realloc (compile_stack.stack, (compile_stack.size << 1) * sizeof (compile_stack_elt_t)))
                                                ;
                  if (compile_stack.stack == 
# 8076 "grep_single_original.c" 3 4
                                            ((void *)0)
# 8076 "grep_single_original.c"
                                                ) return REG_ESPACE;

                  compile_stack.size <<= 1;
                }





              (compile_stack.stack[compile_stack.avail]).begalt_offset = begalt - bufp->buffer;
              (compile_stack.stack[compile_stack.avail]).fixup_alt_jump
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
              (compile_stack.stack[compile_stack.avail]).laststart_offset = b - bufp->buffer;
              (compile_stack.stack[compile_stack.avail]).regnum = regnum;





              if (regnum <= 255)
                {
                  (compile_stack.stack[compile_stack.avail]).inner_group_offset = b - bufp->buffer + 2;
                  zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8098 "grep_single_original.c" 3 4
                 ((void *)0)
# 8098 "grep_single_original.c"
                 ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (start_memory); zzz *b++ = (unsigned char) (regnum); zzz *b++ = (unsigned char) (0); zzz } while (0);
                }

              compile_stack.avail++;

              fixup_alt_jump = 0;
              laststart = 0;
              begalt = b;



       pending_exact = 0;
              break;


            case ')':
              if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) goto normal_backslash;

              if ((compile_stack.avail == 0))
  {
    if (syntax & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
      goto normal_backslash;
    else
      zzz return (free (compile_stack.stack), REG_ERPAREN);
  }

            handle_close:
              if (fixup_alt_jump)
                {



                  zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8130 "grep_single_original.c" 3 4
                 ((void *)0)
# 8130 "grep_single_original.c"
                 ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (push_dummy_failure); zzz } while (0);



                  zzz store_op1 (jump_past_alt, fixup_alt_jump, (int) ((b - 1) - (fixup_alt_jump) - 3));
                }


              if ((compile_stack.avail == 0))
  {
    if (syntax & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
      goto normal_char;
    else
      zzz return (free (compile_stack.stack), REG_ERPAREN);
  }



              ;
              {



                regnum_t this_group_regnum;

                compile_stack.avail--;
                begalt = bufp->buffer + (compile_stack.stack[compile_stack.avail]).begalt_offset;
                fixup_alt_jump
                  = (compile_stack.stack[compile_stack.avail]).fixup_alt_jump
                    ? bufp->buffer + (compile_stack.stack[compile_stack.avail]).fixup_alt_jump - 1
                    : 0;
                laststart = bufp->buffer + (compile_stack.stack[compile_stack.avail]).laststart_offset;
                this_group_regnum = (compile_stack.stack[compile_stack.avail]).regnum;



  pending_exact = 0;



                if (this_group_regnum <= 255)
                  {
                    unsigned char *inner_group_loc
                      = bufp->buffer + (compile_stack.stack[compile_stack.avail]).inner_group_offset;

                    *inner_group_loc = regnum - this_group_regnum;
                    zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8176 "grep_single_original.c" 3 4
                   ((void *)0)
# 8176 "grep_single_original.c"
                   ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (stop_memory); zzz *b++ = (unsigned char) (this_group_regnum); zzz *b++ = (unsigned char) (regnum - this_group_regnum); zzz } while (0)
                                                           ;
                  }
              }
              break;


            case '|':
              if (syntax & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                goto normal_backslash;
            handle_alt:
              if (syntax & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                goto normal_char;



              zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8192 "grep_single_original.c" 3 4
             ((void *)0)
# 8192 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);
              zzz insert_op1 (on_failure_jump, begalt, (int) ((b + 6) - (begalt) - 3), b);
              pending_exact = 0;
              b += 3;
# 8213 "grep_single_original.c"
              if (fixup_alt_jump)
                zzz store_op1 (jump_past_alt, fixup_alt_jump, (int) ((b) - (fixup_alt_jump) - 3));




              fixup_alt_jump = b;
              zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8220 "grep_single_original.c" 3 4
             ((void *)0)
# 8220 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);
              b += 3;

              laststart = 0;
              begalt = b;
              break;


            case '{':

              if (!(syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))


                  || ((syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
                  || (p - 2 == pattern && p == pend))
                goto normal_backslash;

            handle_interval:
              {



                int lower_bound = -1, upper_bound = -1;

                beg_interval = p - 1;

                if (p == pend)
                  {
                    if (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                      goto unfetch_interval;
                    else
                      zzz return (free (compile_stack.stack), REG_EBRACE);
                  }

                zzz { if (p != pend) zzz { zzz zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0); zzz while ((1 && 
# 8254 "grep_single_original.c" 3 4
               ((*__ctype_b_loc ())[(int) ((
# 8254 "grep_single_original.c"
               c
# 8254 "grep_single_original.c" 3 4
               ))] & (unsigned short int) _ISdigit)
# 8254 "grep_single_original.c"
               )) zzz { zzz if (lower_bound < 0) zzz lower_bound = 0; zzz lower_bound = lower_bound * 10 + c - '0'; zzz if (p == pend) zzz break; zzz zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0); zzz } zzz } zzz };

                if (c == ',')
                  {
                    zzz { if (p != pend) zzz { zzz zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0); zzz while ((1 && 
# 8258 "grep_single_original.c" 3 4
                   ((*__ctype_b_loc ())[(int) ((
# 8258 "grep_single_original.c"
                   c
# 8258 "grep_single_original.c" 3 4
                   ))] & (unsigned short int) _ISdigit)
# 8258 "grep_single_original.c"
                   )) zzz { zzz if (upper_bound < 0) zzz upper_bound = 0; zzz upper_bound = upper_bound * 10 + c - '0'; zzz if (p == pend) zzz break; zzz zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0); zzz } zzz } zzz };
                    if (upper_bound < 0) upper_bound = (0x7fff);
                  }
                else

                  upper_bound = lower_bound;

                if (lower_bound < 0 || upper_bound > (0x7fff)
                    || lower_bound > upper_bound)
                  {
                    if (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                      goto unfetch_interval;
                    else
                      zzz return (free (compile_stack.stack), REG_BADBR);
                  }

                if (!(syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
                  {
                    if (c != '\\') zzz return (free (compile_stack.stack), REG_EBRACE);

                    zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);
                  }

                if (c != '}')
                  {
                    if (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                      goto unfetch_interval;
                    else
                      zzz return (free (compile_stack.stack), REG_BADBR);
                  }




                if (!laststart)
                  {
                    if (syntax & (((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1))
                      zzz return (free (compile_stack.stack), REG_BADRPT);
                    else if (syntax & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1))
                      laststart = b;
                    else
                      goto unfetch_interval;
                  }




                 if (upper_bound == 0)
                   {
                     zzz while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8307 "grep_single_original.c" 3 4
                    ((void *)0)
# 8307 "grep_single_original.c"
                    ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);
                     zzz insert_op1 (jump, laststart, (int) ((b + 3) - (laststart) - 3), b);
                     b += 3;
                   }
# 8321 "grep_single_original.c"
                 else
                   {

                     unsigned nbytes = 10 + (upper_bound > 1) * 10;

                     zzz while ((unsigned long) (b - bufp->buffer + (nbytes)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8326 "grep_single_original.c" 3 4
                    ((void *)0)
# 8326 "grep_single_original.c"
                    ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0);






                     zzz insert_op2 (succeed_n, laststart, (int) ((b + 5 + (upper_bound > 1) * 5) - (laststart) - 3), lower_bound, b)

                                               ;
                     b += 5;





                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
                     b += 5;

                     if (upper_bound > 1)
                       {






                         zzz store_op2 (jump_n, b, (int) ((laststart + 5) - (b) - 3), upper_bound - 1)
                                                      ;
                         b += 5;
# 8371 "grep_single_original.c"
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                         b += 5;
                       }
                   }
                pending_exact = 0;
                beg_interval = 
# 8377 "grep_single_original.c" 3 4
                              ((void *)0)
# 8377 "grep_single_original.c"
                                  ;
              }
              break;

            unfetch_interval:

               ;
               p = beg_interval;
               beg_interval = 
# 8385 "grep_single_original.c" 3 4
                             ((void *)0)
# 8385 "grep_single_original.c"
                                 ;


               zzz do {if (p == pend) return REG_EEND; zzz c = (unsigned char) *p++; zzz if (translate) c = (unsigned char) translate[c]; zzz } while (0);

               if (!(syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
                 {
                   if (p > pattern && p[-1] == '\\')
                     goto normal_backslash;
                 }
               goto normal_char;
# 8418 "grep_single_original.c"
            case 'w':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              laststart = b;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8422 "grep_single_original.c" 3 4
             ((void *)0)
# 8422 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (wordchar); zzz } while (0);
              break;


            case 'W':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              laststart = b;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8430 "grep_single_original.c" 3 4
             ((void *)0)
# 8430 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (notwordchar); zzz } while (0);
              break;


            case '<':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8437 "grep_single_original.c" 3 4
             ((void *)0)
# 8437 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (wordbeg); zzz } while (0);
              break;

            case '>':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8443 "grep_single_original.c" 3 4
             ((void *)0)
# 8443 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (wordend); zzz } while (0);
              break;

            case 'b':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8449 "grep_single_original.c" 3 4
             ((void *)0)
# 8449 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (wordbound); zzz } while (0);
              break;

            case 'B':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8455 "grep_single_original.c" 3 4
             ((void *)0)
# 8455 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (notwordbound); zzz } while (0);
              break;

            case '`':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8461 "grep_single_original.c" 3 4
             ((void *)0)
# 8461 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (begbuf); zzz } while (0);
              break;

            case '\'':
       if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
  goto normal_char;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8467 "grep_single_original.c" 3 4
             ((void *)0)
# 8467 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (endbuf); zzz } while (0);
              break;

            case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
              if (syntax & ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                goto normal_char;

              c1 = c - '0';

              if (c1 > regnum)
                zzz return (free (compile_stack.stack), REG_ESUBREG);


              if (group_in_compile_stack (compile_stack, (regnum_t) c1))
                goto normal_char;

              laststart = b;
              zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (2)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8485 "grep_single_original.c" 3 4
             ((void *)0)
# 8485 "grep_single_original.c"
             ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (duplicate); zzz *b++ = (unsigned char) (c1); zzz } while (0);
              break;


            case '+':
            case '?':
              if (syntax & (((unsigned long int) 1) << 1))
                goto handle_plus;
              else
                goto normal_backslash;

            default:
            normal_backslash:



              c = zzz (translate ? (char) translate[(unsigned char) (c)] : (c));
              goto normal_char;
            }
          break;


 default:

 normal_char:

          if (!pending_exact


              || pending_exact + *pending_exact + 1 != b


       || *pending_exact == (1 << 8) - 1


              || *p == '*' || *p == '^'
       || ((syntax & (((unsigned long int) 1) << 1))
    ? *p == '\\' && (p[1] == '+' || p[1] == '?')
    : (*p == '+' || *p == '?'))
       || ((syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                  && ((syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        ? *p == '{'
                      : (p[0] == '\\' && p[1] == '{'))))
     {


              laststart = b;

       zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (2)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8533 "grep_single_original.c" 3 4
      ((void *)0)
# 8533 "grep_single_original.c"
      ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (exactn); zzz *b++ = (unsigned char) (0); zzz } while (0);
       pending_exact = b - 1;
            }

   zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8537 "grep_single_original.c" 3 4
  ((void *)0)
# 8537 "grep_single_original.c"
  ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (c); zzz } while (0);
          (*pending_exact)++;
   break;
        }
    }




  if (fixup_alt_jump)
    zzz store_op1 (jump_past_alt, fixup_alt_jump, (int) ((b) - (fixup_alt_jump) - 3));

  if (!(compile_stack.avail == 0))
    zzz return (free (compile_stack.stack), REG_EPAREN);



  if (syntax & ((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    zzz do { zzz zzz while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) zzz zzz do { zzz unsigned char *old_buffer = bufp->buffer; zzz if (bufp->allocated == (1L << 16)) zzz return REG_ESIZE; zzz bufp->allocated <<= 1; zzz if (bufp->allocated > (1L << 16)) zzz bufp->allocated = (1L << 16); zzz bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));zzz if (bufp->buffer == 
# 8555 "grep_single_original.c" 3 4
   ((void *)0)
# 8555 "grep_single_original.c"
   ) zzz return REG_ESPACE; zzz zzz if (old_buffer != bufp->buffer) zzz { zzz b = (b - old_buffer) + bufp->buffer; zzz begalt = (begalt - old_buffer) + bufp->buffer; zzz if (fixup_alt_jump) zzz fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;zzz if (laststart) zzz laststart = (laststart - old_buffer) + bufp->buffer; zzz if (pending_exact) zzz pending_exact = (pending_exact - old_buffer) + bufp->buffer; zzz } zzz } while (0); zzz *b++ = (unsigned char) (succeed); zzz } while (0);

  free (compile_stack.stack);


  bufp->used = b - bufp->buffer;
# 8611 "grep_single_original.c"
  return REG_NOERROR;
}





static void
store_op1 (op, loc, arg)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
{
  *loc = (unsigned char) op;
  zzz do { zzz (loc + 1)[0] = (arg) & 0377; zzz (loc + 1)[1] = (arg) >> 8; zzz } while (0);
}




static void
store_op2 (op, loc, arg1, arg2)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
{
  *loc = (unsigned char) op;
  zzz do { zzz (loc + 1)[0] = (arg1) & 0377; zzz (loc + 1)[1] = (arg1) >> 8; zzz } while (0);
  zzz do { zzz (loc + 3)[0] = (arg2) & 0377; zzz (loc + 3)[1] = (arg2) >> 8; zzz } while (0);
}





static void
insert_op1 (op, loc, arg, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
    unsigned char *end;
{
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 3;

  while (pfrom != loc)
    *--pto = *--pfrom;

  store_op1 (op, loc, arg);
}




static void
insert_op2 (op, loc, arg1, arg2, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
    unsigned char *end;
{
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 5;

  while (pfrom != loc)
    *--pto = *--pfrom;

  store_op2 (op, loc, arg1, arg2);
}






static boolean
at_begline_loc_p (pattern, p, syntax)
    const char *pattern, *p;
    reg_syntax_t syntax;
{
  const char *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';

  return

       (*prev == '(' && (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || prev_prev_backslash))

    || (*prev == '|' && (syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || prev_prev_backslash));
}





static boolean
at_endline_loc_p (p, pend, syntax)
    const char *p, *pend;
    reg_syntax_t syntax;
{
  const char *next = p;
  boolean next_backslash = *next == '\\';
  const char *next_next = p + 1 < pend ? p + 1 : 0;

  return

       (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? *next == ')'
        : next_backslash && next_next && *next_next == ')')

    || (syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? *next == '|'
        : next_backslash && next_next && *next_next == '|');
}





static boolean
group_in_compile_stack (compile_stack, regnum)
    compile_stack_type compile_stack;
    regnum_t regnum;
{
  int this_element;

  for (this_element = compile_stack.avail - 1;
       this_element >= 0;
       this_element--)
    if (compile_stack.stack[this_element].regnum == regnum)
      return 1;

  return 0;
}
# 8755 "grep_single_original.c"
static reg_errcode_t
compile_range (p_ptr, pend, translate, syntax, b)
    const char **p_ptr, *pend;
    char * translate;
    reg_syntax_t syntax;
    unsigned char *b;
{
  unsigned this_char;

  const char *p = *p_ptr;
  unsigned int range_start, range_end;

  if (p == pend)
    return REG_ERANGE;
# 8778 "grep_single_original.c"
  range_start = ((const unsigned char *) p)[-2];
  range_end = ((const unsigned char *) p)[0];



  (*p_ptr)++;


  if (range_start > range_end)
    return syntax & ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? REG_ERANGE : REG_NOERROR;





  for (this_char = range_start; this_char <= range_end; this_char++)
    {
      zzz (b[((unsigned char) (zzz (translate ? (char) translate[(unsigned char) (this_char)] : (this_char)))) / 8] zzz |= 1 << (((unsigned char) zzz (translate ? (char) translate[(unsigned char) (this_char)] : (this_char))) % 8));
    }

  return REG_NOERROR;
}
# 8814 "grep_single_original.c"
int
re_compile_fastmap (bufp)
     struct re_pattern_buffer *bufp;
{
  int j, k;

  fail_stack_type fail_stack;


  char *destination;


  register char *fastmap = bufp->fastmap;
  unsigned char *pattern = bufp->buffer;
  unsigned char *p = pattern;
  register unsigned char *pend = pattern + bufp->used;
# 8841 "grep_single_original.c"
  boolean path_can_be_null = 1;


  boolean succeed_n_p = 0;

  ;

  zzz do { zzz fail_stack.stack = (fail_stack_elt_t *) zzz 
# 8848 "grep_single_original.c" 3 4
 __builtin_alloca (
# 8848 "grep_single_original.c"
 5 * sizeof (fail_stack_elt_t)
# 8848 "grep_single_original.c" 3 4
 )
# 8848 "grep_single_original.c"
 ; zzz zzz if (fail_stack.stack == 
# 8848 "grep_single_original.c" 3 4
 ((void *)0)
# 8848 "grep_single_original.c"
 ) zzz return -2; zzz zzz fail_stack.size = 5; zzz fail_stack.avail = 0; zzz } while (0);
  (memset (fastmap, '\0', 1 << 8), (fastmap));
  bufp->fastmap_accurate = 1;
  bufp->can_be_null = 0;

  while (1)
    {
      if (p == pend || *p == succeed)
 {

   if (!(fail_stack.avail == 0))
     {
       bufp->can_be_null |= path_can_be_null;


       path_can_be_null = 1;

       p = fail_stack.stack[--fail_stack.avail].pointer;

       continue;
     }
   else
     break;
 }


      ;

      switch (((re_opcode_t) *p++))
 {






 case duplicate:
   bufp->can_be_null = 1;
          goto done;





 case exactn:
          fastmap[p[1]] = 1;
   break;


        case charset:
          for (j = *p++ * 8 - 1; j >= 0; j--)
     if (p[j / 8] & (1 << (j % 8)))
              fastmap[j] = 1;
   break;


 case charset_not:

   for (j = *p * 8; j < (1 << 8); j++)
            fastmap[j] = 1;

   for (j = *p++ * 8 - 1; j >= 0; j--)
     if (!(p[j / 8] & (1 << (j % 8))))
              fastmap[j] = 1;
          break;


 case wordchar:
   for (j = 0; j < (1 << 8); j++)
     if (re_syntax_table[((j) & 0xFF)] == 1)
       fastmap[j] = 1;
   break;


 case notwordchar:
   for (j = 0; j < (1 << 8); j++)
     if (re_syntax_table[((j) & 0xFF)] != 1)
       fastmap[j] = 1;
   break;


        case anychar:
   {
     int fastmap_newline = fastmap['\n'];


     for (j = 0; j < (1 << 8); j++)
       fastmap[j] = 1;


     if (!(bufp->syntax & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)))
       fastmap['\n'] = fastmap_newline;



     else if (bufp->can_be_null)
       goto done;


     break;
   }
# 8978 "grep_single_original.c"
        case no_op:
        case begline:
        case endline:
 case begbuf:
 case endbuf:
 case wordbound:
 case notwordbound:
 case wordbeg:
 case wordend:
        case push_dummy_failure:
          continue;


 case jump_n:
        case pop_failure_jump:
 case maybe_pop_jump:
 case jump:
        case jump_past_alt:
 case dummy_failure_jump:
          zzz do { zzz zzz do { zzz (j) = *(p) & 0377; zzz (j) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
   p += j;
   if (j > 0)
     continue;






          if ((re_opcode_t) *p != on_failure_jump
       && (re_opcode_t) *p != succeed_n)
     continue;

          p++;
          zzz do { zzz zzz do { zzz (j) = *(p) & 0377; zzz (j) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
          p += j;


          if (!(fail_stack.avail == 0)
       && fail_stack.stack[fail_stack.avail - 1].pointer == p)
            fail_stack.avail--;

          continue;


        case on_failure_jump:
        case on_failure_keep_string_jump:
 handle_on_failure_jump:
          zzz do { zzz zzz do { zzz (j) = *(p) & 0377; zzz (j) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
# 9035 "grep_single_original.c"
          if (p + j < pend)
            {
              if (!zzz (((fail_stack.avail == fail_stack.size) zzz && !zzz ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) zzz ? 0 zzz : ((fail_stack).stack = (fail_stack_elt_t *) zzz zzz zzz (destination = (char *) 
# 9037 "grep_single_original.c" 3 4
                  __builtin_alloca (
# 9037 "grep_single_original.c"
                  zzz ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)
# 9037 "grep_single_original.c" 3 4
                  )
# 9037 "grep_single_original.c"
                  , zzz memcpy (destination, (fail_stack).stack, zzz (fail_stack).size * sizeof (fail_stack_elt_t))), zzz zzz (fail_stack).stack == 
# 9037 "grep_single_original.c" 3 4
                  ((void *)0) 
# 9037 "grep_single_original.c"
                  zzz ? 0 zzz : ((fail_stack).size <<= 1, zzz 1)))) zzz ? 0 zzz : ((fail_stack).stack[(fail_stack).avail++].pointer = p + j, zzz 1)))
  {
    ;
    return -2;
  }
            }
          else
            bufp->can_be_null = 1;

          if (succeed_n_p)
            {
              zzz do { zzz zzz do { zzz (k) = *(p) & 0377; zzz (k) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
              succeed_n_p = 0;
     }

          continue;


 case succeed_n:

          p += 2;


          zzz do { zzz zzz do { zzz (k) = *(p) & 0377; zzz (k) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
          if (k == 0)
     {
              p -= 4;
         succeed_n_p = 1;
              goto handle_on_failure_jump;
            }
          continue;


 case set_number_at:
          p += 4;
          continue;


 case start_memory:
        case stop_memory:
   p += 2;
   continue;


 default:
          abort ();
        }







      path_can_be_null = 0;
      p = pend;
    }



  bufp->can_be_null |= path_can_be_null;

 done:
  ;
  return 0;
}
# 9120 "grep_single_original.c"
void
re_set_registers (bufp, regs, num_regs, starts, ends)
    struct re_pattern_buffer *bufp;
    struct re_registers *regs;
    unsigned num_regs;
    regoff_t *starts, *ends;
{
  if (num_regs)
    {
      bufp->regs_allocated = 1;
      regs->num_regs = num_regs;
      regs->start = starts;
      regs->end = ends;
    }
  else
    {
      bufp->regs_allocated = 0;
      regs->num_regs = 0;
      regs->start = regs->end = (regoff_t *) 0;
    }
}
# 9150 "grep_single_original.c"
int
re_search (bufp, string, size, startpos, range, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, startpos, range;
     struct re_registers *regs;
{
  return re_search_2 (bufp, 
# 9157 "grep_single_original.c" 3 4
                           ((void *)0)
# 9157 "grep_single_original.c"
                               , 0, string, size, startpos, range,
        regs, size);
}
# 9186 "grep_single_original.c"
int
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int startpos;
     int range;
     struct re_registers *regs;
     int stop;
{
  int val;
  register char *fastmap = bufp->fastmap;
  register char * translate = bufp->translate;
  int total_size = size1 + size2;
  int endpos = startpos + range;


  if (startpos < 0 || startpos > total_size)
    return -1;




  if (endpos < 0)
    range = 0 - startpos;
  else if (endpos > total_size)
    range = total_size - startpos;



  if (bufp->used > 0 && range > 0
      && ((re_opcode_t) bufp->buffer[0] == begbuf

   || ((re_opcode_t) bufp->buffer[0] == begline
       && !bufp->newline_anchor)))
    {
      if (startpos > 0)
 return -1;
      else
 range = 1;
    }
# 9240 "grep_single_original.c"
  if (fastmap && !bufp->fastmap_accurate)
    if (re_compile_fastmap (bufp) == -2)
      return -2;


  for (;;)
    {




      if (fastmap && startpos < total_size && !bufp->can_be_null)
 {
   if (range > 0)
     {
       register const char *d;
       register int lim = 0;
       int irange = range;

              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);

       d = (startpos >= size1 ? string2 - size1 : string1) + startpos;



       if (translate)
                while (range > lim
                       && !fastmap[(unsigned char)
       translate[(unsigned char) *d++]])
                  range--;
       else
                while (range > lim && !fastmap[(unsigned char) *d++])
                  range--;

       startpos += irange - range;
     }
   else
     {
       register char c = (size1 == 0 || startpos >= size1
                                 ? string2[startpos - size1]
                                 : string1[startpos]);

       if (!fastmap[(unsigned char) zzz (translate ? (char) translate[(unsigned char) (c)] : (c))])
  goto advance;
     }
 }


      if (range >= 0 && startpos == total_size && fastmap
          && !bufp->can_be_null)
 return -1;

      val = re_match_2_internal (bufp, string1, size1, string2, size2,
     startpos, regs, stop);






      if (val >= 0)
 return startpos;

      if (val == -2)
 return -2;

    advance:
      if (!range)
        break;
      else if (range > 0)
        {
          range--;
          startpos++;
        }
      else
        {
          range++;
          startpos--;
        }
    }
  return -1;
}
# 9411 "grep_single_original.c"
int
re_match (bufp, string, size, pos, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, pos;
     struct re_registers *regs;
{
  int result = re_match_2_internal (bufp, 
# 9418 "grep_single_original.c" 3 4
                                         ((void *)0)
# 9418 "grep_single_original.c"
                                             , 0, string, size,
        pos, regs, size);





  return result;
}





static boolean group_match_null_string_p (unsigned char **p, unsigned char *end, register_info_type *reg_info)

                                    ;
static boolean alt_match_null_string_p (unsigned char *p, unsigned char *end, register_info_type *reg_info)

                                    ;
static boolean common_op_match_null_string_p (unsigned char **p, unsigned char *end, register_info_type *reg_info)

                                    ;
static int bcmp_translate (const char *s1, const char *s2, int len, char *translate)
                                   ;
# 9457 "grep_single_original.c"
int
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
{
  int result = re_match_2_internal (bufp, string1, size1, string2, size2,
        pos, regs, stop);





  return result;
}






static int
re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
{

  int mcnt;
  unsigned char *p1;


  const char *end1, *end2;



  const char *end_match_1, *end_match_2;


  const char *d, *dend;


  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;



  unsigned char *just_past_start_mem = 0;


  char * translate = bufp->translate;
# 9525 "grep_single_original.c"
  fail_stack_type fail_stack;
# 9541 "grep_single_original.c"
  size_t num_regs = bufp->re_nsub + 1;


  active_reg_t lowest_active_reg = ((1 << 8) + 1);
  active_reg_t highest_active_reg = (1 << 8);
# 9555 "grep_single_original.c"
  const char **regstart, **regend;
# 9564 "grep_single_original.c"
  const char **old_regstart, **old_regend;
# 9574 "grep_single_original.c"
  register_info_type *reg_info;






  unsigned best_regs_set = 0;

  const char **best_regstart, **best_regend;
# 9594 "grep_single_original.c"
  const char *match_end = 
# 9594 "grep_single_original.c" 3 4
                         ((void *)0)
# 9594 "grep_single_original.c"
                             ;


  int set_regs_matched_done = 0;



  const char **reg_dummy;
  register_info_type *reg_info_dummy;







  ;

  zzz do { zzz fail_stack.stack = (fail_stack_elt_t *) zzz 
# 9612 "grep_single_original.c" 3 4
 __builtin_alloca (
# 9612 "grep_single_original.c"
 5 * sizeof (fail_stack_elt_t)
# 9612 "grep_single_original.c" 3 4
 )
# 9612 "grep_single_original.c"
 ; zzz zzz if (fail_stack.stack == 
# 9612 "grep_single_original.c" 3 4
 ((void *)0)
# 9612 "grep_single_original.c"
 ) zzz return -2; zzz zzz fail_stack.size = 5; zzz fail_stack.avail = 0; zzz } while (0);







  if (bufp->re_nsub)
    {
      regstart = ((const char * *) 
# 9622 "grep_single_original.c" 3 4
                __builtin_alloca (
# 9622 "grep_single_original.c"
                (num_regs) * sizeof (const char *)
# 9622 "grep_single_original.c" 3 4
                )
# 9622 "grep_single_original.c"
                );
      regend = ((const char * *) 
# 9623 "grep_single_original.c" 3 4
              __builtin_alloca (
# 9623 "grep_single_original.c"
              (num_regs) * sizeof (const char *)
# 9623 "grep_single_original.c" 3 4
              )
# 9623 "grep_single_original.c"
              );
      old_regstart = ((const char * *) 
# 9624 "grep_single_original.c" 3 4
                    __builtin_alloca (
# 9624 "grep_single_original.c"
                    (num_regs) * sizeof (const char *)
# 9624 "grep_single_original.c" 3 4
                    )
# 9624 "grep_single_original.c"
                    );
      old_regend = ((const char * *) 
# 9625 "grep_single_original.c" 3 4
                  __builtin_alloca (
# 9625 "grep_single_original.c"
                  (num_regs) * sizeof (const char *)
# 9625 "grep_single_original.c" 3 4
                  )
# 9625 "grep_single_original.c"
                  );
      best_regstart = ((const char * *) 
# 9626 "grep_single_original.c" 3 4
                     __builtin_alloca (
# 9626 "grep_single_original.c"
                     (num_regs) * sizeof (const char *)
# 9626 "grep_single_original.c" 3 4
                     )
# 9626 "grep_single_original.c"
                     );
      best_regend = ((const char * *) 
# 9627 "grep_single_original.c" 3 4
                   __builtin_alloca (
# 9627 "grep_single_original.c"
                   (num_regs) * sizeof (const char *)
# 9627 "grep_single_original.c" 3 4
                   )
# 9627 "grep_single_original.c"
                   );
      reg_info = ((register_info_type *) 
# 9628 "grep_single_original.c" 3 4
                __builtin_alloca (
# 9628 "grep_single_original.c"
                (num_regs) * sizeof (register_info_type)
# 9628 "grep_single_original.c" 3 4
                )
# 9628 "grep_single_original.c"
                );
      reg_dummy = ((const char * *) 
# 9629 "grep_single_original.c" 3 4
                 __builtin_alloca (
# 9629 "grep_single_original.c"
                 (num_regs) * sizeof (const char *)
# 9629 "grep_single_original.c" 3 4
                 )
# 9629 "grep_single_original.c"
                 );
      reg_info_dummy = ((register_info_type *) 
# 9630 "grep_single_original.c" 3 4
                      __builtin_alloca (
# 9630 "grep_single_original.c"
                      (num_regs) * sizeof (register_info_type)
# 9630 "grep_single_original.c" 3 4
                      )
# 9630 "grep_single_original.c"
                      );

      if (!(regstart && regend && old_regstart && old_regend && reg_info
            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
        {
          zzz do { zzz ; zzz if (regstart) ((void)0); regstart = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (regend) ((void)0); regend = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (old_regstart) ((void)0); old_regstart = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (old_regend) ((void)0); old_regend = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (best_regstart) ((void)0); best_regstart = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (best_regend) ((void)0); best_regend = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (reg_info) ((void)0); reg_info = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (reg_dummy) ((void)0); reg_dummy = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz if (reg_info_dummy) ((void)0); reg_info_dummy = 
# 9635 "grep_single_original.c" 3 4
         ((void *)0)
# 9635 "grep_single_original.c"
         ; zzz } while (0);
          return -2;
        }
    }
  else
    {


      regstart = regend = old_regstart = old_regend = best_regstart
        = best_regend = reg_dummy = 
# 9644 "grep_single_original.c" 3 4
                                   ((void *)0)
# 9644 "grep_single_original.c"
                                       ;
      reg_info = reg_info_dummy = (register_info_type *) 
# 9645 "grep_single_original.c" 3 4
                                                        ((void *)0)
# 9645 "grep_single_original.c"
                                                            ;
    }



  if (pos < 0 || pos > size1 + size2)
    {
      zzz do { zzz ; zzz if (regstart) ((void)0); regstart = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (regend) ((void)0); regend = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (old_regstart) ((void)0); old_regstart = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (old_regend) ((void)0); old_regend = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (best_regstart) ((void)0); best_regstart = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (best_regend) ((void)0); best_regend = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (reg_info) ((void)0); reg_info = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (reg_dummy) ((void)0); reg_dummy = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz if (reg_info_dummy) ((void)0); reg_info_dummy = 
# 9652 "grep_single_original.c" 3 4
     ((void *)0)
# 9652 "grep_single_original.c"
     ; zzz } while (0);
      return -1;
    }




  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
    {
      regstart[mcnt] = regend[mcnt]
        = old_regstart[mcnt] = old_regend[mcnt] = (&reg_unset_dummy);

      ((reg_info[mcnt]).bits.match_null_string_p) = 3;
      ((reg_info[mcnt]).bits.is_active) = 0;
      ((reg_info[mcnt]).bits.matched_something) = 0;
      ((reg_info[mcnt]).bits.ever_matched_something) = 0;
    }



  if (size2 == 0 && string1 != 
# 9672 "grep_single_original.c" 3 4
                              ((void *)0)
# 9672 "grep_single_original.c"
                                  )
    {
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
    }
  end1 = string1 + size1;
  end2 = string2 + size2;


  if (stop <= size1)
    {
      end_match_1 = string1 + stop;
      end_match_2 = string2;
    }
  else
    {
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
    }







  if (size1 > 0 && pos <= size1)
    {
      d = string1 + pos;
      dend = end_match_1;
    }
  else
    {
      d = string2 + pos - size1;
      dend = end_match_2;
    }

  ;
  ;
  ;
  ;
  ;




  for (;;)
    {



      ;


      if (p == pend)
 {
          ;



          if (d != end_match_2)
     {


       boolean same_str_p = (zzz (size1 && string1 <= (match_end) && (match_end) <= string1 + size1)
        == (dend == end_match_1));

       boolean best_match_p;



       if (same_str_p)
  best_match_p = d > match_end;
       else
  best_match_p = !(dend == end_match_1);

              ;

              if (!(fail_stack.avail == 0))
                {


                  if (!best_regs_set || best_match_p)
                    {
                      best_regs_set = 1;
                      match_end = d;

                      ;

                      for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
                        {
                          best_regstart[mcnt] = regstart[mcnt];
                          best_regend[mcnt] = regend[mcnt];
                        }
                    }
                  goto fail;
                }




              else if (best_regs_set && !best_match_p)
                {
           restore_best_regs:





                  ;

                  d = match_end;
                  dend = ((d >= string1 && d <= end1)
             ? end_match_1 : end_match_2);

    for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
      {
        regstart[mcnt] = best_regstart[mcnt];
        regend[mcnt] = best_regend[mcnt];
      }
                }
            }

 succeed_label:
          ;


          if (regs && !bufp->no_sub)
     {

              if (bufp->regs_allocated == 0)
                {


                  regs->num_regs = ((30) > (num_regs + 1) ? (30) : (num_regs + 1));
                  regs->start = ((regoff_t *) xmalloc ((regs->num_regs) * sizeof (regoff_t)));
                  regs->end = ((regoff_t *) xmalloc ((regs->num_regs) * sizeof (regoff_t)));
                  if (regs->start == 
# 9811 "grep_single_original.c" 3 4
                                    ((void *)0) 
# 9811 "grep_single_original.c"
                                         || regs->end == 
# 9811 "grep_single_original.c" 3 4
                                                         ((void *)0)
# 9811 "grep_single_original.c"
                                                             )
      {
        zzz do { zzz ; zzz if (regstart) ((void)0); regstart = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (regend) ((void)0); regend = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (old_regstart) ((void)0); old_regstart = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (old_regend) ((void)0); old_regend = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (best_regstart) ((void)0); best_regstart = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (best_regend) ((void)0); best_regend = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (reg_info) ((void)0); reg_info = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (reg_dummy) ((void)0); reg_dummy = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz if (reg_info_dummy) ((void)0); reg_info_dummy = 
# 9813 "grep_single_original.c" 3 4
       ((void *)0)
# 9813 "grep_single_original.c"
       ; zzz } while (0);
        return -2;
      }
                  bufp->regs_allocated = 1;
                }
              else if (bufp->regs_allocated == 1)
                {


                  if (regs->num_regs < num_regs + 1)
                    {
                      regs->num_regs = num_regs + 1;
                      ((regs->start) = (regoff_t *) realloc (regs->start, (regs->num_regs) * sizeof (regoff_t)));
                      ((regs->end) = (regoff_t *) realloc (regs->end, (regs->num_regs) * sizeof (regoff_t)));
                      if (regs->start == 
# 9827 "grep_single_original.c" 3 4
                                        ((void *)0) 
# 9827 "grep_single_original.c"
                                             || regs->end == 
# 9827 "grep_single_original.c" 3 4
                                                             ((void *)0)
# 9827 "grep_single_original.c"
                                                                 )
   {
     zzz do { zzz ; zzz if (regstart) ((void)0); regstart = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (regend) ((void)0); regend = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (old_regstart) ((void)0); old_regstart = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (old_regend) ((void)0); old_regend = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (best_regstart) ((void)0); best_regstart = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (best_regend) ((void)0); best_regend = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (reg_info) ((void)0); reg_info = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (reg_dummy) ((void)0); reg_dummy = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz if (reg_info_dummy) ((void)0); reg_info_dummy = 
# 9829 "grep_single_original.c" 3 4
    ((void *)0)
# 9829 "grep_single_original.c"
    ; zzz } while (0);
     return -2;
   }
                    }
                }
              else
  {


    ;
  }




              if (regs->num_regs > 0)
                {
                  regs->start[0] = pos;
                  regs->end[0] = ((dend == end_match_1)
      ? ((regoff_t) (d - string1))
             : ((regoff_t) (d - string2 + size1)));
                }



       for (mcnt = 1; (unsigned) mcnt < ((num_regs) < (regs->num_regs) ? (num_regs) : (regs->num_regs));
     mcnt++)
  {
                  if (((regstart[mcnt]) == (&reg_unset_dummy)) || ((regend[mcnt]) == (&reg_unset_dummy)))
                    regs->start[mcnt] = regs->end[mcnt] = -1;
                  else
                    {
        regs->start[mcnt]
   = (regoff_t) zzz (zzz (size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1) zzz ? ((regoff_t) ((regstart[mcnt]) - string1)) zzz : ((regoff_t) ((regstart[mcnt]) - string2 + size1)));
                      regs->end[mcnt]
   = (regoff_t) zzz (zzz (size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1) zzz ? ((regoff_t) ((regend[mcnt]) - string1)) zzz : ((regoff_t) ((regend[mcnt]) - string2 + size1)));
                    }
  }






              for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)
                regs->start[mcnt] = regs->end[mcnt] = -1;
     }

         

                                                                        ;
          ;

          mcnt = d - pos - ((dend == end_match_1)
       ? string1
       : string2 - size1);

          ;

          zzz do { zzz ; zzz if (regstart) ((void)0); regstart = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (regend) ((void)0); regend = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (old_regstart) ((void)0); old_regstart = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (old_regend) ((void)0); old_regend = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (best_regstart) ((void)0); best_regstart = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (best_regend) ((void)0); best_regend = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (reg_info) ((void)0); reg_info = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (reg_dummy) ((void)0); reg_dummy = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz if (reg_info_dummy) ((void)0); reg_info_dummy = 
# 9888 "grep_single_original.c" 3 4
         ((void *)0)
# 9888 "grep_single_original.c"
         ; zzz } while (0);
          return mcnt;
        }


      switch (((re_opcode_t) *p++))
 {


        case no_op:
          ;
          break;

 case succeed:
          ;
   goto succeed_label;




 case exactn:
   mcnt = *p++;
          ;



          if (translate)
     {
       do
  {
    zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };
    if ((unsigned char) translate[(unsigned char) *d++]
        != (unsigned char) *p++)
                    goto fail;
  }
       while (--mcnt);
     }
   else
     {
       do
  {
    zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };
    if (*d++ != (char) *p++) goto fail;
  }
       while (--mcnt);
     }
   zzz do zzz { zzz if (!set_regs_matched_done) zzz { zzz active_reg_t r; zzz set_regs_matched_done = 1; zzz for (r = lowest_active_reg; r <= highest_active_reg; r++) zzz { zzz ((reg_info[r]).bits.matched_something) zzz = ((reg_info[r]).bits.ever_matched_something) zzz = 1; zzz } zzz } zzz } zzz while (0);
          break;



 case anychar:
          ;

          zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };

          if ((!(bufp->syntax & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)) && zzz (translate ? (char) translate[(unsigned char) (*d)] : (*d)) == '\n')
              || (bufp->syntax & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && zzz (translate ? (char) translate[(unsigned char) (*d)] : (*d)) == '\000'))
     goto fail;

          zzz do zzz { zzz if (!set_regs_matched_done) zzz { zzz active_reg_t r; zzz set_regs_matched_done = 1; zzz for (r = lowest_active_reg; r <= highest_active_reg; r++) zzz { zzz ((reg_info[r]).bits.matched_something) zzz = ((reg_info[r]).bits.ever_matched_something) zzz = 1; zzz } zzz } zzz } zzz while (0);
          ;
          d++;
   break;


 case charset:
 case charset_not:
   {
     register unsigned char c;
     boolean not = (re_opcode_t) *(p - 1) == charset_not;

            ;

     zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };
     c = zzz (translate ? (char) translate[(unsigned char) (*d)] : (*d));



     if (c < (unsigned) (*p * 8)
  && p[1 + c / 8] & (1 << (c % 8)))
       not = !not;

     p += 1 + *p;

     if (!not) goto fail;

     zzz do zzz { zzz if (!set_regs_matched_done) zzz { zzz active_reg_t r; zzz set_regs_matched_done = 1; zzz for (r = lowest_active_reg; r <= highest_active_reg; r++) zzz { zzz ((reg_info[r]).bits.matched_something) zzz = ((reg_info[r]).bits.ever_matched_something) zzz = 1; zzz } zzz } zzz } zzz while (0);
            d++;
     break;
   }







        case start_memory:
   ;


   p1 = p;

          if (((reg_info[*p]).bits.match_null_string_p) == 3)
            ((reg_info[*p]).bits.match_null_string_p)
              = group_match_null_string_p (&p1, pend, reg_info);






          old_regstart[*p] = ((reg_info[*p]).bits.match_null_string_p)
                             ? ((regstart[*p]) == (&reg_unset_dummy)) ? d : regstart[*p]
                             : regstart[*p];
  
                                         ;

          regstart[*p] = d;
   ;

          ((reg_info[*p]).bits.is_active) = 1;
          ((reg_info[*p]).bits.matched_something) = 0;


   set_regs_matched_done = 0;


          highest_active_reg = *p;



          if (lowest_active_reg == ((1 << 8) + 1))
            lowest_active_reg = *p;


          p += 2;
   just_past_start_mem = p;

          break;





 case stop_memory:
   ;






          old_regend[*p] = ((reg_info[*p]).bits.match_null_string_p)
                           ? ((regend[*p]) == (&reg_unset_dummy)) ? d : regend[*p]
      : regend[*p];
  
                                       ;

          regend[*p] = d;
   ;


          ((reg_info[*p]).bits.is_active) = 0;


   set_regs_matched_done = 0;



          if (lowest_active_reg == highest_active_reg)
            {
              lowest_active_reg = ((1 << 8) + 1);
              highest_active_reg = (1 << 8);
            }
          else
            {



              unsigned char r = *p - 1;
              while (r > 0 && !((reg_info[r]).bits.is_active))
                r--;
# 10080 "grep_single_original.c"
       if (r == 0)
                {
                  lowest_active_reg = ((1 << 8) + 1);
                  highest_active_reg = (1 << 8);
                }
              else
                highest_active_reg = r;
            }






          if ((!((reg_info[*p]).bits.matched_something)
               || just_past_start_mem == p - 1)
       && (p + 2) < pend)
            {
              boolean is_a_jump_n = 0;

              p1 = p + 2;
              mcnt = 0;
              switch ((re_opcode_t) *p1++)
                {
                  case jump_n:
      is_a_jump_n = 1;
                  case pop_failure_jump:
    case maybe_pop_jump:
    case jump:
    case dummy_failure_jump:
                    zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
      if (is_a_jump_n)
        p1 += 2;
                    break;

                  default:
                                     ;
                }
       p1 += mcnt;






              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
  {
# 10138 "grep_single_original.c"
                  if (((reg_info[*p]).bits.ever_matched_something))
      {
        unsigned r;

                      ((reg_info[*p]).bits.ever_matched_something) = 0;


                      for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
      r++)
                        {
                          regstart[r] = old_regstart[r];


                          if (old_regend[r] >= regstart[r])
                            regend[r] = old_regend[r];
                        }
                    }
    p1++;
                  zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
                  zzz do { zzz char *destination; zzz zzz zzz active_reg_t this_reg; zzz zzz ; zzz ; zzz ; zzz ;zzz ;zzz zzz ; zzz ; zzz zzz zzz while (((fail_stack).size - (fail_stack).avail) < zzz (((0 zzz ? 0 : highest_active_reg - lowest_active_reg + 1) zzz * 3) zzz + 4)) zzz { zzz if (!zzz ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) zzz ? 0 zzz : ((fail_stack).stack = (fail_stack_elt_t *) zzz zzz zzz (destination = (char *) 
# 10157 "grep_single_original.c" 3 4
                 __builtin_alloca (
# 10157 "grep_single_original.c"
                 zzz ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)
# 10157 "grep_single_original.c" 3 4
                 )
# 10157 "grep_single_original.c"
                 , zzz memcpy (destination, (fail_stack).stack, zzz (fail_stack).size * sizeof (fail_stack_elt_t))), zzz zzz (fail_stack).stack == 
# 10157 "grep_single_original.c" 3 4
                 ((void *)0) 
# 10157 "grep_single_original.c"
                 zzz ? 0 zzz : ((fail_stack).size <<= 1, zzz 1)))) zzz return -2; zzz zzz ; zzz ;zzz } zzz zzz zzz ; zzz zzz if (1) zzz for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; zzz this_reg++) zzz { zzz ; zzz ; zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); zzz zzz ; zzz ; zzz ; zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); zzz } zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); zzz zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (p1 + mcnt); zzz zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (d); zzz zzz ; zzz ; zzz } while (0);

                  goto fail;
                }
            }


          p += 2;
          break;




        case duplicate:
   {
     register const char *d2, *dend2;
     int regno = *p++;
     ;


            if (((regstart[regno]) == (&reg_unset_dummy)) || ((regend[regno]) == (&reg_unset_dummy)))
              goto fail;


            d2 = regstart[regno];






            dend2 = ((zzz (size1 && string1 <= (regstart[regno]) && (regstart[regno]) <= string1 + size1)
        == zzz (size1 && string1 <= (regend[regno]) && (regend[regno]) <= string1 + size1))
       ? regend[regno] : end_match_1);
     for (;;)
       {


  while (d2 == dend2)
    {
      if (dend2 == end_match_2) break;
      if (dend2 == regend[regno]) break;


                    d2 = string2;
                    dend2 = regend[regno];
    }

  if (d2 == dend2) break;


  zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };


  mcnt = dend - d;



                if (mcnt > dend2 - d2)
    mcnt = dend2 - d2;



  if (translate
                    ? bcmp_translate (d, d2, mcnt, translate)
                    : memcmp (d, d2, mcnt))
    goto fail;
  d += mcnt, d2 += mcnt;


  zzz do zzz { zzz if (!set_regs_matched_done) zzz { zzz active_reg_t r; zzz set_regs_matched_done = 1; zzz for (r = lowest_active_reg; r <= highest_active_reg; r++) zzz { zzz ((reg_info[r]).bits.matched_something) zzz = ((reg_info[r]).bits.ever_matched_something) zzz = 1; zzz } zzz } zzz } zzz while (0);
       }
   }
   break;





 case begline:
          ;

          if (((d) == (size1 ? string1 : string2) || !size2))
            {
              if (!bufp->not_bol) break;
            }
          else if (d[-1] == '\n' && bufp->newline_anchor)
            {
              break;
            }

          goto fail;



 case endline:
          ;

          if (((d) == end2))
            {
              if (!bufp->not_eol) break;
            }


          else if ((d == end1 ? *string2 : *d) == '\n'
                   && bufp->newline_anchor)
            {
              break;
            }
          goto fail;



        case begbuf:
          ;
          if (((d) == (size1 ? string1 : string2) || !size2))
            break;
          goto fail;



        case endbuf:
          ;
   if (((d) == end2))
     break;
          goto fail;
# 10301 "grep_single_original.c"
        case on_failure_keep_string_jump:
          ;

          zzz do { zzz zzz do { zzz (mcnt) = *(p) & 0377; zzz (mcnt) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);



          ;


          zzz do { zzz char *destination; zzz zzz zzz active_reg_t this_reg; zzz zzz ; zzz ; zzz ; zzz ;zzz ;zzz zzz ; zzz ; zzz zzz zzz while (((fail_stack).size - (fail_stack).avail) < zzz (((0 zzz ? 0 : highest_active_reg - lowest_active_reg + 1) zzz * 3) zzz + 4)) zzz { zzz if (!zzz ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) zzz ? 0 zzz : ((fail_stack).stack = (fail_stack_elt_t *) zzz zzz zzz (destination = (char *) 
# 10311 "grep_single_original.c" 3 4
         __builtin_alloca (
# 10311 "grep_single_original.c"
         zzz ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)
# 10311 "grep_single_original.c" 3 4
         )
# 10311 "grep_single_original.c"
         , zzz memcpy (destination, (fail_stack).stack, zzz (fail_stack).size * sizeof (fail_stack_elt_t))), zzz zzz (fail_stack).stack == 
# 10311 "grep_single_original.c" 3 4
         ((void *)0) 
# 10311 "grep_single_original.c"
         zzz ? 0 zzz : ((fail_stack).size <<= 1, zzz 1)))) zzz return -2; zzz zzz ; zzz ;zzz } zzz zzz zzz ; zzz zzz if (1) zzz for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; zzz this_reg++) zzz { zzz ; zzz ; zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); zzz zzz ; zzz ; zzz ; zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); zzz } zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); zzz zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (p + mcnt); zzz zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (
# 10311 "grep_single_original.c" 3 4
         ((void *)0)
# 10311 "grep_single_original.c"
         ); zzz zzz ; zzz ; zzz } while (0);
          break;
# 10327 "grep_single_original.c"
 case on_failure_jump:
        on_failure:
          ;

          zzz do { zzz zzz do { zzz (mcnt) = *(p) & 0377; zzz (mcnt) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);



          ;
# 10347 "grep_single_original.c"
          p1 = p;





          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;

          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
            {




              highest_active_reg = *(p1 + 1) + *(p1 + 2);
              if (lowest_active_reg == ((1 << 8) + 1))
                lowest_active_reg = *(p1 + 1);
            }

          ;
          zzz do { zzz char *destination; zzz zzz zzz active_reg_t this_reg; zzz zzz ; zzz ; zzz ; zzz ;zzz ;zzz zzz ; zzz ; zzz zzz zzz while (((fail_stack).size - (fail_stack).avail) < zzz (((0 zzz ? 0 : highest_active_reg - lowest_active_reg + 1) zzz * 3) zzz + 4)) zzz { zzz if (!zzz ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) zzz ? 0 zzz : ((fail_stack).stack = (fail_stack_elt_t *) zzz zzz zzz (destination = (char *) 
# 10368 "grep_single_original.c" 3 4
         __builtin_alloca (
# 10368 "grep_single_original.c"
         zzz ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)
# 10368 "grep_single_original.c" 3 4
         )
# 10368 "grep_single_original.c"
         , zzz memcpy (destination, (fail_stack).stack, zzz (fail_stack).size * sizeof (fail_stack_elt_t))), zzz zzz (fail_stack).stack == 
# 10368 "grep_single_original.c" 3 4
         ((void *)0) 
# 10368 "grep_single_original.c"
         zzz ? 0 zzz : ((fail_stack).size <<= 1, zzz 1)))) zzz return -2; zzz zzz ; zzz ;zzz } zzz zzz zzz ; zzz zzz if (1) zzz for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; zzz this_reg++) zzz { zzz ; zzz ; zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); zzz zzz ; zzz ; zzz ; zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); zzz } zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); zzz zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (p + mcnt); zzz zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (d); zzz zzz ; zzz ; zzz } while (0);
          break;




        case maybe_pop_jump:
          zzz do { zzz zzz do { zzz (mcnt) = *(p) & 0377; zzz (mcnt) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
          ;
          {
     register unsigned char *p2 = p;
# 10397 "grep_single_original.c"
     while (1)
       {
  if (p2 + 2 < pend
      && ((re_opcode_t) *p2 == stop_memory
   || (re_opcode_t) *p2 == start_memory))
    p2 += 3;
  else if (p2 + 6 < pend
    && (re_opcode_t) *p2 == dummy_failure_jump)
    p2 += 6;
  else
    break;
       }

     p1 = p + mcnt;





            if (p2 == pend)
       {



           p[-3] = (unsigned char) pop_failure_jump;
               
                                                                       ;
              }

            else if ((re_opcode_t) *p2 == exactn
       || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
       {
  register unsigned char c
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];

                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
                  {
        p[-3] = (unsigned char) pop_failure_jump;
                   
                                           ;
                  }

  else if ((re_opcode_t) p1[3] == charset
    || (re_opcode_t) p1[3] == charset_not)
    {
      int not = (re_opcode_t) p1[3] == charset_not;

      if (c < (unsigned char) (p1[4] * 8)
   && p1[5 + c / 8] & (1 << (c % 8)))
        not = !not;



      if (!not)
                      {
            p[-3] = (unsigned char) pop_failure_jump;
                        ;
                      }
    }
       }
            else if ((re_opcode_t) *p2 == charset)
       {


                if ((re_opcode_t) p1[3] == exactn
      && ! ((int) p2[1] * 8 > (int) p1[5]
     && (p2[2 + p1[5] / 8]
         & (1 << (p1[5] % 8)))))
                  {
        p[-3] = (unsigned char) pop_failure_jump;
      ;
                  }

  else if ((re_opcode_t) p1[3] == charset_not)
    {
      int idx;


      for (idx = 0; idx < (int) p2[1]; idx++)
        if (! (p2[2 + idx] == 0
        || (idx < (int) p1[4]
     && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))
   break;

      if (idx == p2[1])
                      {
            p[-3] = (unsigned char) pop_failure_jump;
                        ;
                      }
    }
  else if ((re_opcode_t) p1[3] == charset)
    {
      int idx;


      for (idx = 0;
    idx < (int) p2[1] && idx < (int) p1[4];
    idx++)
        if ((p2[2 + idx] & p1[5 + idx]) != 0)
   break;

      if (idx == p2[1] || idx == p1[4])
                      {
            p[-3] = (unsigned char) pop_failure_jump;
                        ;
                      }
    }
       }
   }
   p -= 2;
   if ((re_opcode_t) p[-1] != pop_failure_jump)
     {
       p[-1] = (unsigned char) jump;
              ;
       goto unconditional_jump;
     }
# 10522 "grep_single_original.c"
        case pop_failure_jump:
          {





            active_reg_t dummy_low_reg, dummy_high_reg;
            unsigned char *pdummy;
            const char *sdummy;

            ;
            zzz{ zzz zzz active_reg_t this_reg; zzz const unsigned char *string_temp; zzz zzz ; zzz zzz zzz ; zzz ; zzz ; zzz zzz ; zzz zzz ; zzz ; zzz zzz zzz string_temp = fail_stack.stack[--fail_stack.avail].pointer; zzz if (string_temp != 
# 10534 "grep_single_original.c" 3 4
           ((void *)0)
# 10534 "grep_single_original.c"
           ) zzz sdummy = (const char *) string_temp; zzz zzz ; zzz ; zzz ; zzz zzz pdummy = (unsigned char *) fail_stack.stack[--fail_stack.avail].pointer; zzz ; zzz ; zzz zzz zzz dummy_high_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; zzz ; zzz zzz dummy_low_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; zzz ; zzz zzz if (1) zzz for (this_reg = dummy_high_reg; this_reg >= dummy_low_reg; this_reg--) zzz { zzz ; zzz zzz reg_info_dummy[this_reg].word = fail_stack.stack[--fail_stack.avail]; zzz ; zzz zzz reg_dummy[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; zzz ; zzz zzz reg_dummy[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; zzz ; zzz } zzz else zzz { zzz for (this_reg = highest_active_reg; this_reg > dummy_high_reg; this_reg--) zzz { zzz reg_info_dummy[this_reg].word.integer = 0; zzz reg_dummy[this_reg] = 0; zzz reg_dummy[this_reg] = 0; zzz } zzz highest_active_reg = dummy_high_reg; zzz } zzz zzz set_regs_matched_done = 0; zzz ; zzz}

                                                                    ;
          }


 unconditional_jump:



   ;




        case jump:
   zzz do { zzz zzz do { zzz (mcnt) = *(p) & 0377; zzz (mcnt) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
          ;
   p += mcnt;



          ;

   break;




        case jump_past_alt:
          ;
          goto unconditional_jump;







        case dummy_failure_jump:
          ;


          zzz do { zzz char *destination; zzz zzz zzz active_reg_t this_reg; zzz zzz ; zzz ; zzz ; zzz ;zzz ;zzz zzz ; zzz ; zzz zzz zzz while (((fail_stack).size - (fail_stack).avail) < zzz (((0 zzz ? 0 : highest_active_reg - lowest_active_reg + 1) zzz * 3) zzz + 4)) zzz { zzz if (!zzz ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) zzz ? 0 zzz : ((fail_stack).stack = (fail_stack_elt_t *) zzz zzz zzz (destination = (char *) 
# 10577 "grep_single_original.c" 3 4
         __builtin_alloca (
# 10577 "grep_single_original.c"
         zzz ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)
# 10577 "grep_single_original.c" 3 4
         )
# 10577 "grep_single_original.c"
         , zzz memcpy (destination, (fail_stack).stack, zzz (fail_stack).size * sizeof (fail_stack_elt_t))), zzz zzz (fail_stack).stack == 
# 10577 "grep_single_original.c" 3 4
         ((void *)0) 
# 10577 "grep_single_original.c"
         zzz ? 0 zzz : ((fail_stack).size <<= 1, zzz 1)))) zzz return -2; zzz zzz ; zzz ;zzz } zzz zzz zzz ; zzz zzz if (1) zzz for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; zzz this_reg++) zzz { zzz ; zzz ; zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); zzz zzz ; zzz ; zzz ; zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); zzz } zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); zzz zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (
# 10577 "grep_single_original.c" 3 4
         ((void *)0)
# 10577 "grep_single_original.c"
         ); zzz zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (
# 10577 "grep_single_original.c" 3 4
         ((void *)0)
# 10577 "grep_single_original.c"
         ); zzz zzz ; zzz ; zzz } while (0);
          goto unconditional_jump;







        case push_dummy_failure:
          ;


          zzz do { zzz char *destination; zzz zzz zzz active_reg_t this_reg; zzz zzz ; zzz ; zzz ; zzz ;zzz ;zzz zzz ; zzz ; zzz zzz zzz while (((fail_stack).size - (fail_stack).avail) < zzz (((0 zzz ? 0 : highest_active_reg - lowest_active_reg + 1) zzz * 3) zzz + 4)) zzz { zzz if (!zzz ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) zzz ? 0 zzz : ((fail_stack).stack = (fail_stack_elt_t *) zzz zzz zzz (destination = (char *) 
# 10590 "grep_single_original.c" 3 4
         __builtin_alloca (
# 10590 "grep_single_original.c"
         zzz ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)
# 10590 "grep_single_original.c" 3 4
         )
# 10590 "grep_single_original.c"
         , zzz memcpy (destination, (fail_stack).stack, zzz (fail_stack).size * sizeof (fail_stack_elt_t))), zzz zzz (fail_stack).stack == 
# 10590 "grep_single_original.c" 3 4
         ((void *)0) 
# 10590 "grep_single_original.c"
         zzz ? 0 zzz : ((fail_stack).size <<= 1, zzz 1)))) zzz return -2; zzz zzz ; zzz ;zzz } zzz zzz zzz ; zzz zzz if (1) zzz for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; zzz this_reg++) zzz { zzz ; zzz ; zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); zzz zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); zzz zzz ; zzz ; zzz ; zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); zzz } zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); zzz zzz ;zzz zzz fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); zzz zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (
# 10590 "grep_single_original.c" 3 4
         ((void *)0)
# 10590 "grep_single_original.c"
         ); zzz zzz ; zzz ; zzz ; zzz zzz fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (
# 10590 "grep_single_original.c" 3 4
         ((void *)0)
# 10590 "grep_single_original.c"
         ); zzz zzz ; zzz ; zzz } while (0);
          break;



        case succeed_n:
          zzz do { zzz (mcnt) = *(p + 2) & 0377; zzz (mcnt) += ((signed char) (*((p + 2) + 1))) << 8; zzz } while (0);
          ;

          ;

          if (mcnt > 0)
            {
               mcnt--;
        p += 2;
               zzz do { zzz zzz do { zzz (p)[0] = (mcnt) & 0377; zzz (p)[1] = (mcnt) >> 8; zzz } while (0); zzz (p) += 2; zzz } while (0);



               ;

            }
   else if (mcnt == 0)
            {



              ;

       p[2] = (unsigned char) no_op;
              p[3] = (unsigned char) no_op;
              goto on_failure;
            }
          break;

        case jump_n:
          zzz do { zzz (mcnt) = *(p + 2) & 0377; zzz (mcnt) += ((signed char) (*((p + 2) + 1))) << 8; zzz } while (0);
          ;


          if (mcnt)
            {
               mcnt--;
               zzz do { zzz (p + 2)[0] = (mcnt) & 0377; zzz (p + 2)[1] = (mcnt) >> 8; zzz } while (0);



               ;

        goto unconditional_jump;
            }

   else
     p += 4;
          break;

 case set_number_at:
   {
            ;

            zzz do { zzz zzz do { zzz (mcnt) = *(p) & 0377; zzz (mcnt) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);
            p1 = p + mcnt;
            zzz do { zzz zzz do { zzz (mcnt) = *(p) & 0377; zzz (mcnt) += ((signed char) (*((p) + 1))) << 8; zzz } while (0); zzz (p) += 2; zzz } while (0);



            ;

     zzz do { zzz (p1)[0] = (mcnt) & 0377; zzz (p1)[1] = (mcnt) >> 8; zzz } while (0);
            break;
          }
# 10680 "grep_single_original.c"
 case wordbound:
 {
   boolean prevchar, thischar;

   ;
   if (((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2))
     break;

   prevchar = zzz (re_syntax_table[(((d - 1) == end1 ? *string2 zzz : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] zzz == 1);
   thischar = zzz (re_syntax_table[(((d) == end1 ? *string2 zzz : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] zzz == 1);
   if (prevchar != thischar)
     break;
   goto fail;
 }

      case notwordbound:
 {
   boolean prevchar, thischar;

   ;
   if (((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2))
     goto fail;

   prevchar = zzz (re_syntax_table[(((d - 1) == end1 ? *string2 zzz : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] zzz == 1);
   thischar = zzz (re_syntax_table[(((d) == end1 ? *string2 zzz : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] zzz == 1);
   if (prevchar != thischar)
     goto fail;
   break;
 }


 case wordbeg:
          ;
   if (zzz (re_syntax_table[(((d) == end1 ? *string2 zzz : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] zzz == 1) && (((d) == (size1 ? string1 : string2) || !size2) || !zzz (re_syntax_table[(((d - 1) == end1 ? *string2 zzz : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] zzz == 1)))
     break;
          goto fail;

 case wordend:
          ;
   if (!((d) == (size1 ? string1 : string2) || !size2) && zzz (re_syntax_table[(((d - 1) == end1 ? *string2 zzz : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] zzz == 1)
              && (!zzz (re_syntax_table[(((d) == end1 ? *string2 zzz : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] zzz == 1) || ((d) == end2)))
     break;
          goto fail;
# 10778 "grep_single_original.c"
 case wordchar:
          ;
   zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };
          if (!zzz (re_syntax_table[(((d) == end1 ? *string2 zzz : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] zzz == 1))
            goto fail;
   zzz do zzz { zzz if (!set_regs_matched_done) zzz { zzz active_reg_t r; zzz set_regs_matched_done = 1; zzz for (r = lowest_active_reg; r <= highest_active_reg; r++) zzz { zzz ((reg_info[r]).bits.matched_something) zzz = ((reg_info[r]).bits.ever_matched_something) zzz = 1; zzz } zzz } zzz } zzz while (0);
          d++;
   break;

 case notwordchar:
          ;
   zzz while (d == dend) zzz { zzz zzz if (dend == end_match_2) zzz goto fail; zzz zzz d = string2; zzz dend = end_match_2; zzz };
   if (zzz (re_syntax_table[(((d) == end1 ? *string2 zzz : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] zzz == 1))
            goto fail;
          zzz do zzz { zzz if (!set_regs_matched_done) zzz { zzz active_reg_t r; zzz set_regs_matched_done = 1; zzz for (r = lowest_active_reg; r <= highest_active_reg; r++) zzz { zzz ((reg_info[r]).bits.matched_something) zzz = ((reg_info[r]).bits.ever_matched_something) zzz = 1; zzz } zzz } zzz } zzz while (0);
          d++;
   break;


        default:
          abort ();
 }
      continue;



    fail:
      if (!(fail_stack.avail == 0))
 {
          ;
          zzz{ zzz zzz active_reg_t this_reg; zzz const unsigned char *string_temp; zzz zzz ; zzz zzz zzz ; zzz ; zzz ; zzz zzz ; zzz zzz ; zzz ; zzz zzz zzz string_temp = fail_stack.stack[--fail_stack.avail].pointer; zzz if (string_temp != 
# 10808 "grep_single_original.c" 3 4
         ((void *)0)
# 10808 "grep_single_original.c"
         ) zzz d = (const char *) string_temp; zzz zzz ; zzz ; zzz ; zzz zzz p = (unsigned char *) fail_stack.stack[--fail_stack.avail].pointer; zzz ; zzz ; zzz zzz zzz highest_active_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; zzz ; zzz zzz lowest_active_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; zzz ; zzz zzz if (1) zzz for (this_reg = highest_active_reg; this_reg >= lowest_active_reg; this_reg--) zzz { zzz ; zzz zzz reg_info[this_reg].word = fail_stack.stack[--fail_stack.avail]; zzz ; zzz zzz regend[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; zzz ; zzz zzz regstart[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; zzz ; zzz } zzz else zzz { zzz for (this_reg = highest_active_reg; this_reg > highest_active_reg; this_reg--) zzz { zzz reg_info[this_reg].word.integer = 0; zzz regend[this_reg] = 0; zzz regstart[this_reg] = 0; zzz } zzz highest_active_reg = highest_active_reg; zzz } zzz zzz set_regs_matched_done = 0; zzz ; zzz}

                                                        ;


          if (!p)
     goto fail;


   ;
          if (p < pend)
            {
              boolean is_a_jump_n = 0;



              switch ((re_opcode_t) *p)
                {
                case jump_n:
                  is_a_jump_n = 1;
                case maybe_pop_jump:
                case pop_failure_jump:
                case jump:
                  p1 = p + 1;
                  zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
                  p1 += mcnt;

                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                      || (!is_a_jump_n
                          && (re_opcode_t) *p1 == on_failure_jump))
                    goto fail;
                  break;
                default:
                                   ;
                }
            }

          if (d >= string1 && d <= end1)
     dend = end_match_1;
        }
      else
        break;
    }

  if (best_regs_set)
    goto restore_best_regs;

  zzz do { zzz ; zzz if (regstart) ((void)0); regstart = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (regend) ((void)0); regend = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (old_regstart) ((void)0); old_regstart = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (old_regend) ((void)0); old_regend = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (best_regstart) ((void)0); best_regstart = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (best_regend) ((void)0); best_regend = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (reg_info) ((void)0); reg_info = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (reg_dummy) ((void)0); reg_dummy = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz if (reg_info_dummy) ((void)0); reg_info_dummy = 
# 10855 "grep_single_original.c" 3 4
 ((void *)0)
# 10855 "grep_single_original.c"
 ; zzz } while (0);

  return -1;
}
# 10873 "grep_single_original.c"
static boolean
group_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;

  unsigned char *p1 = *p + 2;

  while (p1 < end)
    {




      switch ((re_opcode_t) *p1)
        {

        case on_failure_jump:
          p1++;
          zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);




   if (mcnt >= 0)
     {
# 10918 "grep_single_original.c"
              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
                {




                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
                          reg_info))
                    return 0;



                  p1 += mcnt;



                  if ((re_opcode_t) *p1 != on_failure_jump)
                    break;



    p1++;
                  zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
                    {

                      p1 -= 3;
                      break;
                    }
                }




              zzz do { zzz (mcnt) = *(p1 - 2) & 0377; zzz (mcnt) += ((signed char) (*((p1 - 2) + 1))) << 8; zzz } while (0);

              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
                return 0;

              p1 += mcnt;
            }
          break;


        case stop_memory:
   ;
          *p = p1 + 2;
          return 1;


        default:
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return 0;
        }
    }

  return 0;
}






static boolean
alt_match_null_string_p (p, end, reg_info)
    unsigned char *p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  unsigned char *p1 = p;

  while (p1 < end)
    {



      switch ((re_opcode_t) *p1)
        {

        case on_failure_jump:
          p1++;
          zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
          p1 += mcnt;
          break;

 default:
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return 0;
        }
    }

  return 1;
}







static boolean
common_op_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  boolean ret;
  int reg_no;
  unsigned char *p1 = *p;

  switch ((re_opcode_t) *p1++)
    {
    case no_op:
    case begline:
    case endline:
    case begbuf:
    case endbuf:
    case wordbeg:
    case wordend:
    case wordbound:
    case notwordbound:





      break;

    case start_memory:
      reg_no = *p1;
      ;
      ret = group_match_null_string_p (&p1, end, reg_info);




      if (((reg_info[reg_no]).bits.match_null_string_p) == 3)
        ((reg_info[reg_no]).bits.match_null_string_p) = ret;

      if (!ret)
        return 0;
      break;


    case jump:
      zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
      if (mcnt >= 0)
        p1 += mcnt;
      else
        return 0;
      break;

    case succeed_n:

      p1 += 2;
      zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);

      if (mcnt == 0)
        {
          p1 -= 4;
          zzz do { zzz zzz do { zzz (mcnt) = *(p1) & 0377; zzz (mcnt) += ((signed char) (*((p1) + 1))) << 8; zzz } while (0); zzz (p1) += 2; zzz } while (0);
          p1 += mcnt;
        }
      else
        return 0;
      break;

    case duplicate:
      if (!((reg_info[*p1]).bits.match_null_string_p))
        return 0;
      break;

    case set_number_at:
      p1 += 4;

    default:

      return 0;
  }

  *p = p1;
  return 1;
}





static int
bcmp_translate (s1, s2, len, translate)
     const char *s1, *s2;
     register int len;
     char * translate;
{
  register const unsigned char *p1 = (const unsigned char *) s1;
  register const unsigned char *p2 = (const unsigned char *) s2;
  while (len)
    {
      if (translate[*p1++] != translate[*p2++]) return 1;
      len--;
    }
  return 0;
}
# 11134 "grep_single_original.c"
const char *
re_compile_pattern (pattern, length, bufp)
     const char *pattern;
     size_t length;
     struct re_pattern_buffer *bufp;
{
  reg_errcode_t ret;



  bufp->regs_allocated = 0;




  bufp->no_sub = 0;


  bufp->newline_anchor = 1;

  ret = regex_compile (pattern, length, re_syntax_options, bufp);

  if (!ret)
    return 
# 11157 "grep_single_original.c" 3 4
          ((void *)0)
# 11157 "grep_single_original.c"
              ;
  return gettext (re_error_msgid[(int) ret]);
}
# 11272 "grep_single_original.c"
int
regcomp (preg, pattern, cflags)
    regex_t *preg;
    const char *pattern;
    int cflags;
{
  reg_errcode_t ret;
  reg_syntax_t syntax
    = (cflags & 1) ?
      ((((((unsigned long int) 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((unsigned long int) 1) << 1) << 1) << 1) | ((((((unsigned long int) 1) << 1) << 1) << 1) << 1) | ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) : ((((((unsigned long int) 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((unsigned long int) 1) << 1));


  preg->buffer = 0;
  preg->allocated = 0;
  preg->used = 0;


  preg->fastmap = (char *) xmalloc (1 << 8);

  if (cflags & (1 << 1))
    {
      unsigned i;

      preg->translate
 = (char *) xmalloc (256
          * sizeof (*(char *)0));
      if (preg->translate == 
# 11298 "grep_single_original.c" 3 4
                            ((void *)0)
# 11298 "grep_single_original.c"
                                )
        return (int) REG_ESPACE;


      for (i = 0; i < 256; i++)
        preg->translate[i] = (1 && 
# 11303 "grep_single_original.c" 3 4
                            ((*__ctype_b_loc ())[(int) ((
# 11303 "grep_single_original.c"
                            i
# 11303 "grep_single_original.c" 3 4
                            ))] & (unsigned short int) _ISupper)
# 11303 "grep_single_original.c"
                            ) ? tolower (i) : i;
    }
  else
    preg->translate = 
# 11306 "grep_single_original.c" 3 4
                     ((void *)0)
# 11306 "grep_single_original.c"
                         ;


  if (cflags & ((1 << 1) << 1))
    {
      syntax &= ~((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1);
      syntax |= ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);

      preg->newline_anchor = 1;
    }
  else
    preg->newline_anchor = 0;

  preg->no_sub = !!(cflags & (((1 << 1) << 1) << 1));



  ret = regex_compile (pattern, strlen (pattern), syntax, preg);



  if (ret == REG_ERPAREN) ret = REG_EPAREN;

  if (ret == REG_NOERROR && preg->fastmap)
    {


      if (re_compile_fastmap (preg) == -2)
 {


   free (preg->fastmap);
   preg->fastmap = 
# 11338 "grep_single_original.c" 3 4
                  ((void *)0)
# 11338 "grep_single_original.c"
                      ;
 }
    }

  return (int) ret;
}
# 11363 "grep_single_original.c"
int
regexec (preg, string, nmatch, pmatch, eflags)
    const regex_t *preg;
    const char *string;
    size_t nmatch;
    regmatch_t pmatch[];
    int eflags;
{
  int ret;
  struct re_registers regs;
  regex_t private_preg;
  int len = strlen (string);
  boolean want_reg_info = !preg->no_sub && nmatch > 0;

  private_preg = *preg;

  private_preg.not_bol = !!(eflags & 1);
  private_preg.not_eol = !!(eflags & (1 << 1));




  private_preg.regs_allocated = 2;

  if (want_reg_info)
    {
      regs.num_regs = nmatch;
      regs.start = ((regoff_t *) xmalloc ((nmatch * 2) * sizeof (regoff_t)));
      if (regs.start == 
# 11391 "grep_single_original.c" 3 4
                       ((void *)0)
# 11391 "grep_single_original.c"
                           )
        return (int) REG_NOMATCH;
      regs.end = regs.start + nmatch;
    }


  ret = re_search (&private_preg, string, len,
                                0, len,
                   want_reg_info ? &regs : (struct re_registers *) 0);


  if (want_reg_info)
    {
      if (ret >= 0)
        {
          unsigned r;

          for (r = 0; r < nmatch; r++)
            {
              pmatch[r].rm_so = regs.start[r];
              pmatch[r].rm_eo = regs.end[r];
            }
        }


      free (regs.start);
    }


  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
}
# 11430 "grep_single_original.c"
size_t
regerror (errcode, preg, errbuf, errbuf_size)
    int errcode;
    const regex_t *preg;
    char *errbuf;
    size_t errbuf_size;
{
  const char *msg;
  size_t msg_size;

  if (errcode < 0
      || errcode >= (int) (sizeof (re_error_msgid)
      / sizeof (re_error_msgid[0])))




    abort ();

  msg = gettext (re_error_msgid[errcode]);

  msg_size = strlen (msg) + 1;

  if (errbuf_size != 0)
    {
      if (msg_size > errbuf_size)
        {



          memcpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;

        }
      else
        memcpy (errbuf, msg, msg_size);
    }

  return msg_size;
}







void
regfree (preg)
    regex_t *preg;
{
  if (preg->buffer != 
# 11481 "grep_single_original.c" 3 4
                     ((void *)0)
# 11481 "grep_single_original.c"
                         )
    free (preg->buffer);
  preg->buffer = 
# 11483 "grep_single_original.c" 3 4
                ((void *)0)
# 11483 "grep_single_original.c"
                    ;

  preg->allocated = 0;
  preg->used = 0;

  if (preg->fastmap != 
# 11488 "grep_single_original.c" 3 4
                      ((void *)0)
# 11488 "grep_single_original.c"
                          )
    free (preg->fastmap);
  preg->fastmap = 
# 11490 "grep_single_original.c" 3 4
                 ((void *)0)
# 11490 "grep_single_original.c"
                     ;
  preg->fastmap_accurate = 0;

  if (preg->translate != 
# 11493 "grep_single_original.c" 3 4
                        ((void *)0)
# 11493 "grep_single_original.c"
                            )
    free (preg->translate);
  preg->translate = 
# 11495 "grep_single_original.c" 3 4
                   ((void *)0)
# 11495 "grep_single_original.c"
                       ;
}
# 11536 "grep_single_original.c"
# 1 "/usr/include/dirent.h" 1 3 4
# 27 "/usr/include/dirent.h" 3 4

# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4

# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 62 "/usr/include/dirent.h" 2 3 4
# 97 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 127 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 162 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 208 "/usr/include/dirent.h" 3 4
extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 245 "/usr/include/dirent.h" 2 3 4
# 254 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 324 "/usr/include/dirent.h" 3 4
extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 401 "/usr/include/dirent.h" 3 4

# 11537 "grep_single_original.c" 2
# 11577 "grep_single_original.c"

# 11577 "grep_single_original.c"
char *stpcpy ();
# 11589 "grep_single_original.c"
char *
savedir (dir, name_size)
     const char *dir;
     unsigned int name_size;
{
  DIR *dirp;
  struct dirent *dp;
  char *name_space;
  char *namep;

  dirp = opendir (dir);
  if (dirp == 
# 11600 "grep_single_original.c" 3 4
             ((void *)0)
# 11600 "grep_single_original.c"
                 )
    return 
# 11601 "grep_single_original.c" 3 4
          ((void *)0)
# 11601 "grep_single_original.c"
              ;

  name_space = (char *) xmalloc (name_size);
  if (name_space == 
# 11604 "grep_single_original.c" 3 4
                   ((void *)0)
# 11604 "grep_single_original.c"
                       )
    {
      closedir (dirp);
      return 
# 11607 "grep_single_original.c" 3 4
            ((void *)0)
# 11607 "grep_single_original.c"
                ;
    }
  namep = name_space;

  while ((dp = readdir (dirp)) != 
# 11611 "grep_single_original.c" 3 4
                                 ((void *)0)
# 11611 "grep_single_original.c"
                                     )
    {

      if (dp->d_name[0] != '.'
   || (dp->d_name[1] != '\0'
       && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
 {
   unsigned size_needed = (namep - name_space) + strlen((dp)->d_name) + 2;

   if (size_needed > name_size)
     {
       char *new_name_space;

       while (size_needed > name_size)
  name_size += 1024;

       new_name_space = realloc (name_space, name_size);
       if (new_name_space == 
# 11628 "grep_single_original.c" 3 4
                            ((void *)0)
# 11628 "grep_single_original.c"
                                )
  {
    closedir (dirp);
    return 
# 11631 "grep_single_original.c" 3 4
          ((void *)0)
# 11631 "grep_single_original.c"
              ;
  }
       namep += new_name_space - name_space;
       name_space = new_name_space;
     }
   namep = stpcpy (namep, dp->d_name) + 1;
 }
    }
  *namep = '\0';
  if (closedir (dirp))
    {
      free (name_space);
      return 
# 11643 "grep_single_original.c" 3 4
            ((void *)0)
# 11643 "grep_single_original.c"
                ;
    }
  return name_space;
}
# 12901 "grep_single_original.c"
static void Gcompile (char *, size_t);
static void Ecompile (char *, size_t);
static char *EGexecute (char *, size_t, char **);
static void Fcompile (char *, size_t);
static char *Fexecute (char *, size_t, char **);
static void kwsinit (void);


struct matcher matchers[] = {
  { "default", Gcompile, EGexecute },
  { "grep", Gcompile, EGexecute },
  { "egrep", Ecompile, EGexecute },
  { "awk", Ecompile, EGexecute },
  { "fgrep", Fcompile, Fexecute },
  { 0, 0, 0 },
};





static struct dfa dfa_1;


static struct re_pattern_buffer regexbuf;




static kwset_t kwset;




static int lastexact;

void
dfaerror(mesg)
  const char *mesg;
{
  fatal(mesg, 0);
}

static void
kwsinit()
{
  static char trans[(
# 12947 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 12947 "grep_single_original.c"
                   + 1)];
  int i;

  if (match_icase)
    for (i = 0; i < (
# 12951 "grep_single_original.c" 3 4
                   (0x7f * 2 + 1) 
# 12951 "grep_single_original.c"
                   + 1); ++i)
      trans[i] = ((1 && 
# 12952 "grep_single_original.c" 3 4
                ((*__ctype_b_loc ())[(int) ((
# 12952 "grep_single_original.c"
                i
# 12952 "grep_single_original.c" 3 4
                ))] & (unsigned short int) _ISupper)
# 12952 "grep_single_original.c"
                ) ? tolower(i) : (i));

  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
    fatal("memory exhausted", 0);
}





static void
kwsmusts()
{
  struct dfamust *dm;
  char *err;

  if (dfa_1.musts)
    {
      kwsinit();



      for (dm = dfa_1.musts; dm; dm = dm->next)
 {
   if (!dm->exact)
     continue;
   ++lastexact;
   if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
     fatal(err, 0);
 }


      for (dm = dfa_1.musts; dm; dm = dm->next)
 {
   if (dm->exact)
     continue;
   if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
     fatal(err, 0);
 }
      if ((err = kwsprep(kwset)) != 0)
 fatal(err, 0);
    }
}

static void
Gcompile(pattern, size)
     char *pattern;
     size_t size;
{
  const char *err;

  re_set_syntax(((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));

  dfasyntax(((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), match_icase, eolbyte);




  if ((err = re_compile_pattern(pattern, size, &regexbuf)) != 0)
    fatal(err, 0);





  if (match_words || match_lines)
    {







      char *n = xmalloc(size + 50);
      int i = 0;

      strcpy(n, "");

      if (match_lines)
 strcpy(n, "^\\(");
      if (match_words)
 strcpy(n, "\\(^\\|[^[:alnum:]_]\\)\\(");

      i = strlen(n);
      memcpy(n + i, pattern, size);
      i += size;

      if (match_words)
 strcpy(n + i, "\\)\\([^[:alnum:]_]\\|$\\)");
      if (match_lines)
 strcpy(n + i, "\\)$");

      i += strlen(n + i);
      dfacomp(n, i, &dfa_1, 1);
    }
  else
    dfacomp(pattern, size, &dfa_1, 1);

  kwsmusts();
}

static void
Ecompile(pattern, size)
     char *pattern;
     size_t size;
{
  const char *err;

  if (strcmp(matcher, "awk") == 0)
    {
      re_set_syntax((((unsigned long int) 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
      dfasyntax((((unsigned long int) 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase, eolbyte);
    }
  else
    {
      re_set_syntax (((((((unsigned long int) 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | ((((((unsigned long int) 1) << 1) << 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
      dfasyntax (((((((unsigned long int) 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | ((((((unsigned long int) 1) << 1) << 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase, eolbyte);
    }

  if ((err = re_compile_pattern(pattern, size, &regexbuf)) != 0)
    fatal(err, 0);





  if (match_words || match_lines)
    {







      char *n = xmalloc(size + 50);
      int i = 0;

      strcpy(n, "");

      if (match_lines)
 strcpy(n, "^(");
      if (match_words)
 strcpy(n, "(^|[^[:alnum:]_])(");

      i = strlen(n);
      memcpy(n + i, pattern, size);
      i += size;

      if (match_words)
 strcpy(n + i, ")([^[:alnum:]_]|$)");
      if (match_lines)
 strcpy(n + i, ")$");

      i += strlen(n + i);
      dfacomp(n, i, &dfa_1, 1);
    }
  else
    dfacomp(pattern, size, &dfa_1, 1);

  kwsmusts();
}

static char *
EGexecute(buf, size, endp)
     char *buf;
     size_t size;
     char **endp;
{
  register char *buflim, *beg, *end, save;
  char eol = eolbyte;
  int backref, start, len;
  struct kwsmatch kwsm;
  static struct re_registers regs;


  buflim = buf + size;

  for (beg = end = buf; end < buflim; beg = end + 1)
    {
      if (kwset)
 {

   beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
   if (!beg)
     goto failure;


   end = memchr(beg, eol, buflim - beg);
   if (!end)
     end = buflim;
   while (beg > buf && beg[-1] != eol)
     --beg;
   save = *end;
   if (kwsm.strchr < lastexact)
     goto success;
   if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
     {
       *end = save;
       continue;
     }
   *end = save;

   if (!backref)
     goto success;
 }
      else
 {

   save = *buflim;
   beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
   *buflim = save;
   if (!beg)
     goto failure;

   end = memchr(beg, eol, buflim - beg);
   if (!end)
     end = buflim;
   while (beg > buf && beg[-1] != eol)
     --beg;

   if (!backref)
     goto success;
 }


      regexbuf.not_eol = 0;
      if ((start = re_search(&regexbuf, beg, end - beg, 0, end - beg, &regs)) >= 0)
 {
   len = regs.end[0] - start;
   if ((!match_lines && !match_words)
       || (match_lines && len == end - beg))
     goto success;






   if (match_words)
     while (start >= 0)
       {
  if ((start == 0 || !((1 && 
# 13195 "grep_single_original.c" 3 4
                     ((*__ctype_b_loc ())[(int) ((
# 13195 "grep_single_original.c"
                     (unsigned char) beg[start - 1]
# 13195 "grep_single_original.c" 3 4
                     ))] & (unsigned short int) _ISalnum)
# 13195 "grep_single_original.c"
                     ) || ((unsigned char) beg[start - 1]) == '_'))
      && (len == end - beg
   || !((1 && 
# 13197 "grep_single_original.c" 3 4
      ((*__ctype_b_loc ())[(int) ((
# 13197 "grep_single_original.c"
      (unsigned char) beg[start + len]
# 13197 "grep_single_original.c" 3 4
      ))] & (unsigned short int) _ISalnum)
# 13197 "grep_single_original.c"
      ) || ((unsigned char) beg[start + len]) == '_')))
    goto success;
  if (len > 0)
    {

      --len;
      regexbuf.not_eol = 1;
      len = re_match(&regexbuf, beg, start + len, start, &regs);
    }
  if (len <= 0)
    {

      if (start == end - beg)
        break;
      ++start;
      regexbuf.not_eol = 0;
      start = re_search(&regexbuf, beg, end - beg,
          start, end - beg - start, &regs);
      len = regs.end[0] - start;
    }
       }
 }
    }

 failure:
  return 0;

 success:
  *endp = end < buflim ? end + 1 : end;
  return beg;
}

static void
Fcompile(pattern, size)
     char *pattern;
     size_t size;
{
  char *beg, *lim, *err;

  kwsinit();
  beg = pattern;
  do
    {
      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
 ;
      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
 fatal(err, 0);
      if (lim < pattern + size)
 ++lim;
      beg = lim;
    }
  while (beg < pattern + size);

  if ((err = kwsprep(kwset)) != 0)
    fatal(err, 0);
}

static char *
Fexecute(buf, size, endp)
     char *buf;
     size_t size;
     char **endp;
{
  register char *beg, *try, *end;
  register size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;

  for (beg = buf; beg <= buf + size; ++beg)
    {
      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
 return 0;
      len = kwsmatch.size[0];
      if (match_lines)
 {
   if (beg > buf && beg[-1] != eol)
     continue;
   if (beg + len < buf + size && beg[len] != eol)
     continue;
   goto success;
 }
      else if (match_words)
 for (try = beg; len && try;)
   {
     if (try > buf && ((1 && 
# 13281 "grep_single_original.c" 3 4
                     ((*__ctype_b_loc ())[(int) ((
# 13281 "grep_single_original.c"
                     (unsigned char) try[-1]
# 13281 "grep_single_original.c" 3 4
                     ))] & (unsigned short int) _ISalnum)
# 13281 "grep_single_original.c"
                     ) || ((unsigned char) try[-1]) == '_'))
       break;
     if (try + len < buf + size && ((1 && 
# 13283 "grep_single_original.c" 3 4
                                  ((*__ctype_b_loc ())[(int) ((
# 13283 "grep_single_original.c"
                                  (unsigned char) try[len]
# 13283 "grep_single_original.c" 3 4
                                  ))] & (unsigned short int) _ISalnum)
# 13283 "grep_single_original.c"
                                  ) || ((unsigned char) try[len]) == '_'))
       {
  try = kwsexec(kwset, beg, --len, &kwsmatch);
  len = kwsmatch.size[0];
       }
     else
       goto success;
   }
      else
 goto success;
    }

  return 0;

 success:
  if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != 0)
    ++end;
  else
    end = buf + size;
  *endp = end;
  while (beg > buf && beg[-1] != '\n')
    --beg;
  return beg;
}
# 13315 "grep_single_original.c"
char const *matcher;
# 13357 "grep_single_original.c"
char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  register char *d = dest;
  register const char *s = src;

  do
    *d++ = *s;
  while (*s++ != '\0');

  return d - 1;
}
