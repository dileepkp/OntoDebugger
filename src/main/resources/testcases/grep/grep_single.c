

# 1 "grep_single_original.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "grep_single_original.c"
# 28 "grep_single_original.c"
# 1 "./config.h" 1
# 29 "grep_single_original.c" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 367 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 368 "/usr/include/features.h" 2 3 4
# 391 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 392 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4
# 73 "/usr/include/time.h" 3 4
# 91 "/usr/include/time.h" 3 4
# 103 "/usr/include/time.h" 3 4
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 216 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 270 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 32 "grep_single_original.c" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 105 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 208 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 237 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 262 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 283 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 320 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 398 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 441 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 533 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 34 "grep_single_original.c" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 57 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 76 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 36 "grep_single_original.c" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
# 64 "/usr/include/stdio.h" 3 4
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
# 21 "/usr/include/_G_config.h" 2 3 4
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 3 4
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
# 173 "/usr/include/libio.h" 3 4
# 241 "/usr/include/libio.h" 3 4
# 289 "/usr/include/libio.h" 3 4
# 333 "/usr/include/libio.h" 3 4
# 385 "/usr/include/libio.h" 3 4
# 429 "/usr/include/libio.h" 3 4
# 459 "/usr/include/libio.h" 3 4
# 75 "/usr/include/stdio.h" 2 3 4
# 108 "/usr/include/stdio.h" 3 4
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4
# 209 "/usr/include/stdio.h" 3 4
# 227 "/usr/include/stdio.h" 3 4
# 252 "/usr/include/stdio.h" 3 4
# 266 "/usr/include/stdio.h" 3 4
# 295 "/usr/include/stdio.h" 3 4
# 306 "/usr/include/stdio.h" 3 4
# 319 "/usr/include/stdio.h" 3 4
# 412 "/usr/include/stdio.h" 3 4
# 443 "/usr/include/stdio.h" 3 4
# 463 "/usr/include/stdio.h" 3 4
# 494 "/usr/include/stdio.h" 3 4
# 522 "/usr/include/stdio.h" 3 4
# 550 "/usr/include/stdio.h" 3 4
# 561 "/usr/include/stdio.h" 3 4
# 594 "/usr/include/stdio.h" 3 4
# 640 "/usr/include/stdio.h" 3 4
# 665 "/usr/include/stdio.h" 3 4
# 737 "/usr/include/stdio.h" 3 4
# 773 "/usr/include/stdio.h" 3 4
# 792 "/usr/include/stdio.h" 3 4
# 815 "/usr/include/stdio.h" 3 4
# 824 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
# 854 "/usr/include/stdio.h" 2 3 4
# 872 "/usr/include/stdio.h" 3 4
# 912 "/usr/include/stdio.h" 3 4
# 942 "/usr/include/stdio.h" 3 4
# 42 "grep_single_original.c" 2
# 1 "system.h" 1
# 23 "system.h"
# 23 "system.h"
# 35 "system.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 363 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 437 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 76 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 77 "/usr/include/fcntl.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 78 "/usr/include/fcntl.h" 2 3 4
# 146 "/usr/include/fcntl.h" 3 4
# 156 "/usr/include/fcntl.h" 3 4
# 180 "/usr/include/fcntl.h" 3 4
# 202 "/usr/include/fcntl.h" 3 4
# 231 "/usr/include/fcntl.h" 3 4
# 248 "/usr/include/fcntl.h" 3 4
# 270 "/usr/include/fcntl.h" 3 4
# 292 "/usr/include/fcntl.h" 3 4
# 36 "system.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 258 "/usr/include/unistd.h" 3 4
# 270 "/usr/include/unistd.h" 3 4
# 290 "/usr/include/unistd.h" 3 4
# 307 "/usr/include/unistd.h" 3 4
# 337 "/usr/include/unistd.h" 3 4
# 356 "/usr/include/unistd.h" 3 4
# 379 "/usr/include/unistd.h" 3 4
# 420 "/usr/include/unistd.h" 3 4
# 435 "/usr/include/unistd.h" 3 4
# 447 "/usr/include/unistd.h" 3 4
# 472 "/usr/include/unistd.h" 3 4
# 514 "/usr/include/unistd.h" 3 4
# 528 "/usr/include/unistd.h" 3 4
# 546 "/usr/include/unistd.h" 3 4
# 601 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
# 613 "/usr/include/unistd.h" 2 3 4
# 663 "/usr/include/unistd.h" 3 4
# 703 "/usr/include/unistd.h" 3 4
# 759 "/usr/include/unistd.h" 3 4
# 874 "/usr/include/unistd.h" 3 4
# 1 "./getopt.h" 1 3 4
# 35 "./getopt.h" 3 4
# 49 "./getopt.h" 3 4
# 81 "./getopt.h" 3 4
# 106 "./getopt.h" 3 4
# 875 "/usr/include/unistd.h" 2 3 4
# 972 "/usr/include/unistd.h" 3 4
# 996 "/usr/include/unistd.h" 3 4
# 1019 "/usr/include/unistd.h" 3 4
# 1040 "/usr/include/unistd.h" 3 4
# 1061 "/usr/include/unistd.h" 3 4
# 1115 "/usr/include/unistd.h" 3 4
# 1154 "/usr/include/unistd.h" 3 4
# 37 "system.h" 2
# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 36 "/usr/include/errno.h" 2 3 4
# 58 "/usr/include/errno.h" 3 4
# 45 "system.h" 2
# 114 "system.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
# 33 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
# 95 "/usr/include/stdlib.h" 3 4
# 139 "/usr/include/stdlib.h" 3 4
# 305 "/usr/include/stdlib.h" 3 4
# 321 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4
# 493 "/usr/include/stdlib.h" 2 3 4
# 578 "/usr/include/stdlib.h" 3 4
# 606 "/usr/include/stdlib.h" 3 4
# 619 "/usr/include/stdlib.h" 3 4
# 641 "/usr/include/stdlib.h" 3 4
# 662 "/usr/include/stdlib.h" 3 4
# 711 "/usr/include/stdlib.h" 3 4
# 733 "/usr/include/stdlib.h" 3 4
# 751 "/usr/include/stdlib.h" 3 4
# 774 "/usr/include/stdlib.h" 3 4
# 811 "/usr/include/stdlib.h" 3 4
# 898 "/usr/include/stdlib.h" 3 4
# 950 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 955 "/usr/include/stdlib.h" 2 3 4
# 967 "/usr/include/stdlib.h" 3 4
# 115 "system.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
# 426 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
# 123 "system.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 1 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 126 "system.h" 2
# 141 "system.h"
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 92 "/usr/include/string.h" 3 4
# 123 "/usr/include/string.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
# 160 "/usr/include/string.h" 2 3 4
# 206 "/usr/include/string.h" 3 4
# 231 "/usr/include/string.h" 3 4
# 258 "/usr/include/string.h" 3 4
# 277 "/usr/include/string.h" 3 4
# 310 "/usr/include/string.h" 3 4
# 337 "/usr/include/string.h" 3 4
# 392 "/usr/include/string.h" 3 4
# 422 "/usr/include/string.h" 3 4
# 440 "/usr/include/string.h" 3 4
# 484 "/usr/include/string.h" 3 4
# 512 "/usr/include/string.h" 3 4
# 529 "/usr/include/string.h" 3 4
# 552 "/usr/include/string.h" 3 4
# 658 "/usr/include/string.h" 3 4
# 142 "system.h" 2
# 158 "system.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
# 46 "/usr/include/ctype.h" 3 4
# 79 "/usr/include/ctype.h" 3 4
# 104 "/usr/include/ctype.h" 3 4
# 150 "/usr/include/ctype.h" 3 4
# 271 "/usr/include/ctype.h" 3 4
# 347 "/usr/include/ctype.h" 3 4
# 159 "system.h" 2
# 185 "system.h"
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4
# 121 "/usr/include/libintl.h" 3 4
# 186 "system.h" 2
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 50 "/usr/include/locale.h" 3 4
# 120 "/usr/include/locale.h" 3 4
# 151 "/usr/include/locale.h" 3 4
# 186 "/usr/include/locale.h" 3 4
# 194 "system.h" 2
# 49 "grep_single_original.c" 2
# 1 "getopt.h" 1
# 50 "grep_single_original.c" 2
# 1 "getpagesize.h" 1
# 51 "grep_single_original.c" 2
# 1 "grep.h" 1
# 23 "grep.h"
# 23 "grep.h"
# 52 "grep_single_original.c" 2
# 1 "savedir.h" 1
# 12 "savedir.h"
# 53 "grep_single_original.c" 2
# 82 "grep_single_original.c" 3 4
# 82 "grep_single_original.c"
# 82 "grep_single_original.c" 3 4
# 82 "grep_single_original.c"
# 83 "grep_single_original.c" 3 4
# 83 "grep_single_original.c"
# 83 "grep_single_original.c" 3 4
# 83 "grep_single_original.c"
# 84 "grep_single_original.c" 3 4
# 84 "grep_single_original.c"
# 84 "grep_single_original.c" 3 4
# 84 "grep_single_original.c"
# 85 "grep_single_original.c" 3 4
# 85 "grep_single_original.c"
# 85 "grep_single_original.c" 3 4
# 85 "grep_single_original.c"
# 86 "grep_single_original.c" 3 4
# 86 "grep_single_original.c"
# 86 "grep_single_original.c" 3 4
# 86 "grep_single_original.c"
# 87 "grep_single_original.c" 3 4
# 87 "grep_single_original.c"
# 87 "grep_single_original.c" 3 4
# 87 "grep_single_original.c"
# 88 "grep_single_original.c" 3 4
# 88 "grep_single_original.c"
# 88 "grep_single_original.c" 3 4
# 88 "grep_single_original.c"
# 89 "grep_single_original.c" 3 4
# 89 "grep_single_original.c"
# 89 "grep_single_original.c" 3 4
# 89 "grep_single_original.c"
# 90 "grep_single_original.c" 3 4
# 90 "grep_single_original.c"
# 90 "grep_single_original.c" 3 4
# 90 "grep_single_original.c"
# 91 "grep_single_original.c" 3 4
# 91 "grep_single_original.c"
# 91 "grep_single_original.c" 3 4
# 91 "grep_single_original.c"
# 92 "grep_single_original.c" 3 4
# 92 "grep_single_original.c"
# 92 "grep_single_original.c" 3 4
# 92 "grep_single_original.c"
# 93 "grep_single_original.c" 3 4
# 93 "grep_single_original.c"
# 93 "grep_single_original.c" 3 4
# 93 "grep_single_original.c"
# 94 "grep_single_original.c" 3 4
# 94 "grep_single_original.c"
# 94 "grep_single_original.c" 3 4
# 94 "grep_single_original.c"
# 95 "grep_single_original.c" 3 4
# 95 "grep_single_original.c"
# 96 "grep_single_original.c" 3 4
# 96 "grep_single_original.c"
# 96 "grep_single_original.c" 3 4
# 96 "grep_single_original.c"
# 97 "grep_single_original.c" 3 4
# 97 "grep_single_original.c"
# 97 "grep_single_original.c" 3 4
# 97 "grep_single_original.c"
# 98 "grep_single_original.c" 3 4
# 98 "grep_single_original.c"
# 98 "grep_single_original.c" 3 4
# 98 "grep_single_original.c"
# 99 "grep_single_original.c" 3 4
# 99 "grep_single_original.c"
# 100 "grep_single_original.c" 3 4
# 100 "grep_single_original.c"
# 100 "grep_single_original.c" 3 4
# 100 "grep_single_original.c"
# 101 "grep_single_original.c" 3 4
# 101 "grep_single_original.c"
# 101 "grep_single_original.c" 3 4
# 101 "grep_single_original.c"
# 102 "grep_single_original.c" 3 4
# 102 "grep_single_original.c"
# 102 "grep_single_original.c" 3 4
# 102 "grep_single_original.c"
# 103 "grep_single_original.c" 3 4
# 103 "grep_single_original.c"
# 103 "grep_single_original.c" 3 4
# 103 "grep_single_original.c"
# 104 "grep_single_original.c" 3 4
# 104 "grep_single_original.c"
# 104 "grep_single_original.c" 3 4
# 104 "grep_single_original.c"
# 105 "grep_single_original.c" 3 4
# 105 "grep_single_original.c"
# 105 "grep_single_original.c" 3 4
# 105 "grep_single_original.c"
# 106 "grep_single_original.c" 3 4
# 106 "grep_single_original.c"
# 106 "grep_single_original.c" 3 4
# 106 "grep_single_original.c"
# 107 "grep_single_original.c" 3 4
# 107 "grep_single_original.c"
# 107 "grep_single_original.c" 3 4
# 107 "grep_single_original.c"
# 108 "grep_single_original.c" 3 4
# 108 "grep_single_original.c"
# 108 "grep_single_original.c" 3 4
# 108 "grep_single_original.c"
# 109 "grep_single_original.c" 3 4
# 109 "grep_single_original.c"
# 109 "grep_single_original.c" 3 4
# 109 "grep_single_original.c"
# 110 "grep_single_original.c" 3 4
# 110 "grep_single_original.c"
# 110 "grep_single_original.c" 3 4
# 110 "grep_single_original.c"
# 111 "grep_single_original.c" 3 4
# 111 "grep_single_original.c"
# 111 "grep_single_original.c" 3 4
# 111 "grep_single_original.c"
# 112 "grep_single_original.c" 3 4
# 112 "grep_single_original.c"
# 112 "grep_single_original.c" 3 4
# 112 "grep_single_original.c"
# 113 "grep_single_original.c" 3 4
# 113 "grep_single_original.c"
# 113 "grep_single_original.c" 3 4
# 113 "grep_single_original.c"
# 114 "grep_single_original.c" 3 4
# 114 "grep_single_original.c"
# 114 "grep_single_original.c" 3 4
# 114 "grep_single_original.c"
# 172 "grep_single_original.c" 3 4
# 172 "grep_single_original.c"
# 174 "grep_single_original.c" 3 4
# 174 "grep_single_original.c"
# 266 "grep_single_original.c"
# 289 "grep_single_original.c" 3 4
# 289 "grep_single_original.c"
# 334 "grep_single_original.c" 3 4
# 334 "grep_single_original.c"
# 337 "grep_single_original.c" 3 4
# 337 "grep_single_original.c"
# 337 "grep_single_original.c" 3 4
# 337 "grep_single_original.c"
# 339 "grep_single_original.c" 3 4
# 339 "grep_single_original.c"
# 339 "grep_single_original.c" 3 4
# 339 "grep_single_original.c"
# 345 "grep_single_original.c" 3 4
# 345 "grep_single_original.c"
# 348 "grep_single_original.c" 3 4
# 348 "grep_single_original.c"
# 397 "grep_single_original.c" 3 4
# 397 "grep_single_original.c"
# 397 "grep_single_original.c" 3 4
# 397 "grep_single_original.c"
# 471 "grep_single_original.c" 3 4
# 471 "grep_single_original.c"
# 471 "grep_single_original.c" 3 4
# 471 "grep_single_original.c"
# 471 "grep_single_original.c" 3 4
# 471 "grep_single_original.c"
# 471 "grep_single_original.c" 3 4
# 471 "grep_single_original.c"
# 489 "grep_single_original.c" 3 4
# 489 "grep_single_original.c"
# 491 "grep_single_original.c" 3 4
# 491 "grep_single_original.c"
# 503 "grep_single_original.c" 3 4
# 503 "grep_single_original.c"
# 503 "grep_single_original.c" 3 4
# 503 "grep_single_original.c"
# 532 "grep_single_original.c"
# 595 "grep_single_original.c" 3 4
# 595 "grep_single_original.c"
# 624 "grep_single_original.c" 3 4
# 624 "grep_single_original.c"
# 625 "grep_single_original.c" 3 4
# 625 "grep_single_original.c"
# 626 "grep_single_original.c" 3 4
# 626 "grep_single_original.c"
# 780 "grep_single_original.c" 3 4
# 780 "grep_single_original.c"
# 780 "grep_single_original.c" 3 4
# 780 "grep_single_original.c"
# 785 "grep_single_original.c" 3 4
# 785 "grep_single_original.c"
# 800 "grep_single_original.c" 3 4
# 800 "grep_single_original.c"
# 800 "grep_single_original.c" 3 4
# 800 "grep_single_original.c"
# 801 "grep_single_original.c" 3 4
# 801 "grep_single_original.c"
# 846 "grep_single_original.c" 3 4
# 846 "grep_single_original.c"
# 846 "grep_single_original.c" 3 4
# 846 "grep_single_original.c"
# 847 "grep_single_original.c" 3 4
# 847 "grep_single_original.c"
# 883 "grep_single_original.c" 3 4
# 883 "grep_single_original.c"
# 883 "grep_single_original.c" 3 4
# 883 "grep_single_original.c"
# 883 "grep_single_original.c" 3 4
# 883 "grep_single_original.c"
# 892 "grep_single_original.c" 3 4
# 892 "grep_single_original.c"
# 894 "grep_single_original.c" 3 4
# 894 "grep_single_original.c"
# 898 "grep_single_original.c" 3 4
# 898 "grep_single_original.c"
# 911 "grep_single_original.c" 3 4
# 911 "grep_single_original.c"
# 914 "grep_single_original.c" 3 4
# 914 "grep_single_original.c"
# 918 "grep_single_original.c" 3 4
# 918 "grep_single_original.c"
# 918 "grep_single_original.c" 3 4
# 918 "grep_single_original.c"
# 939 "grep_single_original.c"
# 963 "grep_single_original.c" 3 4
# 963 "grep_single_original.c"
# 963 "grep_single_original.c" 3 4
# 963 "grep_single_original.c"
# 965 "grep_single_original.c" 3 4
# 965 "grep_single_original.c"
# 992 "grep_single_original.c" 3 4
# 992 "grep_single_original.c"
# 1001 "grep_single_original.c" 3 4
# 1001 "grep_single_original.c"
# 1004 "grep_single_original.c" 3 4
# 1004 "grep_single_original.c"
# 1014 "grep_single_original.c" 3 4
# 1014 "grep_single_original.c"
# 1044 "grep_single_original.c" 3 4
# 1044 "grep_single_original.c"
# 1045 "grep_single_original.c" 3 4
# 1045 "grep_single_original.c"
# 1089 "grep_single_original.c"
# 1104 "grep_single_original.c"
# 1161 "grep_single_original.c"
# 1183 "grep_single_original.c" 3 4
# 1183 "grep_single_original.c"
# 1183 "grep_single_original.c" 3 4
# 1183 "grep_single_original.c"
# 1194 "grep_single_original.c" 3 4
# 1194 "grep_single_original.c"
# 1194 "grep_single_original.c" 3 4
# 1194 "grep_single_original.c"
# 1212 "grep_single_original.c" 3 4
# 1212 "grep_single_original.c"
# 1272 "grep_single_original.c"
# 1272 "grep_single_original.c" 3 4
# 1272 "grep_single_original.c"
# 1288 "grep_single_original.c" 3 4
# 1288 "grep_single_original.c"
# 1297 "grep_single_original.c" 3 4
# 1297 "grep_single_original.c"
# 1395 "grep_single_original.c" 3 4
# 1395 "grep_single_original.c"
# 1397 "grep_single_original.c" 3 4
# 1397 "grep_single_original.c"
# 1409 "grep_single_original.c" 3 4
# 1409 "grep_single_original.c"
# 1528 "grep_single_original.c"
# 1534 "grep_single_original.c" 3 4
# 1534 "grep_single_original.c"
# 1540 "grep_single_original.c" 3 4
# 1540 "grep_single_original.c"
# 1542 "grep_single_original.c" 3 4
# 1542 "grep_single_original.c"
# 1542 "grep_single_original.c" 3 4
# 1542 "grep_single_original.c"
# 1543 "grep_single_original.c" 3 4
# 1543 "grep_single_original.c"
# 1574 "grep_single_original.c"
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
# 69 "/usr/include/assert.h" 3 4
# 1575 "grep_single_original.c" 2
# 1657 "grep_single_original.c"
# 1 "regex.h" 1
# 44 "regex.h"
# 44 "regex.h"
# 167 "regex.h"
# 283 "regex.h"
# 323 "regex.h"
# 368 "regex.h"
# 418 "regex.h"
# 444 "regex.h"
# 523 "regex.h"
# 539 "regex.h"
# 1658 "grep_single_original.c" 2
# 1 "dfa.h" 1
# 57 "dfa.h"
# 201 "dfa.h"
# 278 "dfa.h"
# 326 "dfa.h"
# 345 "dfa.h"
# 1659 "grep_single_original.c" 2
# 1668 "grep_single_original.c"
# 1802 "grep_single_original.c"
# 1943 "grep_single_original.c"
# 1943 "grep_single_original.c" 3 4
# 1943 "grep_single_original.c"
# 1943 "grep_single_original.c" 3 4
# 1943 "grep_single_original.c"
# 1944 "grep_single_original.c" 3 4
# 1944 "grep_single_original.c"
# 1944 "grep_single_original.c" 3 4
# 1944 "grep_single_original.c"
# 1945 "grep_single_original.c" 3 4
# 1945 "grep_single_original.c"
# 1945 "grep_single_original.c" 3 4
# 1945 "grep_single_original.c"
# 1946 "grep_single_original.c" 3 4
# 1946 "grep_single_original.c"
# 1946 "grep_single_original.c" 3 4
# 1946 "grep_single_original.c"
# 1947 "grep_single_original.c" 3 4
# 1947 "grep_single_original.c"
# 1947 "grep_single_original.c" 3 4
# 1947 "grep_single_original.c"
# 1948 "grep_single_original.c" 3 4
# 1948 "grep_single_original.c"
# 1948 "grep_single_original.c" 3 4
# 1948 "grep_single_original.c"
# 1949 "grep_single_original.c" 3 4
# 1949 "grep_single_original.c"
# 1949 "grep_single_original.c" 3 4
# 1949 "grep_single_original.c"
# 1950 "grep_single_original.c" 3 4
# 1950 "grep_single_original.c"
# 1950 "grep_single_original.c" 3 4
# 1950 "grep_single_original.c"
# 1951 "grep_single_original.c" 3 4
# 1951 "grep_single_original.c"
# 1951 "grep_single_original.c" 3 4
# 1951 "grep_single_original.c"
# 1952 "grep_single_original.c" 3 4
# 1952 "grep_single_original.c"
# 1952 "grep_single_original.c" 3 4
# 1952 "grep_single_original.c"
# 1953 "grep_single_original.c" 3 4
# 1953 "grep_single_original.c"
# 1953 "grep_single_original.c" 3 4
# 1953 "grep_single_original.c"
# 2137 "grep_single_original.c" 3 4
# 2137 "grep_single_original.c"
# 2137 "grep_single_original.c" 3 4
# 2137 "grep_single_original.c"
# 2141 "grep_single_original.c" 3 4
# 2141 "grep_single_original.c"
# 2141 "grep_single_original.c" 3 4
# 2141 "grep_single_original.c"
# 2166 "grep_single_original.c" 3 4
# 2166 "grep_single_original.c"
# 2166 "grep_single_original.c" 3 4
# 2166 "grep_single_original.c"
# 2172 "grep_single_original.c" 3 4
# 2172 "grep_single_original.c"
# 2172 "grep_single_original.c" 3 4
# 2172 "grep_single_original.c"
# 2186 "grep_single_original.c" 3 4
# 2186 "grep_single_original.c"
# 2186 "grep_single_original.c" 3 4
# 2186 "grep_single_original.c"
# 2194 "grep_single_original.c" 3 4
# 2194 "grep_single_original.c"
# 2194 "grep_single_original.c" 3 4
# 2194 "grep_single_original.c"
# 2265 "grep_single_original.c" 3 4
# 2265 "grep_single_original.c"
# 2265 "grep_single_original.c" 3 4
# 2265 "grep_single_original.c"
# 2337 "grep_single_original.c" 3 4
# 2337 "grep_single_original.c"
# 2337 "grep_single_original.c" 3 4
# 2337 "grep_single_original.c"
# 2339 "grep_single_original.c" 3 4
# 2339 "grep_single_original.c"
# 2339 "grep_single_original.c" 3 4
# 2339 "grep_single_original.c"
# 2359 "grep_single_original.c" 3 4
# 2359 "grep_single_original.c"
# 2359 "grep_single_original.c" 3 4
# 2359 "grep_single_original.c"
# 2363 "grep_single_original.c" 3 4
# 2363 "grep_single_original.c"
# 2363 "grep_single_original.c" 3 4
# 2363 "grep_single_original.c"
# 2450 "grep_single_original.c"
# 2886 "grep_single_original.c"
# 2916 "grep_single_original.c"
# 3069 "grep_single_original.c"
# 3084 "grep_single_original.c"
# 3149 "grep_single_original.c"
# 3182 "grep_single_original.c" 3 4
# 3182 "grep_single_original.c"
# 3182 "grep_single_original.c" 3 4
# 3182 "grep_single_original.c"
# 3315 "grep_single_original.c" 3 4
# 3315 "grep_single_original.c"
# 3315 "grep_single_original.c" 3 4
# 3315 "grep_single_original.c"
# 3374 "grep_single_original.c" 3 4
# 3374 "grep_single_original.c"
# 3374 "grep_single_original.c" 3 4
# 3374 "grep_single_original.c"
# 3394 "grep_single_original.c"
# 3412 "grep_single_original.c" 3 4
# 3412 "grep_single_original.c"
# 3417 "grep_single_original.c" 3 4
# 3417 "grep_single_original.c"
# 3456 "grep_single_original.c" 3 4
# 3456 "grep_single_original.c"
# 3457 "grep_single_original.c" 3 4
# 3457 "grep_single_original.c"
# 3499 "grep_single_original.c"
# 3522 "grep_single_original.c" 3 4
# 3522 "grep_single_original.c"
# 3522 "grep_single_original.c" 3 4
# 3522 "grep_single_original.c"
# 3565 "grep_single_original.c" 3 4
# 3565 "grep_single_original.c"
# 3624 "grep_single_original.c" 3 4
# 3624 "grep_single_original.c"
# 3624 "grep_single_original.c" 3 4
# 3624 "grep_single_original.c"
# 3761 "grep_single_original.c"
# 3769 "grep_single_original.c" 3 4
# 3769 "grep_single_original.c"
# 3770 "grep_single_original.c" 3 4
# 3770 "grep_single_original.c"
# 3775 "grep_single_original.c" 3 4
# 3775 "grep_single_original.c"
# 3779 "grep_single_original.c" 3 4
# 3779 "grep_single_original.c"
# 3779 "grep_single_original.c" 3 4
# 3779 "grep_single_original.c"
# 3788 "grep_single_original.c" 3 4
# 3788 "grep_single_original.c"
# 3803 "grep_single_original.c" 3 4
# 3803 "grep_single_original.c"
# 3810 "grep_single_original.c" 3 4
# 3810 "grep_single_original.c"
# 3820 "grep_single_original.c" 3 4
# 3820 "grep_single_original.c"
# 3822 "grep_single_original.c" 3 4
# 3822 "grep_single_original.c"
# 3825 "grep_single_original.c" 3 4
# 3825 "grep_single_original.c"
# 3837 "grep_single_original.c" 3 4
# 3837 "grep_single_original.c"
# 3838 "grep_single_original.c" 3 4
# 3838 "grep_single_original.c"
# 3839 "grep_single_original.c" 3 4
# 3839 "grep_single_original.c"
# 3842 "grep_single_original.c" 3 4
# 3842 "grep_single_original.c"
# 3846 "grep_single_original.c" 3 4
# 3846 "grep_single_original.c"
# 3847 "grep_single_original.c" 3 4
# 3847 "grep_single_original.c"
# 3854 "grep_single_original.c" 3 4
# 3854 "grep_single_original.c"
# 3855 "grep_single_original.c" 3 4
# 3855 "grep_single_original.c"
# 3863 "grep_single_original.c" 3 4
# 3863 "grep_single_original.c"
# 3867 "grep_single_original.c" 3 4
# 3867 "grep_single_original.c"
# 3868 "grep_single_original.c" 3 4
# 3868 "grep_single_original.c"
# 3870 "grep_single_original.c" 3 4
# 3870 "grep_single_original.c"
# 3887 "grep_single_original.c" 3 4
# 3887 "grep_single_original.c"
# 3887 "grep_single_original.c" 3 4
# 3887 "grep_single_original.c"
# 3888 "grep_single_original.c" 3 4
# 3888 "grep_single_original.c"
# 3890 "grep_single_original.c" 3 4
# 3890 "grep_single_original.c"
# 3891 "grep_single_original.c" 3 4
# 3891 "grep_single_original.c"
# 3892 "grep_single_original.c" 3 4
# 3892 "grep_single_original.c"
# 3897 "grep_single_original.c" 3 4
# 3897 "grep_single_original.c"
# 3907 "grep_single_original.c" 3 4
# 3907 "grep_single_original.c"
# 3920 "grep_single_original.c" 3 4
# 3920 "grep_single_original.c"
# 3920 "grep_single_original.c" 3 4
# 3920 "grep_single_original.c"
# 3921 "grep_single_original.c" 3 4
# 3921 "grep_single_original.c"
# 3922 "grep_single_original.c" 3 4
# 3922 "grep_single_original.c"
# 3925 "grep_single_original.c" 3 4
# 3925 "grep_single_original.c"
# 3942 "grep_single_original.c" 3 4
# 3942 "grep_single_original.c"
# 3942 "grep_single_original.c" 3 4
# 3942 "grep_single_original.c"
# 3943 "grep_single_original.c" 3 4
# 3943 "grep_single_original.c"
# 3945 "grep_single_original.c" 3 4
# 3945 "grep_single_original.c"
# 3946 "grep_single_original.c" 3 4
# 3946 "grep_single_original.c"
# 3947 "grep_single_original.c" 3 4
# 3947 "grep_single_original.c"
# 3948 "grep_single_original.c" 3 4
# 3948 "grep_single_original.c"
# 3950 "grep_single_original.c" 3 4
# 3950 "grep_single_original.c"
# 3953 "grep_single_original.c" 3 4
# 3953 "grep_single_original.c"
# 3956 "grep_single_original.c" 3 4
# 3956 "grep_single_original.c"
# 3961 "grep_single_original.c" 3 4
# 3961 "grep_single_original.c"
# 3962 "grep_single_original.c" 3 4
# 3962 "grep_single_original.c"
# 4002 "grep_single_original.c" 3 4
# 4002 "grep_single_original.c"
# 4013 "grep_single_original.c" 3 4
# 4013 "grep_single_original.c"
# 4013 "grep_single_original.c" 3 4
# 4013 "grep_single_original.c"
# 4014 "grep_single_original.c" 3 4
# 4014 "grep_single_original.c"
# 4014 "grep_single_original.c" 3 4
# 4014 "grep_single_original.c"
# 4017 "grep_single_original.c" 3 4
# 4017 "grep_single_original.c"
# 4028 "grep_single_original.c"
# 4085 "grep_single_original.c" 3 4
# 4085 "grep_single_original.c"
# 4101 "grep_single_original.c" 3 4
# 4101 "grep_single_original.c"
# 4120 "grep_single_original.c" 3 4
# 4120 "grep_single_original.c"
# 4128 "grep_single_original.c" 3 4
# 4128 "grep_single_original.c"
# 4131 "grep_single_original.c" 3 4
# 4131 "grep_single_original.c"
# 4136 "grep_single_original.c" 3 4
# 4136 "grep_single_original.c"
# 4144 "grep_single_original.c" 3 4
# 4144 "grep_single_original.c"
# 4151 "grep_single_original.c" 3 4
# 4151 "grep_single_original.c"
# 4157 "grep_single_original.c" 3 4
# 4157 "grep_single_original.c"
# 4187 "grep_single_original.c" 3 4
# 4187 "grep_single_original.c"
# 4202 "grep_single_original.c"
# 4263 "grep_single_original.c"
# 1 "kwset.h" 1
# 23 "kwset.h"
# 4264 "grep_single_original.c" 2
# 1 "obstack.h" 1
# 161 "obstack.h"
# 223 "obstack.h"
# 267 "obstack.h"
# 4265 "grep_single_original.c" 2
# 4277 "grep_single_original.c"
# 4307 "grep_single_original.c" 3 4
# 4307 "grep_single_original.c"
# 4308 "grep_single_original.c" 3 4
# 4308 "grep_single_original.c"
# 4631 "grep_single_original.c" 3 4
# 4631 "grep_single_original.c"
# 4632 "grep_single_original.c" 3 4
# 4632 "grep_single_original.c"
# 4640 "grep_single_original.c" 3 4
# 4640 "grep_single_original.c"
# 4643 "grep_single_original.c" 3 4
# 4643 "grep_single_original.c"
# 4716 "grep_single_original.c" 3 4
# 4716 "grep_single_original.c"
# 4721 "grep_single_original.c" 3 4
# 4721 "grep_single_original.c"
# 4724 "grep_single_original.c" 3 4
# 4724 "grep_single_original.c"
# 4730 "grep_single_original.c" 3 4
# 4730 "grep_single_original.c"
# 4733 "grep_single_original.c" 3 4
# 4733 "grep_single_original.c"
# 4993 "grep_single_original.c"
# 5077 "grep_single_original.c"
# 1 "/usr/include/gnu-versions.h" 1 3 4
# 5078 "grep_single_original.c" 2
# 5693 "grep_single_original.c"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 5694 "grep_single_original.c" 2
# 5922 "grep_single_original.c"
# 5937 "grep_single_original.c" 3 4
# 5937 "grep_single_original.c"
# 5937 "grep_single_original.c" 3 4
# 5937 "grep_single_original.c"
# 6053 "grep_single_original.c"
# 6101 "grep_single_original.c"
# 6110 "grep_single_original.c"
# 6154 "grep_single_original.c"
# 6201 "grep_single_original.c"
# 6658 "grep_single_original.c"
# 6668 "grep_single_original.c"
# 6692 "grep_single_original.c"
# 6798 "grep_single_original.c"
# 7131 "grep_single_original.c"
# 7173 "grep_single_original.c"
# 7344 "grep_single_original.c"
# 7480 "grep_single_original.c"
# 7506 "grep_single_original.c"
# 7575 "grep_single_original.c"
# 7576 "grep_single_original.c" 3 4
# 7576 "grep_single_original.c"
# 7634 "grep_single_original.c" 3 4
# 7634 "grep_single_original.c"
# 7649 "grep_single_original.c" 3 4
# 7649 "grep_single_original.c"
# 7739 "grep_single_original.c"
# 7742 "grep_single_original.c" 3 4
# 7742 "grep_single_original.c"
# 7767 "grep_single_original.c" 3 4
# 7767 "grep_single_original.c"
# 7781 "grep_single_original.c" 3 4
# 7781 "grep_single_original.c"
# 7791 "grep_single_original.c" 3 4
# 7791 "grep_single_original.c"
# 7803 "grep_single_original.c" 3 4
# 7803 "grep_single_original.c"
# 7809 "grep_single_original.c" 3 4
# 7809 "grep_single_original.c"
# 7817 "grep_single_original.c" 3 4
# 7817 "grep_single_original.c"
# 7944 "grep_single_original.c"
# 7971 "grep_single_original.c" 3 4
# 7971 "grep_single_original.c"
# 7971 "grep_single_original.c" 3 4
# 7971 "grep_single_original.c"
# 7972 "grep_single_original.c" 3 4
# 7972 "grep_single_original.c"
# 7972 "grep_single_original.c" 3 4
# 7972 "grep_single_original.c"
# 7973 "grep_single_original.c" 3 4
# 7973 "grep_single_original.c"
# 7973 "grep_single_original.c" 3 4
# 7973 "grep_single_original.c"
# 7974 "grep_single_original.c" 3 4
# 7974 "grep_single_original.c"
# 7974 "grep_single_original.c" 3 4
# 7974 "grep_single_original.c"
# 7976 "grep_single_original.c" 3 4
# 7976 "grep_single_original.c"
# 7976 "grep_single_original.c" 3 4
# 7976 "grep_single_original.c"
# 7977 "grep_single_original.c" 3 4
# 7977 "grep_single_original.c"
# 7977 "grep_single_original.c" 3 4
# 7977 "grep_single_original.c"
# 7978 "grep_single_original.c" 3 4
# 7978 "grep_single_original.c"
# 7978 "grep_single_original.c" 3 4
# 7978 "grep_single_original.c"
# 7979 "grep_single_original.c" 3 4
# 7979 "grep_single_original.c"
# 7979 "grep_single_original.c" 3 4
# 7979 "grep_single_original.c"
# 7981 "grep_single_original.c" 3 4
# 7981 "grep_single_original.c"
# 7981 "grep_single_original.c" 3 4
# 7981 "grep_single_original.c"
# 7982 "grep_single_original.c" 3 4
# 7982 "grep_single_original.c"
# 7982 "grep_single_original.c" 3 4
# 7982 "grep_single_original.c"
# 7983 "grep_single_original.c" 3 4
# 7983 "grep_single_original.c"
# 7983 "grep_single_original.c" 3 4
# 7983 "grep_single_original.c"
# 7984 "grep_single_original.c" 3 4
# 7984 "grep_single_original.c"
# 7984 "grep_single_original.c" 3 4
# 7984 "grep_single_original.c"
# 7987 "grep_single_original.c" 3 4
# 7987 "grep_single_original.c"
# 7987 "grep_single_original.c" 3 4
# 7987 "grep_single_original.c"
# 7987 "grep_single_original.c" 3 4
# 7987 "grep_single_original.c"
# 7987 "grep_single_original.c" 3 4
# 7987 "grep_single_original.c"
# 8076 "grep_single_original.c" 3 4
# 8076 "grep_single_original.c"
# 8098 "grep_single_original.c" 3 4
# 8098 "grep_single_original.c"
# 8130 "grep_single_original.c" 3 4
# 8130 "grep_single_original.c"
# 8176 "grep_single_original.c" 3 4
# 8176 "grep_single_original.c"
# 8192 "grep_single_original.c" 3 4
# 8192 "grep_single_original.c"
# 8213 "grep_single_original.c"
# 8220 "grep_single_original.c" 3 4
# 8220 "grep_single_original.c"
# 8254 "grep_single_original.c" 3 4
# 8254 "grep_single_original.c"
# 8254 "grep_single_original.c" 3 4
# 8254 "grep_single_original.c"
# 8258 "grep_single_original.c" 3 4
# 8258 "grep_single_original.c"
# 8258 "grep_single_original.c" 3 4
# 8258 "grep_single_original.c"
# 8307 "grep_single_original.c" 3 4
# 8307 "grep_single_original.c"
# 8321 "grep_single_original.c"
# 8326 "grep_single_original.c" 3 4
# 8326 "grep_single_original.c"
# 8371 "grep_single_original.c"
# 8377 "grep_single_original.c" 3 4
# 8377 "grep_single_original.c"
# 8385 "grep_single_original.c" 3 4
# 8385 "grep_single_original.c"
# 8418 "grep_single_original.c"
# 8422 "grep_single_original.c" 3 4
# 8422 "grep_single_original.c"
# 8430 "grep_single_original.c" 3 4
# 8430 "grep_single_original.c"
# 8437 "grep_single_original.c" 3 4
# 8437 "grep_single_original.c"
# 8443 "grep_single_original.c" 3 4
# 8443 "grep_single_original.c"
# 8449 "grep_single_original.c" 3 4
# 8449 "grep_single_original.c"
# 8455 "grep_single_original.c" 3 4
# 8455 "grep_single_original.c"
# 8461 "grep_single_original.c" 3 4
# 8461 "grep_single_original.c"
# 8467 "grep_single_original.c" 3 4
# 8467 "grep_single_original.c"
# 8485 "grep_single_original.c" 3 4
# 8485 "grep_single_original.c"
# 8533 "grep_single_original.c" 3 4
# 8533 "grep_single_original.c"
# 8537 "grep_single_original.c" 3 4
# 8537 "grep_single_original.c"
# 8555 "grep_single_original.c" 3 4
# 8555 "grep_single_original.c"
# 8611 "grep_single_original.c"
# 8755 "grep_single_original.c"
# 8778 "grep_single_original.c"
# 8814 "grep_single_original.c"
# 8841 "grep_single_original.c"
# 8848 "grep_single_original.c" 3 4
# 8848 "grep_single_original.c"
# 8848 "grep_single_original.c" 3 4
# 8848 "grep_single_original.c"
# 8848 "grep_single_original.c" 3 4
# 8848 "grep_single_original.c"
# 8978 "grep_single_original.c"
# 9035 "grep_single_original.c"
# 9037 "grep_single_original.c" 3 4
# 9037 "grep_single_original.c"
# 9037 "grep_single_original.c" 3 4
# 9037 "grep_single_original.c"
# 9037 "grep_single_original.c" 3 4
# 9037 "grep_single_original.c"
# 9120 "grep_single_original.c"
# 9150 "grep_single_original.c"
# 9157 "grep_single_original.c" 3 4
# 9157 "grep_single_original.c"
# 9186 "grep_single_original.c"
# 9240 "grep_single_original.c"
# 9411 "grep_single_original.c"
# 9418 "grep_single_original.c" 3 4
# 9418 "grep_single_original.c"
# 9457 "grep_single_original.c"
# 9525 "grep_single_original.c"
# 9541 "grep_single_original.c"
# 9555 "grep_single_original.c"
# 9564 "grep_single_original.c"
# 9574 "grep_single_original.c"
# 9594 "grep_single_original.c"
# 9594 "grep_single_original.c" 3 4
# 9594 "grep_single_original.c"
# 9612 "grep_single_original.c" 3 4
# 9612 "grep_single_original.c"
# 9612 "grep_single_original.c" 3 4
# 9612 "grep_single_original.c"
# 9612 "grep_single_original.c" 3 4
# 9612 "grep_single_original.c"
# 9622 "grep_single_original.c" 3 4
# 9622 "grep_single_original.c"
# 9622 "grep_single_original.c" 3 4
# 9622 "grep_single_original.c"
# 9623 "grep_single_original.c" 3 4
# 9623 "grep_single_original.c"
# 9623 "grep_single_original.c" 3 4
# 9623 "grep_single_original.c"
# 9624 "grep_single_original.c" 3 4
# 9624 "grep_single_original.c"
# 9624 "grep_single_original.c" 3 4
# 9624 "grep_single_original.c"
# 9625 "grep_single_original.c" 3 4
# 9625 "grep_single_original.c"
# 9625 "grep_single_original.c" 3 4
# 9625 "grep_single_original.c"
# 9626 "grep_single_original.c" 3 4
# 9626 "grep_single_original.c"
# 9626 "grep_single_original.c" 3 4
# 9626 "grep_single_original.c"
# 9627 "grep_single_original.c" 3 4
# 9627 "grep_single_original.c"
# 9627 "grep_single_original.c" 3 4
# 9627 "grep_single_original.c"
# 9628 "grep_single_original.c" 3 4
# 9628 "grep_single_original.c"
# 9628 "grep_single_original.c" 3 4
# 9628 "grep_single_original.c"
# 9629 "grep_single_original.c" 3 4
# 9629 "grep_single_original.c"
# 9629 "grep_single_original.c" 3 4
# 9629 "grep_single_original.c"
# 9630 "grep_single_original.c" 3 4
# 9630 "grep_single_original.c"
# 9630 "grep_single_original.c" 3 4
# 9630 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9635 "grep_single_original.c" 3 4
# 9635 "grep_single_original.c"
# 9644 "grep_single_original.c" 3 4
# 9644 "grep_single_original.c"
# 9645 "grep_single_original.c" 3 4
# 9645 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9652 "grep_single_original.c" 3 4
# 9652 "grep_single_original.c"
# 9672 "grep_single_original.c" 3 4
# 9672 "grep_single_original.c"
# 9811 "grep_single_original.c" 3 4
# 9811 "grep_single_original.c"
# 9811 "grep_single_original.c" 3 4
# 9811 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9813 "grep_single_original.c" 3 4
# 9813 "grep_single_original.c"
# 9827 "grep_single_original.c" 3 4
# 9827 "grep_single_original.c"
# 9827 "grep_single_original.c" 3 4
# 9827 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9829 "grep_single_original.c" 3 4
# 9829 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 9888 "grep_single_original.c" 3 4
# 9888 "grep_single_original.c"
# 10080 "grep_single_original.c"
# 10138 "grep_single_original.c"
# 10157 "grep_single_original.c" 3 4
# 10157 "grep_single_original.c"
# 10157 "grep_single_original.c" 3 4
# 10157 "grep_single_original.c"
# 10157 "grep_single_original.c" 3 4
# 10157 "grep_single_original.c"
# 10301 "grep_single_original.c"
# 10311 "grep_single_original.c" 3 4
# 10311 "grep_single_original.c"
# 10311 "grep_single_original.c" 3 4
# 10311 "grep_single_original.c"
# 10311 "grep_single_original.c" 3 4
# 10311 "grep_single_original.c"
# 10311 "grep_single_original.c" 3 4
# 10311 "grep_single_original.c"
# 10327 "grep_single_original.c"
# 10347 "grep_single_original.c"
# 10368 "grep_single_original.c" 3 4
# 10368 "grep_single_original.c"
# 10368 "grep_single_original.c" 3 4
# 10368 "grep_single_original.c"
# 10368 "grep_single_original.c" 3 4
# 10368 "grep_single_original.c"
# 10397 "grep_single_original.c"
# 10522 "grep_single_original.c"
# 10534 "grep_single_original.c" 3 4
# 10534 "grep_single_original.c"
# 10577 "grep_single_original.c" 3 4
# 10577 "grep_single_original.c"
# 10577 "grep_single_original.c" 3 4
# 10577 "grep_single_original.c"
# 10577 "grep_single_original.c" 3 4
# 10577 "grep_single_original.c"
# 10577 "grep_single_original.c" 3 4
# 10577 "grep_single_original.c"
# 10577 "grep_single_original.c" 3 4
# 10577 "grep_single_original.c"
# 10590 "grep_single_original.c" 3 4
# 10590 "grep_single_original.c"
# 10590 "grep_single_original.c" 3 4
# 10590 "grep_single_original.c"
# 10590 "grep_single_original.c" 3 4
# 10590 "grep_single_original.c"
# 10590 "grep_single_original.c" 3 4
# 10590 "grep_single_original.c"
# 10590 "grep_single_original.c" 3 4
# 10590 "grep_single_original.c"
# 10680 "grep_single_original.c"
# 10778 "grep_single_original.c"
# 10808 "grep_single_original.c" 3 4
# 10808 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10855 "grep_single_original.c" 3 4
# 10855 "grep_single_original.c"
# 10873 "grep_single_original.c"
# 10918 "grep_single_original.c"
# 11134 "grep_single_original.c"
# 11157 "grep_single_original.c" 3 4
# 11157 "grep_single_original.c"
# 11272 "grep_single_original.c"
# 11298 "grep_single_original.c" 3 4
# 11298 "grep_single_original.c"
# 11303 "grep_single_original.c" 3 4
# 11303 "grep_single_original.c"
# 11303 "grep_single_original.c" 3 4
# 11303 "grep_single_original.c"
# 11306 "grep_single_original.c" 3 4
# 11306 "grep_single_original.c"
# 11338 "grep_single_original.c" 3 4
# 11338 "grep_single_original.c"
# 11363 "grep_single_original.c"
# 11391 "grep_single_original.c" 3 4
# 11391 "grep_single_original.c"
# 11430 "grep_single_original.c"
# 11481 "grep_single_original.c" 3 4
# 11481 "grep_single_original.c"
# 11483 "grep_single_original.c" 3 4
# 11483 "grep_single_original.c"
# 11488 "grep_single_original.c" 3 4
# 11488 "grep_single_original.c"
# 11490 "grep_single_original.c" 3 4
# 11490 "grep_single_original.c"
# 11493 "grep_single_original.c" 3 4
# 11493 "grep_single_original.c"
# 11495 "grep_single_original.c" 3 4
# 11495 "grep_single_original.c"
# 11536 "grep_single_original.c"
# 1 "/usr/include/dirent.h" 1 3 4
# 27 "/usr/include/dirent.h" 3 4
# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
# 62 "/usr/include/dirent.h" 2 3 4
# 97 "/usr/include/dirent.h" 3 4
# 127 "/usr/include/dirent.h" 3 4
# 162 "/usr/include/dirent.h" 3 4
# 183 "/usr/include/dirent.h" 3 4
# 208 "/usr/include/dirent.h" 3 4
# 244 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 245 "/usr/include/dirent.h" 2 3 4
# 254 "/usr/include/dirent.h" 3 4
# 324 "/usr/include/dirent.h" 3 4
# 352 "/usr/include/dirent.h" 3 4
# 401 "/usr/include/dirent.h" 3 4
# 11537 "grep_single_original.c" 2
# 11577 "grep_single_original.c"
# 11577 "grep_single_original.c"
# 11589 "grep_single_original.c"
# 11600 "grep_single_original.c" 3 4
# 11600 "grep_single_original.c"
# 11601 "grep_single_original.c" 3 4
# 11601 "grep_single_original.c"
# 11604 "grep_single_original.c" 3 4
# 11604 "grep_single_original.c"
# 11607 "grep_single_original.c" 3 4
# 11607 "grep_single_original.c"
# 11611 "grep_single_original.c" 3 4
# 11611 "grep_single_original.c"
# 11628 "grep_single_original.c" 3 4
# 11628 "grep_single_original.c"
# 11631 "grep_single_original.c" 3 4
# 11631 "grep_single_original.c"
# 11643 "grep_single_original.c" 3 4
# 11643 "grep_single_original.c"
# 12901 "grep_single_original.c"
# 12947 "grep_single_original.c" 3 4
# 12947 "grep_single_original.c"
# 12951 "grep_single_original.c" 3 4
# 12951 "grep_single_original.c"
# 12952 "grep_single_original.c" 3 4
# 12952 "grep_single_original.c"
# 12952 "grep_single_original.c" 3 4
# 12952 "grep_single_original.c"
# 13195 "grep_single_original.c" 3 4
# 13195 "grep_single_original.c"
# 13195 "grep_single_original.c" 3 4
# 13195 "grep_single_original.c"
# 13197 "grep_single_original.c" 3 4
# 13197 "grep_single_original.c"
# 13197 "grep_single_original.c" 3 4
# 13197 "grep_single_original.c"
# 13281 "grep_single_original.c" 3 4
# 13281 "grep_single_original.c"
# 13281 "grep_single_original.c" 3 4
# 13281 "grep_single_original.c"
# 13283 "grep_single_original.c" 3 4
# 13283 "grep_single_original.c"
# 13283 "grep_single_original.c" 3 4
# 13283 "grep_single_original.c"
# 13315 "grep_single_original.c"
# 1524 "grep_single.c"






























typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;



typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void * __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;

typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino_t ino_t;

typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __off_t off_t;

typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;



typedef __clock_t clock_t;

typedef __time_t time_t;

typedef __clockid_t clockid_t;

typedef __timer_t timer_t;




typedef long unsigned int size_t;

typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;

typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
typedef int register_t __attribute__ ((__mode__ (__word__)));













static __inline unsigned int __bswap_32 (unsigned int __bsx) {


return __builtin_bswap32 (__bsx);
}

static __inline __uint64_t __bswap_64 (__uint64_t __bsx) {


return __builtin_bswap64 (__bsx);
}











typedef int __sig_atomic_t;
typedef struct {

unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;

typedef __sigset_t sigset_t;


struct timespec {

__time_t tv_sec;
__syscall_slong_t tv_nsec;
};



struct timeval {

__time_t tv_sec;
__suseconds_t tv_usec;
};

typedef __suseconds_t suseconds_t;
typedef long int __fd_mask;

typedef struct {

__fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
} fd_set;
typedef __fd_mask fd_mask;


extern int select (int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);

extern int pselect (int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);




__extension__ extern unsigned int gnu_dev_major (unsigned long long int __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


__extension__ extern unsigned int gnu_dev_minor (unsigned long long int __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


__extension__ extern unsigned long long int gnu_dev_makedev (unsigned int __major, unsigned int __minor) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;






typedef unsigned long int pthread_t;
union pthread_attr_t {

char __size[56];
long int __align;
};
typedef union pthread_attr_t pthread_attr_t;
typedef struct __pthread_internal_list {

struct __pthread_internal_list *__prev;
struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef union {

struct __pthread_mutex_s {

int __lock;
unsigned int __count;
int __owner;
unsigned int __nusers;
int __kind;
short __spins;
short __elision;
__pthread_list_t __list;

} __data;
char __size[40];
long int __align;
} pthread_mutex_t;
typedef union {

char __size[4];
int __align;
} pthread_mutexattr_t;
typedef union {

struct {

int __lock;
unsigned int __futex;
__extension__ unsigned long long int __total_seq;
__extension__ unsigned long long int __wakeup_seq;
__extension__ unsigned long long int __woken_seq;
void *__mutex;
unsigned int __nwaiters;
unsigned int __broadcast_seq;
} __data;
char __size[48];
__extension__ long long int __align;
} pthread_cond_t;
typedef union {

char __size[4];
int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef union {

struct {

int __lock;
unsigned int __nr_readers;
unsigned int __readers_wakeup;
unsigned int __writer_wakeup;
unsigned int __nr_readers_queued;
unsigned int __nr_writers_queued;
int __writer;
int __shared;
signed char __rwelision;
unsigned char __pad1[7];
unsigned long int __pad2;
unsigned int __flags;
} __data;

char __size[56];
long int __align;
} pthread_rwlock_t;
typedef union {

char __size[8];
long int __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {

char __size[32];
long int __align;
} pthread_barrier_t;
typedef union {

char __size[4];
int __align;
} pthread_barrierattr_t;









struct stat {

__dev_t st_dev;
__ino_t st_ino;
__nlink_t st_nlink;
__mode_t st_mode;
__uid_t st_uid;
__gid_t st_gid;
int __pad0;
__dev_t st_rdev;
__off_t st_size;
__blksize_t st_blksize;
__blkcnt_t st_blocks;

struct timespec st_atim;
struct timespec st_mtim;
struct timespec st_ctim;

__syscall_slong_t __glibc_reserved[3];

};


extern int stat (const char *__restrict __file, struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int fstatat (int __fd, const char *__restrict __file, struct stat *__restrict __buf, int __flag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));



extern int lstat (const char *__restrict __file, struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int chmod (const char *__file, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int lchmod (const char *__file, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));
extern int fchmodat (int __fd, const char *__file, __mode_t __mode, int __flag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;


extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));

extern int mkdir (const char *__path, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int mkdirat (int __fd, const char *__path, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int mkfifo (const char *__path, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int mkfifoat (int __fd, const char *__path, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int utimensat (int __fd, const char *__path, const struct timespec __times[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));

extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int __xstat (int __ver, const char *__filename, struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename, struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename, struct stat *__stat_buf, int __flag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));



extern int __xmknod (int __ver, const char *__path, __mode_t __mode, __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
extern int __xmknodat (int __ver, int __fd, const char *__path, __mode_t __mode, __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));















extern void *mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset) __attribute__ ((__nothrow__ , __leaf__));

extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));
extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ , __leaf__));
extern int msync (void *__addr, size_t __len, int __flags);
extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));
extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));
extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));
extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));
extern int mlockall (int __flags) __attribute__ ((__nothrow__ , __leaf__));
extern int munlockall (void) __attribute__ ((__nothrow__ , __leaf__));
extern int mincore (void *__start, size_t __len, unsigned char *__vec) __attribute__ ((__nothrow__ , __leaf__));


extern int shm_open (const char *__name, int __oflag, mode_t __mode);
extern int shm_unlink (const char *__name);






struct _IO_FILE;
typedef struct _IO_FILE FILE;

typedef struct _IO_FILE __FILE;









typedef struct {

int __count;
union {

unsigned int __wch;
char __wchb[4];
} __value;
} __mbstate_t;

typedef struct {

__off_t __pos;
__mbstate_t __state;
} _G_fpos_t;
typedef struct {

__off64_t __pos;
__mbstate_t __state;
} _G_fpos64_t;




typedef __builtin_va_list __gnuc_va_list;


struct _IO_jump_t; struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
struct _IO_marker *_next;
struct _IO_FILE *_sbuf;
int _pos;

};
enum __codecvt_result {

__codecvt_ok, __codecvt_partial, __codecvt_error, __codecvt_noconv };





struct _IO_FILE {
int _flags;
char* _IO_read_ptr;
char* _IO_read_end;
char* _IO_read_base;
char* _IO_write_base;
char* _IO_write_ptr;
char* _IO_write_end;
char* _IO_buf_base;
char* _IO_buf_end;
char *_IO_save_base;
char *_IO_backup_base;
char *_IO_save_end;
struct _IO_marker *_markers;
struct _IO_FILE *_chain;
int _fileno;
int _flags2;
__off_t _old_offset;
unsigned short _cur_column;
signed char _vtable_offset;
char _shortbuf[1];
_IO_lock_t *_lock;

__off64_t _offset;
void *__pad1;
void *__pad2;
void *__pad3;
void *__pad4;
size_t __pad5;
int _mode;
char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
typedef struct _IO_FILE _IO_FILE;
struct _IO_FILE_plus;
extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;

typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);
typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf, size_t __n);
typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);
typedef int __io_close_fn (void *__cookie);

extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);

extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_peekc_locked (_IO_FILE *__fp);
extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict, __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict, __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);
extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);
extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));

typedef __gnuc_va_list va_list;

typedef _G_fpos_t fpos_t;



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern int renameat (int __oldfd, const char *__old, int __newfd, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern FILE *tmpfile (void) ;

extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;

extern char *tempnam (const char *__dir, const char *__pfx) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern int fclose (FILE *__stream);
extern int fflush (FILE *__stream);

extern int fflush_unlocked (FILE *__stream);

extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) ;
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) ;


extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;

extern FILE *fmemopen (void *__s, size_t __len, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;

extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__));
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int fprintf (FILE *__restrict __stream, const char *__restrict __format, ...);
extern int printf (const char *__restrict __format, ...);
extern int sprintf (char *__restrict __s, const char *__restrict __format, ...) __attribute__ ((__nothrow__));
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg);
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf (char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__ ((__nothrow__));
extern int snprintf (char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));


extern int vsnprintf (char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));



extern int vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__ ((__format__ (__printf__, 2, 0)));


extern int dprintf (int __fd, const char *__restrict __fmt, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) ;
extern int scanf (const char *__restrict __format, ...) ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));

extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") ;

extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__)) ;


extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__ ((__format__ (__scanf__, 2, 0))) ;


extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __attribute__ ((__format__ (__scanf__, 1, 0))) ;

extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));



extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf") __attribute__ ((__format__ (__scanf__, 2, 0))) ;

extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf") __attribute__ ((__format__ (__scanf__, 1, 0))) ;

extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));


extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);
extern int getchar (void);

extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);

extern int fgetc_unlocked (FILE *__stream);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);
extern int putchar (int __c);

extern int fputc_unlocked (int __c, FILE *__stream);
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
extern int getw (FILE *__stream);
extern int putw (int __w, FILE *__stream);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream) ;



extern __ssize_t __getdelim (char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream) ;
extern __ssize_t getline (char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream) ;
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
extern int puts (const char *__s);
extern int ungetc (int __c, FILE *__stream);
extern size_t fread (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite (const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);

extern size_t fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
extern int fseek (FILE *__stream, long int __off, int __whence);
extern long int ftell (FILE *__stream) ;
extern void rewind (FILE *__stream);

extern int fseeko (FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello (FILE *__stream) ;

extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
extern int fsetpos (FILE *__stream, const fpos_t *__pos);


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void perror (const char *__s);


extern int sys_nerr;
extern const char *const sys_errlist[];

extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern FILE *popen (const char *__command, const char *__modes) ;
extern int pclose (FILE *__stream);
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));

extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));





typedef void * ptr_t;






struct flock {

short int l_type;
short int l_whence;
__off_t l_start;
__off_t l_len;
__pid_t l_pid;
};












extern int fcntl (int __fd, int __cmd, ...);

extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));

extern int openat (int __fd, const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (2)));


extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));

extern int lockf (int __fd, int __cmd, off_t __len);

extern int posix_fadvise (int __fd, off_t __offset, off_t __len, int __advise) __attribute__ ((__nothrow__ , __leaf__));

extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
















typedef __useconds_t useconds_t;

typedef __intptr_t intptr_t;
typedef __socklen_t socklen_t;

extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int faccessat (int __fd, const char *__file, int __type, int __flag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;


extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));

extern int close (int __fd);
extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;
extern ssize_t write (int __fd, const void *__buf, size_t __n) ;

extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset) ;
extern ssize_t pwrite (int __fd, const void *__buf, size_t __n, __off_t __offset) ;

extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;

extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));

extern unsigned int sleep (unsigned int __seconds);
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval) __attribute__ ((__nothrow__ , __leaf__));

extern int usleep (__useconds_t __useconds);

extern int pause (void);
extern int chown (const char *__file, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int lchown (const char *__file, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int fchownat (int __fd, const char *__file, __uid_t __owner, __gid_t __group, int __flag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;


extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;

extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;

extern char *getwd (char *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;

extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));

extern char **__environ;
extern int execve (const char *__path, char *const __argv[], char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fexecve (int __fd, char *const __argv[], char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int execv (const char *__path, char *const __argv[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int execle (const char *__path, const char *__arg, ...) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int execl (const char *__path, const char *__arg, ...) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int execvp (const char *__file, char *const __argv[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int execlp (const char *__file, const char *__arg, ...) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void _exit (int __status) __attribute__ ((__noreturn__));


enum {

_PC_LINK_MAX, _PC_MAX_CANON, _PC_MAX_INPUT, _PC_NAME_MAX, _PC_PATH_MAX, _PC_PIPE_BUF, _PC_CHOWN_RESTRICTED, _PC_NO_TRUNC, _PC_VDISABLE, _PC_SYNC_IO, _PC_ASYNC_IO, _PC_PRIO_IO, _PC_SOCK_MAXBUF, _PC_FILESIZEBITS, _PC_REC_INCR_XFER_SIZE, _PC_REC_MAX_XFER_SIZE, _PC_REC_MIN_XFER_SIZE, _PC_REC_XFER_ALIGN, _PC_ALLOC_SIZE_MIN, _PC_SYMLINK_MAX, _PC_2_SYMLINKS };





















enum {

_SC_ARG_MAX, _SC_CHILD_MAX, _SC_CLK_TCK, _SC_NGROUPS_MAX, _SC_OPEN_MAX, _SC_STREAM_MAX, _SC_TZNAME_MAX, _SC_JOB_CONTROL, _SC_SAVED_IDS, _SC_REALTIME_SIGNALS, _SC_PRIORITY_SCHEDULING, _SC_TIMERS, _SC_ASYNCHRONOUS_IO, _SC_PRIORITIZED_IO, _SC_SYNCHRONIZED_IO, _SC_FSYNC, _SC_MAPPED_FILES, _SC_MEMLOCK, _SC_MEMLOCK_RANGE, _SC_MEMORY_PROTECTION, _SC_MESSAGE_PASSING, _SC_SEMAPHORES, _SC_SHARED_MEMORY_OBJECTS, _SC_AIO_LISTIO_MAX, _SC_AIO_MAX, _SC_AIO_PRIO_DELTA_MAX, _SC_DELAYTIMER_MAX, _SC_MQ_OPEN_MAX, _SC_MQ_PRIO_MAX, _SC_VERSION, _SC_PAGESIZE, _SC_RTSIG_MAX, _SC_SEM_NSEMS_MAX, _SC_SEM_VALUE_MAX, _SC_SIGQUEUE_MAX, _SC_TIMER_MAX, _SC_BC_BASE_MAX, _SC_BC_DIM_MAX, _SC_BC_SCALE_MAX, _SC_BC_STRING_MAX, _SC_COLL_WEIGHTS_MAX, _SC_EQUIV_CLASS_MAX, _SC_EXPR_NEST_MAX, _SC_LINE_MAX, _SC_RE_DUP_MAX, _SC_CHARCLASS_NAME_MAX, _SC_2_VERSION, _SC_2_C_BIND, _SC_2_C_DEV, _SC_2_FORT_DEV, _SC_2_FORT_RUN, _SC_2_SW_DEV, _SC_2_LOCALEDEF, _SC_PII, _SC_PII_XTI, _SC_PII_SOCKET, _SC_PII_INTERNET, _SC_PII_OSI, _SC_POLL, _SC_SELECT, _SC_UIO_MAXIOV, _SC_IOV_MAX = _SC_UIO_MAXIOV, _SC_PII_INTERNET_STREAM, _SC_PII_INTERNET_DGRAM, _SC_PII_OSI_COTS, _SC_PII_OSI_CLTS, _SC_PII_OSI_M, _SC_T_IOV_MAX, _SC_THREADS, _SC_THREAD_SAFE_FUNCTIONS, _SC_GETGR_R_SIZE_MAX, _SC_GETPW_R_SIZE_MAX, _SC_LOGIN_NAME_MAX, _SC_TTY_NAME_MAX, _SC_THREAD_DESTRUCTOR_ITERATIONS, _SC_THREAD_KEYS_MAX, _SC_THREAD_STACK_MIN, _SC_THREAD_THREADS_MAX, _SC_THREAD_ATTR_STACKADDR, _SC_THREAD_ATTR_STACKSIZE, _SC_THREAD_PRIORITY_SCHEDULING, _SC_THREAD_PRIO_INHERIT, _SC_THREAD_PRIO_PROTECT, _SC_THREAD_PROCESS_SHARED, _SC_NPROCESSORS_CONF, _SC_NPROCESSORS_ONLN, _SC_PHYS_PAGES, _SC_AVPHYS_PAGES, _SC_ATEXIT_MAX, _SC_PASS_MAX, _SC_XOPEN_VERSION, _SC_XOPEN_XCU_VERSION, _SC_XOPEN_UNIX, _SC_XOPEN_CRYPT, _SC_XOPEN_ENH_I18N, _SC_XOPEN_SHM, _SC_2_CHAR_TERM, _SC_2_C_VERSION, _SC_2_UPE, _SC_XOPEN_XPG2, _SC_XOPEN_XPG3, _SC_XOPEN_XPG4, _SC_CHAR_BIT, _SC_CHAR_MAX, _SC_CHAR_MIN, _SC_INT_MAX, _SC_INT_MIN, _SC_LONG_BIT, _SC_WORD_BIT, _SC_MB_LEN_MAX, _SC_NZERO, _SC_SSIZE_MAX, _SC_SCHAR_MAX, _SC_SCHAR_MIN, _SC_SHRT_MAX, _SC_SHRT_MIN, _SC_UCHAR_MAX, _SC_UINT_MAX, _SC_ULONG_MAX, _SC_USHRT_MAX, _SC_NL_ARGMAX, _SC_NL_LANGMAX, _SC_NL_MSGMAX, _SC_NL_NMAX, _SC_NL_SETMAX, _SC_NL_TEXTMAX, _SC_XBS5_ILP32_OFF32, _SC_XBS5_ILP32_OFFBIG, _SC_XBS5_LP64_OFF64, _SC_XBS5_LPBIG_OFFBIG, _SC_XOPEN_LEGACY, _SC_XOPEN_REALTIME, _SC_XOPEN_REALTIME_THREADS, _SC_ADVISORY_INFO, _SC_BARRIERS, _SC_BASE, _SC_C_LANG_SUPPORT, _SC_C_LANG_SUPPORT_R, _SC_CLOCK_SELECTION, _SC_CPUTIME, _SC_THREAD_CPUTIME, _SC_DEVICE_IO, _SC_DEVICE_SPECIFIC, _SC_DEVICE_SPECIFIC_R, _SC_FD_MGMT, _SC_FIFO, _SC_PIPE, _SC_FILE_ATTRIBUTES, _SC_FILE_LOCKING, _SC_FILE_SYSTEM, _SC_MONOTONIC_CLOCK, _SC_MULTI_PROCESS, _SC_SINGLE_PROCESS, _SC_NETWORKING, _SC_READER_WRITER_LOCKS, _SC_SPIN_LOCKS, _SC_REGEXP, _SC_REGEX_VERSION, _SC_SHELL, _SC_SIGNALS, _SC_SPAWN, _SC_SPORADIC_SERVER, _SC_THREAD_SPORADIC_SERVER, _SC_SYSTEM_DATABASE, _SC_SYSTEM_DATABASE_R, _SC_TIMEOUTS, _SC_TYPED_MEMORY_OBJECTS, _SC_USER_GROUPS, _SC_USER_GROUPS_R, _SC_2_PBS, _SC_2_PBS_ACCOUNTING, _SC_2_PBS_LOCATE, _SC_2_PBS_MESSAGE, _SC_2_PBS_TRACK, _SC_SYMLOOP_MAX, _SC_STREAMS, _SC_2_PBS_CHECKPOINT, _SC_V6_ILP32_OFF32, _SC_V6_ILP32_OFFBIG, _SC_V6_LP64_OFF64, _SC_V6_LPBIG_OFFBIG, _SC_HOST_NAME_MAX, _SC_TRACE, _SC_TRACE_EVENT_FILTER, _SC_TRACE_INHERIT, _SC_TRACE_LOG, _SC_LEVEL1_ICACHE_SIZE, _SC_LEVEL1_ICACHE_ASSOC, _SC_LEVEL1_ICACHE_LINESIZE, _SC_LEVEL1_DCACHE_SIZE, _SC_LEVEL1_DCACHE_ASSOC, _SC_LEVEL1_DCACHE_LINESIZE, _SC_LEVEL2_CACHE_SIZE, _SC_LEVEL2_CACHE_ASSOC, _SC_LEVEL2_CACHE_LINESIZE, _SC_LEVEL3_CACHE_SIZE, _SC_LEVEL3_CACHE_ASSOC, _SC_LEVEL3_CACHE_LINESIZE, _SC_LEVEL4_CACHE_SIZE, _SC_LEVEL4_CACHE_ASSOC, _SC_LEVEL4_CACHE_LINESIZE, _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50, _SC_RAW_SOCKETS, _SC_V7_ILP32_OFF32, _SC_V7_ILP32_OFFBIG, _SC_V7_LP64_OFF64, _SC_V7_LPBIG_OFFBIG, _SC_SS_REPL_MAX, _SC_TRACE_EVENT_NAME_MAX, _SC_TRACE_NAME_MAX, _SC_TRACE_SYS_MAX, _SC_TRACE_USER_EVENT_MAX, _SC_XOPEN_STREAMS, _SC_THREAD_ROBUST_PRIO_INHERIT, _SC_THREAD_ROBUST_PRIO_PROTECT };























































































































































































































enum {

_CS_PATH, _CS_V6_WIDTH_RESTRICTED_ENVS, _CS_GNU_LIBC_VERSION, _CS_GNU_LIBPTHREAD_VERSION, _CS_V5_WIDTH_RESTRICTED_ENVS, _CS_V7_WIDTH_RESTRICTED_ENVS, _CS_LFS_CFLAGS = 1000, _CS_LFS_LDFLAGS, _CS_LFS_LIBS, _CS_LFS_LINTFLAGS, _CS_LFS64_CFLAGS, _CS_LFS64_LDFLAGS, _CS_LFS64_LIBS, _CS_LFS64_LINTFLAGS, _CS_XBS5_ILP32_OFF32_CFLAGS = 1100, _CS_XBS5_ILP32_OFF32_LDFLAGS, _CS_XBS5_ILP32_OFF32_LIBS, _CS_XBS5_ILP32_OFF32_LINTFLAGS, _CS_XBS5_ILP32_OFFBIG_CFLAGS, _CS_XBS5_ILP32_OFFBIG_LDFLAGS, _CS_XBS5_ILP32_OFFBIG_LIBS, _CS_XBS5_ILP32_OFFBIG_LINTFLAGS, _CS_XBS5_LP64_OFF64_CFLAGS, _CS_XBS5_LP64_OFF64_LDFLAGS, _CS_XBS5_LP64_OFF64_LIBS, _CS_XBS5_LP64_OFF64_LINTFLAGS, _CS_XBS5_LPBIG_OFFBIG_CFLAGS, _CS_XBS5_LPBIG_OFFBIG_LDFLAGS, _CS_XBS5_LPBIG_OFFBIG_LIBS, _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS, _CS_POSIX_V6_ILP32_OFF32_CFLAGS, _CS_POSIX_V6_ILP32_OFF32_LDFLAGS, _CS_POSIX_V6_ILP32_OFF32_LIBS, _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS, _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS, _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS, _CS_POSIX_V6_ILP32_OFFBIG_LIBS, _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS, _CS_POSIX_V6_LP64_OFF64_CFLAGS, _CS_POSIX_V6_LP64_OFF64_LDFLAGS, _CS_POSIX_V6_LP64_OFF64_LIBS, _CS_POSIX_V6_LP64_OFF64_LINTFLAGS, _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS, _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS, _CS_POSIX_V6_LPBIG_OFFBIG_LIBS, _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS, _CS_POSIX_V7_ILP32_OFF32_CFLAGS, _CS_POSIX_V7_ILP32_OFF32_LDFLAGS, _CS_POSIX_V7_ILP32_OFF32_LIBS, _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS, _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS, _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS, _CS_POSIX_V7_ILP32_OFFBIG_LIBS, _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS, _CS_POSIX_V7_LP64_OFF64_CFLAGS, _CS_POSIX_V7_LP64_OFF64_LDFLAGS, _CS_POSIX_V7_LP64_OFF64_LIBS, _CS_POSIX_V7_LP64_OFF64_LINTFLAGS, _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS, _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS, _CS_POSIX_V7_LPBIG_OFFBIG_LIBS, _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS, _CS_V6_ENV, _CS_V7_ENV };

































































extern long int pathconf (const char *__path, int __name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));
extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));
extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));
extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));

extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));
extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));
extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));
extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));
extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));
extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));
extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;

extern __pid_t fork (void) __attribute__ ((__nothrow__));
extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));
extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));
extern int ttyname_r (int __fd, char *__buf, size_t __buflen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;

extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));
extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));
extern int link (const char *__from, const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;

extern int linkat (int __fromfd, const char *__from, int __tofd, const char *__to, int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;


extern int symlink (const char *__from, const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;

extern ssize_t readlink (const char *__restrict __path, char *__restrict __buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;


extern int symlinkat (const char *__from, int __tofd, const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;
extern ssize_t readlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;


extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int unlinkat (int __fd, const char *__name, int __flag) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));
extern char *getlogin (void);
extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));
extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *optarg;

extern int optind;
extern int opterr;
extern int optopt;

struct option {

const char *name;
int has_arg;
int *flag;
int val;
};

extern int getopt (int argc, char *const *argv, const char *shortopts);
extern int getopt_long (int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
extern int _getopt_internal (int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind, int long_only);

extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int sethostname (const char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int getdomainname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int setdomainname (const char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));
extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int profil (unsigned short int *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));
extern int fsync (int __fd);

extern long int gethostid (void);
extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));
extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));

extern int truncate (const char *__file, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));

extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));

extern int fdatasync (int __fildes);















extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));








typedef int wchar_t;



typedef enum {

P_ALL, P_PID, P_PGID } idtype_t;






union wait {

int w_status;
struct {

unsigned int __w_termsig:7;
unsigned int __w_coredump:1;
unsigned int __w_retcode:8;
unsigned int:16;
} __wait_terminated;
struct {

unsigned int __w_stopval:8;
unsigned int __w_stopsig:8;
unsigned int:16;
} __wait_stopped;
};


typedef union {

union wait *__uptr;
int *__iptr;
} __WAIT_STATUS __attribute__ ((__transparent_union__));

typedef struct {

int quot;
int rem;
} div_t;
typedef struct {

long int quot;
long int rem;
} ldiv_t;
__extension__ typedef struct {

long long int quot;
long long int rem;
} lldiv_t;

extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;
extern double atof (const char *__nptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

__extension__ extern long long int atoll (const char *__nptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern double strtod (const char *__restrict __nptr, char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern float strtof (const char *__restrict __nptr, char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern long double strtold (const char *__restrict __nptr, char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int strtol (const char *__restrict __nptr, char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern unsigned long int strtoul (const char *__restrict __nptr, char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


__extension__ extern long long int strtoq (const char *__restrict __nptr, char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__ extern unsigned long long int strtouq (const char *__restrict __nptr, char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__ extern long long int strtoll (const char *__restrict __nptr, char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__ extern unsigned long long int strtoull (const char *__restrict __nptr, char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;
extern long int a64l (const char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;


extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));
extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));
extern char *initstate (unsigned int __seed, char *__statebuf, size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
struct random_data {

int32_t *fptr;
int32_t *rptr;
int32_t *state;
int rand_type;
int rand_deg;
int rand_sep;
int32_t *end_ptr;
};
extern int random_r (struct random_data *__restrict __buf, int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int srandom_r (unsigned int __seed, struct random_data *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));



extern int setstate_r (char *__restrict __statebuf, struct random_data *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));
extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));
extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));
extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
struct drand48_data {

unsigned short int __x[3];
unsigned short int __old_x[3];
unsigned short int __c;
unsigned short int __init;
__extension__ unsigned long long int __a;
};
extern int drand48_r (struct drand48_data *__restrict __buffer, double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int lrand48_r (struct drand48_data *__restrict __buffer, long int *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int nrand48_r (unsigned short int __xsubi[3], struct drand48_data *__restrict __buffer, long int *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int mrand48_r (struct drand48_data *__restrict __buffer, long int *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int jrand48_r (unsigned short int __xsubi[3], struct drand48_data *__restrict __buffer, long int *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int srand48_r (long int __seedval, struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3], struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int lcong48_r (unsigned short int __param[7], struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
extern void *calloc (size_t __nmemb, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *realloc (void *__ptr, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));
extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));

extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern void *aligned_alloc (size_t __alignment, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;

extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int setenv (const char *__name, const char *__value, int __replace) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));

extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;

extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;

extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int system (const char *__command) ;

extern char *realpath (const char *__restrict __name, char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;
typedef int (*__compar_fn_t) (const void *, const void *);

extern void *bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 2, 5))) ;


extern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
__extension__ extern long long int llabs (long long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

extern div_t div (int __numer, int __denom) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

extern ldiv_t ldiv (long int __numer, long int __denom) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

__extension__ extern lldiv_t lldiv (long long int __numer, long long int __denom) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *gcvt (double __value, int __ndigit, char *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;

extern char *qecvt (long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;


extern char *qfcvt (long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;


extern char *qgcvt (long double __value, int __ndigit, char *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;

extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qecvt_r (long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));



extern int qfcvt_r (long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));



extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern int mbtowc (wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));
extern size_t mbstowcs (wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern size_t wcstombs (char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

extern int getsubopt (char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;




extern int getloadavg (double __loadavg[], int __nelem) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







typedef long int ptrdiff_t;

typedef struct {
long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;



























extern void *memcpy (void *__restrict __dest, const void *__restrict __src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memmove (void *__dest, const void *__src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern void *memccpy (void *__restrict __dest, const void *__restrict __src, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int memcmp (const void *__s1, const void *__s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (const void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *strcpy (char *__restrict __dest, const char *__restrict __src) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest, const char *__restrict __src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int strcmp (const char *__s1, const char *__s2) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strcoll (const char *__s1, const char *__s2) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest, const char *__restrict __src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




typedef struct __locale_struct {

struct __locale_data *__locales[13];
const unsigned short int *__ctype_b;
const int *__ctype_tolower;
const int *__ctype_toupper;
const char *__names[13];
} *__locale_t;
typedef __locale_t locale_t;

extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
extern char *strdup (const char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));

extern char *strndup (const char *__string, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));



extern char *strchr (const char *__s, int __c) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *strrchr (const char *__s, int __c) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern size_t strcspn (const char *__s, const char *__reject) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strspn (const char *__s, const char *__accept) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strpbrk (const char *__s, const char *__accept) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strstr (const char *__haystack, const char *__needle) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strtok (char *__restrict __s, const char *__restrict __delim) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern char *__strtok_r (char *__restrict __s, const char *__restrict __delim, char **__restrict __save_ptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));



extern char *strtok_r (char *__restrict __s, const char *__restrict __delim, char **__restrict __save_ptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));



extern size_t strlen (const char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern size_t strnlen (const char *__string, size_t __maxlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void bcopy (const void *__src, void *__dest, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int bcmp (const void *__s1, const void *__s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (const char *__s, int __c) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (const char *__s, int __c) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern int strcasecmp (const char *__s1, const char *__s2) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncasecmp (const char *__s1, const char *__s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsep (char **__restrict __stringp, const char *__restrict __delim) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *stpcpy (char *__restrict __dest, const char *__restrict __src) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *__stpncpy (char *__restrict __dest, const char *__restrict __src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *stpncpy (char *__restrict __dest, const char *__restrict __src, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));








enum {

_ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)), _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)), _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)), _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)), _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)), _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)), _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)), _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)), _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)), _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)), _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)), _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8)) };













extern const unsigned short int **__ctype_b_loc (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern const __int32_t **__ctype_tolower_loc (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern const __int32_t **__ctype_toupper_loc (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));
extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));

extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));
extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));
extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));

extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern char *gettext (const char *__msgid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));

extern char *dgettext (const char *__domainname, const char *__msgid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));

extern char *__dgettext (const char *__domainname, const char *__msgid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));

extern char *dcgettext (const char *__domainname, const char *__msgid, int __category) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));


extern char *__dcgettext (const char *__domainname, const char *__msgid, int __category) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));


extern char *ngettext (const char *__msgid1, const char *__msgid2, unsigned long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));


extern char *dngettext (const char *__domainname, const char *__msgid1, const char *__msgid2, unsigned long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));


extern char *dcngettext (const char *__domainname, const char *__msgid1, const char *__msgid2, unsigned long int __n, int __category) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));
extern char *bindtextdomain (const char *__domainname, const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));
extern char *bind_textdomain_codeset (const char *__domainname, const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));









struct lconv {

char *decimal_point;
char *thousands_sep;
char *grouping;
char *int_curr_symbol;
char *currency_symbol;
char *mon_decimal_point;
char *mon_thousands_sep;
char *mon_grouping;
char *positive_sign;
char *negative_sign;
char int_frac_digits;
char frac_digits;
char p_cs_precedes;
char p_sep_by_space;
char n_cs_precedes;
char n_sep_by_space;
char p_sign_posn;
char n_sign_posn;
char int_p_cs_precedes;
char int_p_sep_by_space;
char int_n_cs_precedes;
char int_n_sep_by_space;
char int_p_sign_posn;
char int_n_sign_posn;

};
extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));
extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));

extern __locale_t newlocale (int __category_mask, const char *__locale, __locale_t __base) __attribute__ ((__nothrow__ , __leaf__));

extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));
extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));
extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));









extern void fatal (const char *, int) __attribute__((noreturn));
extern char *xmalloc (size_t size);
extern char *xrealloc (char *ptr, size_t size);
extern struct matcher {

char *name;
void (*compile) (char *, size_t);
char *(*execute) (char *, size_t, char **);
} matchers[];
extern char const *matcher;
extern int match_icase;
extern int match_words;
extern int match_lines;
extern unsigned char eolbyte;



char * savedir (const char *dir, unsigned int name_size);

struct stats {

struct stats *parent;
struct stat stat;
};
static struct stats stats_base;
static int show_help;
static int show_version;
static int mmap_option;
static char const short_options[] = "0123456789A:B:C::EFGHUVX:abcd:e:f:hiLlnqrsuvwxyZz";
static struct option long_options[] = {

{"after-context",   1  ,   ((void *)0)  , 'A'}, {"basic-regexp",   0  ,   ((void *)0)  , 'G'}, {"before-context",   1  ,   ((void *)0)  , 'B'}, {"byte-offset",   0  ,   ((void *)0)  , 'b'}, {"context",   2  ,   ((void *)0)  , 'C'}, {"count",   0  ,   ((void *)0)  , 'c'}, {"directories",   1  ,   ((void *)0)  , 'd'}, {"extended-regexp",   0  ,   ((void *)0)  , 'E'}, {"file",   1  ,   ((void *)0)  , 'f'}, {"files-with-matches",   0  ,   ((void *)0)  , 'l'}, {"files-without-match",   0  ,   ((void *)0)  , 'L'}, {"fixed-regexp",   0  ,   ((void *)0)  , 'F'}, {"fixed-strings",   0  ,   ((void *)0)  , 'F'}, {"help",   0  , &show_help, 1}, {"ignore-case",   0  ,   ((void *)0)  , 'i'}, {"line-number",   0  ,   ((void *)0)  , 'n'}, {"line-regexp",   0  ,   ((void *)0)  , 'x'}, {"mmap",   0  , &mmap_option, 1}, {"no-filename",   0  ,   ((void *)0)  , 'h'}, {"no-messages",   0  ,   ((void *)0)  , 's'}, {"null",   0  ,   ((void *)0)  , 'Z'}, {"null-data",   0  ,   ((void *)0)  , 'z'}, {"quiet",   0  ,   ((void *)0)  , 'q'}, {"recursive",   0  ,   ((void *)0)  , 'r'}, {"regexp",   1  ,   ((void *)0)  , 'e'}, {"invert-match",   0  ,   ((void *)0)  , 'v'}, {"silent",   0  ,   ((void *)0)  , 'q'}, {"text",   0  ,   ((void *)0)  , 'a'}, {"binary",   0  ,   ((void *)0)  , 'U'}, {"unix-byte-offsets",   0  ,   ((void *)0)  , 'u'}, {"version",   0  ,   ((void *)0)  , 'V'}, {"with-filename",   0  ,   ((void *)0)  , 'H'}, {"word-regexp",   0  ,   ((void *)0)  , 'w'}, {0, 0, 0, 0}

































































































































































































































































































};
int match_icase;
int match_words;
int match_lines;
unsigned char eolbyte;
static char *prog;
static char const *filename;
static int errseen;
static enum {

READ_DIRECTORIES, RECURSE_DIRECTORIES, SKIP_DIRECTORIES } directories;



static int ck_atoi (char const *, int *);
static void usage (int) __attribute__((noreturn));
static void error (const char *, int);
static void setmatcher (char const *);
static int install_matcher (char const *);
static int prepend_args (char const *, char *, char **);
static void prepend_default_options (char const *, int *, char ***);
static char *page_alloc (size_t, char **);
static int reset (int, char const *, struct stats *);
static int fillbuf (size_t, struct stats *);
static int grepbuf (char *, char *);
static void prtext (char *, char *, int *);
static void prpending (char *);
static void prline (char *, char *, int);
static void print_offset_sep (off_t, int);
static void nlscan (char *);
static int grep (int, char const *, struct stats *);
static int grepdir (char const *, struct stats *);
static int grepfile (char const *, struct stats *);
static void (*compile) (char *, size_t);
static char *(*execute) (char *, size_t, char **);
static void error (mesg, errnum) const char *mesg;


int errnum;
{
if (errnum) {
fprintf (  stdout  , "%s: %s: %s\n", prog, mesg, strerror (errnum));
}





else {
fprintf (  stdout  , "%s: %s\n", prog, mesg);
}





errseen = 1;
}
void fatal (mesg, errnum) const char *mesg;


int errnum;
{
error (mesg, errnum);
exit (2);
}
char * xmalloc (size) size_t size;


{
char *result;
result = malloc (size);
if (size && !result) {
fatal (gettext ("memory exhausted"), 0);
}

return result;
}
char * xrealloc (ptr, size) char *ptr;


size_t size;
{
char *result;
if (ptr) {
result = realloc (ptr, size);
}

else {
result = malloc (size);
}
if (size && !result) {
fatal (gettext ("memory exhausted"), 0);
}

return result;
}
static int ck_atoi (str, out) char const *str;


int *out;
{
char const *p;
for (p = str; *p; p++){
if (*p < '0' || *p > '9') {
return -1;
}}


*out = atoi (optarg);
return 0;
}
static char *ubuffer;
static char *buffer;
static size_t bufsalloc;
static size_t bufalloc;
static int bufdesc;
static char *bufbeg;
static char *buflim;
static size_t pagesize;
static off_t bufoffset;
static int bufmapped;
static off_t initial_bufoffset;

static char * page_alloc (size, up) size_t size;


char **up;
{
size_t asize = size + pagesize - 1;
if (size <= asize){
char *p = *up ? realloc (*up, asize) : malloc (asize);
if (p){
*up = p;
return 
 ((size_t) (p) % (pagesize) == 0 
 ? (p) 
 : (p) + ((pagesize) - (size_t) (p) % (pagesize)));
}
}
return   ((void *)0)  ;




}
static int reset (fd, file, stats) int fd;


char const *file;
struct stats *stats;
{
if (pagesize) {
bufsalloc = 
 ((size_t) (bufalloc / 5) % (pagesize) == 0 
 ? (bufalloc / 5) 
 : (bufalloc / 5) + ((pagesize) - (size_t) (bufalloc / 5) % (pagesize)));
}


else {

size_t ubufsalloc;
pagesize = getpagesize ();
if (pagesize == 0) {
abort ();
}

ubufsalloc = ((8192) > (pagesize) ? (8192) : (pagesize));
bufsalloc = 
 ((size_t) (ubufsalloc) % (pagesize) == 0 
 ? (ubufsalloc) 
 : (ubufsalloc) + ((pagesize) - (size_t) (ubufsalloc) % (pagesize)));
bufalloc = 5 * bufsalloc;
if (bufsalloc < ubufsalloc || bufalloc / 5 != bufsalloc || bufalloc + 1 < bufalloc || ! (buffer = page_alloc (bufalloc + 1, &ubuffer))) {
fatal (gettext ("memory exhausted"), 0);
}




}
buflim = buffer;
bufdesc = fd;
if (fstat (fd, &stats->stat) != 0){
error ("fstat",   (*__errno_location ())  );




return 0;
}
if (directories == SKIP_DIRECTORIES &&   ((((  stats->stat.st_mode  )) & 0170000) == (0040000))  ) {
return 0;
}









if (  ((((  stats->stat.st_mode  )) & 0170000) == (0100000))  ) {









if (file) {
bufoffset = 0;
}

else {

bufoffset = lseek (fd, 0,   1  );




if (bufoffset < 0){
error ("lseek",   (*__errno_location ())  );




return 0;
}
}
initial_bufoffset = bufoffset;
bufmapped = mmap_option && bufoffset % pagesize == 0;
}
else {

bufmapped = 0;
}
return 1;
}
static int fillbuf (save, stats) size_t save;


struct stats *stats;
{
size_t fillsize = 0;
int cc = 1;
size_t readsize;
size_t saved_offset = buflim - ubuffer - save;
if (bufsalloc < save){
size_t aligned_save = 
 ((size_t) (save) % (pagesize) == 0 
 ? (save) 
 : (save) + ((pagesize) - (size_t) (save) % (pagesize)));
size_t maxalloc = (size_t) -1;
size_t newalloc;
if (  ((((  stats->stat.st_mode  )) & 0170000) == (0100000))  ) {









off_t to_be_read = stats->stat.st_size - bufoffset;
size_t slop = to_be_read % pagesize;
off_t aligned_to_be_read = to_be_read + (slop ? pagesize - slop : 0);
off_t maxalloc_off = aligned_save + aligned_to_be_read;
if (0 <= maxalloc_off && maxalloc_off == (size_t) maxalloc_off) {
maxalloc = maxalloc_off;
}

}
while (bufsalloc < save){
if (bufsalloc < bufsalloc * 2) {
bufsalloc *= 2;
}


else {

bufsalloc = aligned_save;
break;
}}
newalloc = 5 * bufsalloc;
if (maxalloc < newalloc){
newalloc = maxalloc;
bufsalloc = aligned_save;
}
if (bufsalloc < save || newalloc < save || (newalloc == save && newalloc != maxalloc) || (bufalloc < newalloc && ! (buffer = page_alloc ((bufalloc = newalloc) + 1, &ubuffer)))) {
fatal (gettext ("memory exhausted"), 0);
}





}
bufbeg = buffer + bufsalloc - save;
memmove (bufbeg, ubuffer + saved_offset, save);
readsize = bufsalloc - bufalloc;
if (bufmapped){
size_t mmapsize = readsize;
if (stats->stat.st_size - bufoffset < mmapsize){
mmapsize = stats->stat.st_size - bufoffset;
mmapsize -= mmapsize % pagesize;
}
if (mmapsize && (mmap ((caddr_t) (buffer + bufsalloc), mmapsize,  0x1   |   0x2  ,   0x02   |   0x10  , bufdesc, bufoffset) != (caddr_t) -1)) {




















fillsize = mmapsize;
}
else {

bufmapped = 0;
if (bufoffset != initial_bufoffset && lseek (bufdesc, bufoffset,   0  ) < 0) {






error ("lseek",   (*__errno_location ())  );




cc = 0;
}
}
}
if (! fillsize){
ssize_t bytesread;
while ((bytesread = read (bufdesc, buffer + bufsalloc, readsize)) < 0 &&   (*__errno_location ())   ==   4  ) {
continue;
}










if (bytesread < 0) {
cc = 0;
}

else {
fillsize = bytesread;
}
}
bufoffset += fillsize;

buflim = buffer + bufsalloc + fillsize;
return cc;
}
static int always_text;
static int filename_mask;
static int out_quiet;
static int out_invert;
static int out_file;
static int out_line;
static int out_byte;
static int out_before;
static int out_after;
static int count_matches;
static int list_files;
static int no_filenames;
static int suppress_errors;
static off_t totalcc;
static char *lastnl;
static char *lastout;
static off_t totalnl;
static int pending;
static int done_on_match;
static void nlscan (lim) char *lim;


{
char *beg;
for (beg = lastnl; (beg = memchr (beg, eolbyte, lim - beg)); beg++) totalnl++;

lastnl = lim;
}
static void print_offset_sep (pos, sep) off_t pos;


int sep;
{
char buf[sizeof pos * 8];
char *p = buf + sizeof buf - 1;
*p = sep;
do *--p = '0' + pos % 10;

while ((pos /= 10) != 0);
fwrite (p, 1, buf + sizeof buf - p,   stdout  );




}
static void prline (beg, lim, sep) char *beg;


char *lim;
int sep;
{
if (out_file) {
printf ("%s%c", filename, sep & filename_mask);
}

if (out_line){
nlscan (beg);
print_offset_sep (++totalnl, sep);
lastnl = lim;
}
if (out_byte){
off_t pos = totalcc + (beg - bufbeg);
print_offset_sep (pos, sep);
}
fwrite (beg, 1, lim - beg,   stdout  );




if (ferror (  stdout  )) {
error (gettext ("writing output"),   (*__errno_location ())  );
}









lastout = lim;
}
static void prpending (lim) char *lim;


{
char *nl;
if (!lastout) {
lastout = bufbeg;
}

while (pending > 0 && lastout < lim) {

--pending;
if ((nl = memchr (lastout, eolbyte, lim - lastout)) != 0) {
++nl;
}

else {
nl = lim;
}
prline (lastout, nl, '-');
}
}
static void prtext (beg, lim, nlinesp) char *beg;


char *lim;
int *nlinesp;
{
static int used;
char *bp, *p, *nl;
char eol = eolbyte;
int i, n;
if (!out_quiet && pending > 0) {
prpending (beg);
}

p = beg;
if (!out_quiet){
bp = lastout ? lastout : bufbeg;
for (i = 0; i < out_before; ++i){
if (p > bp) {
do --p;



while (p > bp && p[-1] != eol);
}}

if ((out_before || out_after) && used && p != lastout) {
puts ("--");
}

while (p < beg) {

nl = memchr (p, eol, beg - p);
prline (p, nl + 1, '-');
p = nl + 1;
}
}
if (nlinesp){
for (n = 0; p < lim; ++n){
if ((nl = memchr (p, eol, lim - p)) != 0) {
++nl;
}

else {
nl = lim;
}
if (!out_quiet) {
prline (p, nl, ':');
}

p = nl;
}
*nlinesp = n;
}
else{
if (!out_quiet) {
prline (beg, lim, ':');
}

}


pending = out_quiet ? 0 : out_after;
used = 1;
}
static int grepbuf (beg, lim) char *beg;


char *lim;
{
int nlines, n;
register char *p, *b;
char *endp;
char eol = eolbyte;
nlines = 0;
p = beg;
while ((b = (*execute)(p, lim - p, &endp)) != 0) {

if (b == lim && ((b > beg && b[-1] == eol) || b == beg)) {
break;
}

if (!out_invert){
prtext (b, endp, (int *) 0);
nlines += 1;
if (done_on_match) {
return nlines;
}

}
else{
if (p < b){
prtext (p, b, &n);
nlines += n;
}
}

p = endp;
}
if (out_invert && p < lim){
prtext (p, lim, &n);
nlines += n;
}
return nlines;
}
static int grep (fd, file, stats) int fd;


char const *file;
struct stats *stats;
{
int nlines, i;
int not_text;
size_t residue, save;
char *beg, *lim;
char eol = eolbyte;
if (!reset (fd, file, stats)) {
return 0;
}

if (file && directories == RECURSE_DIRECTORIES &&   ((((  stats->stat.st_mode  )) & 0170000) == (0040000))  ) {










if (close (fd) != 0) {
error (file,   (*__errno_location ())  );
}





return grepdir (file, stats) - 2;
}
totalcc = 0;
lastout = 0;
totalnl = 0;
pending = 0;
nlines = 0;
residue = 0;
save = 0;
if (! fillbuf (save, stats)){
if (! (((  (*__errno_location ())  ) ==   21  ) && suppress_errors)) {
error (filename,   (*__errno_location ())  );
}













return nlines;
}
not_text = (! (always_text | out_quiet) && memchr (bufbeg, eol ? '\0' : '\200', buflim - bufbeg));

done_on_match += not_text;
out_quiet += not_text;
for (;;){
lastnl = bufbeg;
if (lastout) {
lastout = bufbeg;
}

if (buflim - bufbeg == save) {
break;
}

beg = bufbeg + save - residue;
for (lim = buflim; lim > beg && lim[-1] != eol; --lim) ;

residue = buflim - lim;
if (beg < lim){
nlines += grepbuf (beg, lim);
if (pending) {
prpending (lim);
}

if (nlines && done_on_match && !out_invert) {
goto finish_grep;
}

}
i = 0;
beg = lim;
while (i < out_before && beg > bufbeg && beg != lastout) {

++i;
do --beg;

while (beg > bufbeg && beg[-1] != eol);
}
if (beg != lastout) {
lastout = 0;
}

save = residue + lim - beg;
totalcc += buflim - bufbeg - save;
if (out_line) {
nlscan (beg);
}

if (! fillbuf (save, stats)){
if (! (((  (*__errno_location ())  ) ==   21  ) && suppress_errors)) {
error (filename,   (*__errno_location ())  );
}













goto finish_grep;
}
}
if (residue){
nlines += grepbuf (bufbeg + save - residue, buflim);
if (pending) {
prpending (buflim);
}

}
finish_grep:
done_on_match -= not_text;
out_quiet -= not_text;
if ((not_text & ~out_quiet) && nlines != 0) {
printf (gettext ("Binary file %s matches\n"), filename);
}

return nlines;
}
static int grepfile (file, stats) char const *file;


struct stats *stats;
{
int desc;
int count;
int status;
if (! file){
desc = 0;
filename = gettext ("(standard input)");
}
else {

while ((desc = open (file,   00  )) < 0 &&   (*__errno_location ())   ==   4  ) continue;













if (desc < 0){
int e =   (*__errno_location ())  ;




if (((e) ==   21  ) && directories == RECURSE_DIRECTORIES) {





if (stat (file, &stats->stat) != 0){
error (file,   (*__errno_location ())  );




return 1;
}
return grepdir (file, stats);
}
if (!suppress_errors){
if (directories == SKIP_DIRECTORIES) {
switch (e) {


case   21  :




return 1;
case   13  :




if (stat (file, &stats->stat) == 0 &&   ((((  stats->stat.st_mode  )) & 0170000) == (0040000))  ) {
return 1;
}










break;
}
}

error (file, e);
}
return 1;
}
filename = file;
}

count = grep (desc, file, stats);
if (count < 0) {
status = count + 2;
}

else {

if (count_matches){
if (out_file) {
printf ("%s%c", filename, ':' & filename_mask);
}

printf ("%d\n", count);
}
status = !count;
if (list_files == 1 - 2 * status) {
printf ("%s%c", filename, '\n' & filename_mask);
}

if (file) {
while (close (desc) != 0){
if (  (*__errno_location ())   !=   4  ) {











error (file,   (*__errno_location ())  );




break;
}}
}

}
return status;
}
static int grepdir (dir, stats) char const *dir;


struct stats *stats;
{
int status = 1;
struct stats *ancestor;
char *name_space;
for (ancestor = stats; (ancestor = ancestor->parent) != 0; ){
if (ancestor->stat.st_ino == stats->stat.st_ino && ancestor->stat.st_dev == stats->stat.st_dev) {



if (!suppress_errors) {
fprintf (  stdout  , gettext ("%s: warning: %s: %s\n"), prog, dir, gettext ("recursive directory loop"));
}





return 1;
}}
name_space = savedir (dir, (unsigned) stats->stat.st_size);
if (! name_space){
if (  (*__errno_location ())  ) {





if (!suppress_errors) {
error (dir,   (*__errno_location ())  );
}





}
else {
fatal (gettext ("Memory exhausted"), 0);
}
}
else {

size_t dirlen = strlen (dir);
int needs_slash = ! (dirlen == 0 || ((dir[dirlen - 1]) == '/'));
char *file =   ((void *)0)  ;




char *namep = name_space;
struct stats child;
child.parent = stats;
out_file += !no_filenames;
while (*namep) {

size_t namelen = strlen (namep);
file = xrealloc (file, dirlen + 1 + namelen + 1);
strcpy (file, dir);
file[dirlen] = '/';
strcpy (file + dirlen + needs_slash, namep);
namep += namelen + 1;
status &= grepfile (file, &child);
}
out_file -= !no_filenames;
if (file) {
free (file);
}

free (name_space);
}
return status;
}
static void usage(status) int status;


{
if (status != 0){
fprintf (  stdout  , gettext ("Usage: %s [OPTION]... PATTERN [FILE]...\n"), prog);




fprintf (  stdout  , gettext ("Try `%s --help' for more information.\n"), prog);




}
else {

printf (gettext ("Usage: %s [OPTION]... PATTERN [FILE] ...\n"), prog);
printf (gettext ("Search for PATTERN in each FILE or standard input.\n Example: %s -i 'hello.*world' menu.h main.c\n  \n Regexp selection and interpretation:\n") , prog);

printf (gettext (" -E, --extended-regexp     PATTERN is an extended regular expression\n   -F, --fixed-strings       PATTERN is a set of newline-separated strings\n   -G, --basic-regexp        PATTERN is a basic regular expression\n") );

printf (gettext ("   -e, --regexp=PATTERN      use PATTERN as a regular expression\n   -f, --file=FILE           obtain PATTERN from FILE\n   -i, --ignore-case         ignore case distinctions\n   -w, --word-regexp         force PATTERN to match only whole words\n   -x, --line-regexp         force PATTERN to match only whole lines\n   -z, --null-data           a data line ends in 0 byte, not newline\n") );

printf (gettext (" \n Miscellaneous:\n   -s, --no-messages         suppress error messages\n   -v, --invert-match        select non-matching lines\n   -V, --version             print version information and exit\n       --help                display this help and exit\n       --mmap                use memory-mapped input if possible\n") );

printf (gettext (" \n Output control:\n    -b, --byte-offset         print the byte offset with output lines\n   -n, --line-number         print line number with output lines\n   -H, --with-filename       print the filename for each match\n   -h, --no-filename         suppress the prefixing filename on output\n    -q, --quiet, --silent     suppress all normal output\n  -a, --text                do not suppress binary output\n   -d, --directories=ACTION  how to handle directories\n                             ACTION is 'read', 'recurse', or 'skip'.\n   -r, --recursive           equivalent to --directories=recurse.\n   -L, --files-without-match only print FILE names containing no match\n   -l, --files-with-matches  only print FILE names containing matches\n   -c, --count               only print a count of matching lines per FILE\n   -Z, --null                print 0 byte after FILE name\n")  );


printf (gettext (" \n Context control:\n   -B, --before-context=NUM  print NUM lines of leading context\n   -A, --after-context=NUM   print NUM lines of trailing context\n   -C, --context[=NUM]       print NUM (default 2) lines of output context\n                             unless overridden by -A or -B\n   -NUM                      same as --context=NUM\n   -U, --binary              do not strip CR characters at EOL (MSDOS)\n   -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n \n `egrep' means `grep -E'.  `fgrep' means `grep -F'.\n With no FILE, or when FILE is -, read standard input.  If less than\n two FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\n and 2 if trouble.\n")  );


printf (gettext ("\nReport bugs to <bug-gnu-utils@gnu.org>.\n"));
}
exit (status);
}
static void setmatcher (m) char const *m;


{
if (matcher && strcmp (matcher, m) != 0) {
fatal (gettext ("conflicting matchers specified"), 0);
}

matcher = m;
}
static int install_matcher (name) char const *name;


{
int i;
for (i = 0; matchers[i].name; ++i){
if (strcmp (name, matchers[i].name) == 0){

compile = matchers[i].compile;
execute = matchers[i].execute;

return 1;
}}
return 0;
}
static int prepend_args (options, buf, argv) char const *options;


char *buf;
char **argv;
{
char const *o = options;
char *b = buf;
int n = 0;
for (;;){
while ((1 &&   ((*__ctype_b_loc ())[(int) ((  (unsigned char) *o  ))] & (unsigned short int) _ISspace)  )) o++;









if (!*o) {
return n;
}

if (argv) {
argv[n] = b;
}

n++;
do if ((*b++ = *o++) == '\\' && *o) {
b[-1] = *o++;
}


while (*o && ! (1 &&   ((*__ctype_b_loc ())[(int) ((  (unsigned char) *o  ))] & (unsigned short int) _ISspace)  ));








*b++ = '\0';
}
}
static void prepend_default_options (options, pargc, pargv) char const *options;


int *pargc;
char ***pargv;
{
if (options){
char *buf = xmalloc (strlen (options) + 1);
int prepended = prepend_args (options, buf, (char **)   ((void *)0)  );




int argc = *pargc;
char * const *argv = *pargv;
char **pp = (char **) xmalloc ((prepended + argc + 1) * sizeof *pp);
*pargc = prepended + argc;
*pargv = pp;
*pp++ = *argv++;
pp += prepend_args (options, buf, pp);
while ((*pp++ = *argv++)) continue;

}
}
int main (argc, argv) int argc;


char *argv[];
{
char *keys;
size_t keycc, oldcc, keyalloc;
int with_filenames;
int opt, cc, status;
unsigned digit_args_val, default_context;
FILE *fp;
extern char *optarg;
extern int optind;
;
argv[0] = "target3";
prog = argv[0];
if (prog && strrchr (prog, '/')) {
prog = strrchr (prog, '/') + 1;
}


keys =   ((void *)0)  ;




keycc = 0;
with_filenames = 0;
eolbyte = '\n';
filename_mask = ~0;
out_after = out_before = -1;
default_context = 0;
digit_args_val = 0;
setlocale (  6  , "");




bindtextdomain ("grep", "/nfs/spectre/u4/jin/research/experiments/grep/docs/grep_2.4/lib/locale");
textdomain ("grep");
prepend_default_options (getenv ("GREP_OPTIONS"), &argc, &argv);
while ((opt = getopt_long (argc, argv, short_options, long_options,   ((void *)0)  )) != -1) switch (opt) {







case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
digit_args_val = 10 * digit_args_val + opt - '0';
default_context = digit_args_val;
break;
case 'A':
if (optarg){
if (ck_atoi (optarg, &out_after)) {
fatal (gettext ("invalid context length argument"), 0);
}

}
break;
case 'B':
if (optarg){
if (ck_atoi (optarg, &out_before)) {
fatal (gettext ("invalid context length argument"), 0);
}

}
break;
case 'C':
if (optarg){
if (ck_atoi (optarg, &default_context)) {
fatal (gettext ("invalid context length argument"), 0);
}

}
else {
default_context = 2;
}
break;
case 'E':
setmatcher ("egrep");
break;
case 'F':
setmatcher ("fgrep");
break;
case 'G':
setmatcher ("grep");
break;
case 'H':
with_filenames = 1;
break;
case 'U':
break;
case 'u':
break;
case 'V':
show_version = 1;
break;
case 'X':
setmatcher (optarg);
break;
case 'a':
always_text = 1;
break;
case 'b':
out_byte = 1;
break;
case 'c':
out_quiet = 1;
count_matches = 1;
break;
case 'd':
if (strcmp (optarg, "read") == 0) {
directories = READ_DIRECTORIES;
}

else{
if (strcmp (optarg, "skip") == 0) {
directories = SKIP_DIRECTORIES;
}

else{
if (strcmp (optarg, "recurse") == 0) {
directories = RECURSE_DIRECTORIES;
}

else {
fatal (gettext ("unknown directories method"), 0);
}
}
}
break;
case 'e':
cc = strlen (optarg);
keys = xrealloc (keys, keycc + cc + 1);
strcpy (&keys[keycc], optarg);
keycc += cc;
keys[keycc++] = '\n';
break;
case 'f':
fp = strcmp (optarg, "-") != 0 ? fopen (optarg, "r") :   stdin  ;




if (!fp) {
fatal (optarg,   (*__errno_location ())  );
}





for (keyalloc = 1; keyalloc <= keycc + 1; keyalloc *= 2) ;

keys = xrealloc (keys, keyalloc);
oldcc = keycc;
while (!feof (fp) && (cc = fread (keys + keycc, 1, keyalloc - 1 - keycc, fp)) > 0) {


keycc += cc;
if (keycc == keyalloc - 1) {
keys = xrealloc (keys, keyalloc *= 2);
}

}
if (fp !=   stdin  ) {
fclose(fp);
}





if (oldcc != keycc && keys[keycc - 1] != '\n') {
keys[keycc++] = '\n';
}

break;
case 'h':
no_filenames = 1;
break;
case 'i':
case 'y':
match_icase = 1;
break;
case 'L':
out_quiet = 1;
list_files = -1;
done_on_match = 1;
break;
case 'l':
out_quiet = 1;
list_files = 1;
done_on_match = 1;
break;
case 'n':
out_line = 1;
break;
case 'q':
done_on_match = 1;
out_quiet = 1;
break;
case 'r':
directories = RECURSE_DIRECTORIES;
break;
case 's':
suppress_errors = 1;
break;
case 'v':
out_invert = 1;
break;
case 'w':
match_words = 1;
break;
case 'x':
match_lines = 1;
break;
case 'Z':
filename_mask = 0;
break;
case 'z':
eolbyte = '\0';
break;
case 0:
break;
default:
usage (2);
break;
}
if (out_after < 0) {
out_after = default_context;
}

if (out_before < 0) {
out_before = default_context;
}

if (! matcher) {
matcher = "grep";
}

if (show_version){
printf (gettext ("%s (GNU grep) %s\n"), matcher, "2.4");
printf ("\n");
printf (gettext (" Copyright (C) 1988, 1992-1998, 1999 Free Software Foundation, Inc.\n") );

printf (gettext ("This is free software; see the source for copying conditions. There is NO\n warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n") );

printf ("\n");
exit (0);
}
if (show_help) {
usage (0);
}

if (keys){
if (keycc == 0) {
out_invert ^= 1;
}

else {
--keycc;
}
}
else{
if (optind < argc){

keys = argv[optind++];
keycc = strlen (keys);
}
else {
usage (2);
}

}
if (!install_matcher (matcher) && !install_matcher ("default")) {
abort ();
}

(*compile)(keys, keycc);
if ((argc - optind > 1 && !no_filenames) || with_filenames) {
out_file = 1;
}


if (optind < argc){
status = 1;
do {

char *file = argv[optind];
status &= grepfile (strcmp (file, "-") == 0 ? (char *)   ((void *)0)   : file, &stats_base);




}
while ( ++optind < argc);
}
else {
status = grepfile ((char *)   ((void *)0)  , &stats_base);
}





if (fclose (  stdout  ) ==   (-1)  ) {
error (gettext ("writing output"),   (*__errno_location ())  );
}













exit (errseen ? 2 : status);
}




extern void __assert_fail (const char *__assertion, const char *__file, unsigned int __line, const char *__function) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file, unsigned int __line, const char *__function) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert (const char *__assertion, const char *__file, int __line) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






typedef long int s_reg_t;
typedef unsigned long int active_reg_t;
typedef unsigned long int reg_syntax_t;

extern reg_syntax_t re_syntax_options;

typedef enum {

REG_NOERROR = 0, REG_NOMATCH, REG_BADPAT, REG_ECOLLATE, REG_ECTYPE, REG_EESCAPE, REG_ESUBREG, REG_EBRACK, REG_EPAREN, REG_EBRACE, REG_BADBR, REG_ERANGE, REG_ESPACE, REG_BADRPT, REG_EEND, REG_ESIZE, REG_ERPAREN } reg_errcode_t;


















struct re_pattern_buffer {

unsigned char *buffer;
unsigned long int allocated;
unsigned long int used;
reg_syntax_t syntax;
char *fastmap;
char * translate;
size_t re_nsub;
unsigned can_be_null : 1;

unsigned regs_allocated : 2;
unsigned fastmap_accurate : 1;
unsigned no_sub : 1;
unsigned not_bol : 1;
unsigned not_eol : 1;
unsigned newline_anchor : 1;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct re_registers {

unsigned num_regs;
regoff_t *start;
regoff_t *end;
};

typedef struct {

regoff_t rm_so;
regoff_t rm_eo;
} regmatch_t;

extern reg_syntax_t __re_set_syntax (reg_syntax_t syntax);
extern reg_syntax_t re_set_syntax (reg_syntax_t syntax);
extern const char *__re_compile_pattern (const char *pattern, size_t length, struct re_pattern_buffer *buffer) ;


extern const char *re_compile_pattern (const char *pattern, size_t length, struct re_pattern_buffer *buffer) ;


extern int __re_compile_fastmap (struct re_pattern_buffer *buffer);
extern int re_compile_fastmap (struct re_pattern_buffer *buffer);
extern int __re_search (struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs) ;


extern int re_search (struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs) ;


extern int __re_search_2 (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, int range, struct re_registers *regs, int stop) ;


extern int re_search_2 (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, int range, struct re_registers *regs, int stop) ;


extern int __re_match (struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs) ;


extern int re_match (struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs) ;


extern int __re_match_2 (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, struct re_registers *regs, int stop) ;


extern int re_match_2 (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, struct re_registers *regs, int stop) ;



extern void __re_set_registers (struct re_pattern_buffer *buffer, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends) ;


extern void re_set_registers (struct re_pattern_buffer *buffer, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends) ;



extern int __regcomp (regex_t *__preg, const char *__pattern, int __cflags) ;

extern int regcomp (regex_t *__preg, const char *__pattern, int __cflags) ;

extern int __regexec (const regex_t *__preg, const char *__string, size_t __nmatch, regmatch_t __pmatch[], int __eflags) ;

extern int regexec (const regex_t *__preg, const char *__string, size_t __nmatch, regmatch_t __pmatch[], int __eflags) ;

extern size_t __regerror (int __errcode, const regex_t *__preg, char *__errbuf, size_t __errbuf_size) ;

extern size_t regerror (int __errcode, const regex_t *__preg, char *__errbuf, size_t __errbuf_size) ;

extern void __regfree (regex_t *__preg);
extern void regfree (regex_t *__preg);



typedef int charclass[(((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))];
typedef enum {

END = -1, EMPTY = (1 << 8), BACKREF, BEGLINE, ENDLINE, BEGWORD, ENDWORD, LIMWORD, NOTLIMWORD, QMARK, STAR, PLUS, REPMN, CAT, OR, ORTOP, LPAREN, RPAREN, CSET } token;




















typedef struct {

unsigned strchr;
unsigned constraint;
} position;
typedef struct {

position *elems;
int nelem;
} position_set;
typedef struct {

int hash;
position_set elems;
char newline;
char letter;
char backref;
unsigned char constraint;
int first_end;
} dfa_state;
struct dfamust {

int exact;
char *must;
struct dfamust *next;
};
struct dfa {

charclass *charclasses;
int cindex;
int calloc;
token *tokens;
int tindex;
int talloc;
int depth;
int nleaves;
int nregexps;
dfa_state *states;
int sindex;
int salloc;
position_set *follows;
int searchflag;

int tralloc;
int trcount;
int **trans;
int **realtrans;
int **fails;
int *success;
int *newlines;
struct dfamust *musts;
};

extern void dfasyntax (reg_syntax_t, int, int);
extern void dfacomp (char *, size_t, struct dfa *, int);

extern char *dfaexec (struct dfa *, char *, char *, int, int *, int *);
extern void dfafree (struct dfa *);
extern void dfainit (struct dfa *);
extern void dfaparse (char *, size_t, struct dfa *);
extern void dfaanalyze (struct dfa *, int);
extern void dfastate (int, struct dfa *, int []);
extern void dfaerror (const char *);


static void dfamust (struct dfa *dfa);
static ptr_t xcalloc (size_t n, size_t s);
static ptr_t xmalloc_1 (size_t n);
static ptr_t xrealloc_1 (ptr_t p, size_t n);
static int tstbit (int b, charclass c);
static void setbit (int b, charclass c);
static void clrbit (int b, charclass c);
static void copyset (charclass src, charclass dst);
static void zeroset (charclass s);
static void notset (charclass s);
static int equal (charclass s1, charclass s2);
static int charclass_index (charclass s);
static int looking_at (const char *s);
static token lex (void);
static void addtok (token t);
static void atom (void);
static int nsubtoks (int tindex);
static void copytoks (int tindex, int ntokens);
static void closure (void);
static void branch (void);
static void regexp (int toplevel);
static void copy (position_set *src, position_set *dst);
static void insert (position p, position_set *s);
static void merge (position_set *s1, position_set *s2, position_set *m);
static void delete (position p, position_set *s);
static int state_index (struct dfa *d, position_set *s, int newline, int letter) ;

static void build_state (int s, struct dfa *d);
static void build_state_zero (struct dfa *d);
static char *icatalloc (char *old, char *new);
static char *icpyalloc (char *string);
static char *istrstr (char *lookin, char *lookfor);
static void ifree (char *cp);
static void freelist (char **cpp);
static char **enlist (char **cpp, char *new, size_t len);
static char **comsubs (char *left, char *right);
static char **addlists (char **old, char **new);
static char **inboth (char **left, char **right);
static ptr_t xcalloc(n, s) size_t n;


size_t s;
{
ptr_t r = calloc(n, s);
if (!r) {
dfaerror(gettext ("Memory exhausted"));
}

return r;
}
static ptr_t xmalloc_1(n) size_t n;


{
ptr_t r = malloc(n);
;
if (!r) {
dfaerror(gettext ("Memory exhausted"));
}

return r;
}
static ptr_t xrealloc_1(p, n) ptr_t p;


size_t n;
{
ptr_t r = realloc(p, n);
;
if (!r) {
dfaerror(gettext ("Memory exhausted"));
}

return r;
}

static int tstbit(b, c) int b;


charclass c;
{
return c[b / (8 * sizeof (int))] & 1 << b % (8 * sizeof (int));
}
static void setbit(b, c) int b;


charclass c;
{
c[b / (8 * sizeof (int))] |= 1 << b % (8 * sizeof (int));
}
static void clrbit(b, c) int b;


charclass c;
{
c[b / (8 * sizeof (int))] &= ~(1 << b % (8 * sizeof (int)));
}
static void copyset(src, dst) charclass src;


charclass dst;
{
int i;
for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i) dst[i] = src[i];

}
static void zeroset(s) charclass s;


{
int i;
for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i) s[i] = 0;

}
static void notset(s) charclass s;


{
int i;
for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i) s[i] = ~s[i];

}
static int equal(s1, s2) charclass s1;


charclass s2;
{
int i;
for (i = 0; i < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++i){
if (s1[i] != s2[i]) {
return 0;
}}


return 1;
}
static struct dfa *dfa;
static int charclass_index(s) charclass s;


{
int i;
for (i = 0; i < dfa->cindex; ++i){
if (equal(s, dfa->charclasses[i])) {
return i;
}}



 if ((dfa->cindex) >= (dfa->calloc)){
 
 while ((dfa->cindex) >= (dfa->calloc)) 
 (dfa->calloc) *= 2; 
 ((dfa->charclasses) = (charclass *) xrealloc_1((ptr_t) (dfa->charclasses), (dfa->calloc) * sizeof (charclass))); 
 };
++dfa->cindex;
copyset(s, dfa->charclasses[i]);
return i;
}
static reg_syntax_t syntax_bits, syntax_bits_set;
static int case_fold;
static unsigned char eolbyte_1;
void dfasyntax(bits, fold, eol) reg_syntax_t bits;


int fold;
int eol;
{
syntax_bits_set = 1;
syntax_bits = bits;
case_fold = fold;
eolbyte_1 = eol;
}
static char *lexstart;
static char *lexptr;
static int lexleft;
static token lasttok;
static int laststart;
static int parens;
static int minrep, maxrep;

static int is_alpha(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISalpha)  ; }








static int is_upper(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISupper)  ; }








static int is_lower(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISlower)  ; }








static int is_digit(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  ; }








static int is_xdigit(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISxdigit)  ; }








static int is_space(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISspace)  ; }








static int is_punct(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISpunct)  ; }








static int is_alnum(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISalnum)  ; }








static int is_print(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISprint)  ; }








static int is_graph(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISgraph)  ; }








static int is_cntrl(int c) { return   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _IScntrl)  ; }








static int is_blank(c) int c;

{
return (c == ' ' || c == '\t');
}
static struct {
const char *name;
int (*pred) (int);
} prednames[] = {
{ ":alpha:]", is_alpha }, { ":upper:]", is_upper }, { ":lower:]", is_lower }, { ":digit:]", is_digit }, { ":xdigit:]", is_xdigit }, { ":space:]", is_space }, { ":punct:]", is_punct }, { ":alnum:]", is_alnum }, { ":print:]", is_print }, { ":graph:]", is_graph }, { ":cntrl:]", is_cntrl }, { ":blank:]", is_blank }, { 0 }












};
static int looking_at(s) const char *s;


{
size_t len;
len = strlen(s);
if (lexleft < len) {
return 0;
}

return strncmp(s, lexptr, len) == 0;
}
static token lex() {


token c, c1, c2;
int backslash = 0, invert;
charclass ccl;
int i;
for (i = 0; i < 2; ++i){

 { 
 if (! lexleft) {
 
if (0 != 0) {
 
dfaerror(0); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
switch (c) {

case '\\':
if (backslash) {
goto normal_char;
}

if (lexleft == 0) {
dfaerror(gettext ("Unfinished \\ escape"));
}

backslash = 1;
break;
case '^':
if (backslash) {
goto normal_char;
}

if (syntax_bits & (((((unsigned long int) 1) << 1) << 1) << 1) || lasttok == END || lasttok == LPAREN || lasttok == OR) {
return lasttok = BEGLINE;
}




goto normal_char;
case '$':
if (backslash) {
goto normal_char;
}

if (syntax_bits & (((((unsigned long int) 1) << 1) << 1) << 1) || lexleft == 0 || (syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? lexleft > 0 && *lexptr == ')' : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')') || (syntax_bits & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? lexleft > 0 && *lexptr == '|' : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|') || ((syntax_bits & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && lexleft > 0 && *lexptr == '\n')) {
return lasttok = ENDLINE;
}










goto normal_char;
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
if (backslash && !(syntax_bits & ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))){
laststart = 0;
return lasttok = BACKREF;
}
goto normal_char;
case '`':
if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
return lasttok = BEGLINE;
}

goto normal_char;
case '\'':
if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
return lasttok = ENDLINE;
}

goto normal_char;
case '<':
if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
return lasttok = BEGWORD;
}

goto normal_char;
case '>':
if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
return lasttok = ENDWORD;
}

goto normal_char;
case 'b':
if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
return lasttok = LIMWORD;
}

goto normal_char;
case 'B':
if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
return lasttok = NOTLIMWORD;
}

goto normal_char;
case '?':
if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

if (backslash != ((syntax_bits & (((unsigned long int) 1) << 1)) != 0)) {
goto normal_char;
}

if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart) {
goto normal_char;
}

return lasttok = QMARK;
case '*':
if (backslash) {
goto normal_char;
}

if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart) {
goto normal_char;
}

return lasttok = STAR;
case '+':
if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

if (backslash != ((syntax_bits & (((unsigned long int) 1) << 1)) != 0)) {
goto normal_char;
}

if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart) {
goto normal_char;
}

return lasttok = PLUS;
case '{':
if (!(syntax_bits & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
goto normal_char;
}

if (backslash != ((syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
goto normal_char;
}

if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart) {
goto normal_char;
}

if (syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)){
int lo = -1, hi = -1;
char const *p = lexptr;
char const *lim = p + lexleft;
for (; p != lim &&   ((*__ctype_b_loc ())[(int) ((  *p  ))] & (unsigned short int) _ISdigit)  ; p++) lo = (lo < 0 ? 0 : lo * 10) + *p - '0';









if (p != lim && *p == ',') {
while (++p != lim &&   ((*__ctype_b_loc ())[(int) ((  *p  ))] & (unsigned short int) _ISdigit)  ) hi = (hi < 0 ? 0 : hi * 10) + *p - '0';
}










else {
hi = lo;
}
if (p == lim || *p != '}' || lo < 0 || (0x7fff) < hi || (0 <= hi && hi < lo)) {
goto normal_char;
}


}
minrep = 0;

 { 
 if (! lexleft) {
 
if (gettext ("unfinished repeat count") != 0) {
 
dfaerror(gettext ("unfinished repeat count")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (  ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  ) {









minrep = c - '0';
for (;;){

 { 
 if (! lexleft) {
 
if (gettext ("unfinished repeat count") != 0) {
 
dfaerror(gettext ("unfinished repeat count")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (!  ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  ) {
break;
}









minrep = 10 * minrep + c - '0';
}
}
else {
dfaerror(gettext ("malformed repeat count"));
}
if (c == ','){

 { 
 if (! lexleft) {
 
if (gettext ("unfinished repeat count") != 0) {
 
dfaerror(gettext ("unfinished repeat count")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (!   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  ) {
maxrep = -1;
}









else {

maxrep = c - '0';
for (;;){

 { 
 if (! lexleft) {
 
if (gettext ("unfinished repeat count") != 0) {
 
dfaerror(gettext ("unfinished repeat count")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (!   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  ) {
break;
}









maxrep = 10 * maxrep + c - '0';
}
if (0 <= maxrep && maxrep < minrep) {
dfaerror (gettext ("malformed repeat count"));
}

}
}
else {
maxrep = minrep;
}
if (!(syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))){
if (c != '\\') {
dfaerror(gettext ("malformed repeat count"));
}


 { 
 if (! lexleft) {
 
if (gettext ("unfinished repeat count") != 0) {
 
dfaerror(gettext ("unfinished repeat count")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
}
if (c != '}') {
dfaerror(gettext ("malformed repeat count"));
}

laststart = 0;
return lasttok = REPMN;
case '|':
if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

if (backslash != ((syntax_bits & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
goto normal_char;
}

laststart = 1;
return lasttok = OR;
case '\n':
if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || backslash || !(syntax_bits & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
goto normal_char;
}



laststart = 1;
return lasttok = OR;
case '(':
if (backslash != ((syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
goto normal_char;
}

++parens;
laststart = 1;
return lasttok = LPAREN;
case ')':
if (backslash != ((syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
goto normal_char;
}

if (parens == 0 && syntax_bits & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

--parens;
laststart = 0;
return lasttok = RPAREN;
case '.':
if (backslash) {
goto normal_char;
}

zeroset(ccl);
notset(ccl);
if (!(syntax_bits & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
clrbit(eolbyte_1, ccl);
}

if (syntax_bits & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
clrbit('\0', ccl);
}

laststart = 0;
return lasttok = CSET + charclass_index(ccl);
case 'w':
case 'W':
if (!backslash || (syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
goto normal_char;
}

zeroset(ccl);
for (c2 = 0; c2 < (1 << 8); ++c2){
if ((  ((*__ctype_b_loc ())[(int) ((  c2  ))] & (unsigned short int) _ISalnum)   || (c2) == '_')) {
setbit(c2, ccl);
}}










if (c == 'W') {
notset(ccl);
}

laststart = 0;
return lasttok = CSET + charclass_index(ccl);
case '[':
if (backslash) {
goto normal_char;
}

zeroset(ccl);

 { 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (c == '^'){

 { 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
invert = 1;
}
else {
invert = 0;
}
do {

if (c == '[' && (syntax_bits & ((((unsigned long int) 1) << 1) << 1))) {
for (c1 = 0; prednames[c1].name; ++c1){
if (looking_at(prednames[c1].name)){


int (*pred)() = prednames[c1].pred;
if (case_fold && (pred == is_upper || pred == is_lower)) {
pred = is_alpha;
}


for (c2 = 0; c2 < (1 << 8); ++c2){
if ((*pred)(c2)) {
setbit(c2, ccl);
}}


lexptr += strlen(prednames[c1].name);
lexleft -= strlen(prednames[c1].name);

 { 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c1) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
goto skip;
}}
}

if (c == '\\' && (syntax_bits & ((unsigned long int) 1))) {
 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c) = (unsigned char) *lexptr++; 
 --lexleft; 
 };


 { 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c1) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (c1 == '-'){

 { 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c2) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
if (c2 == ']'){
--lexptr;
++lexleft;
c2 = c;
}
else {

if (c2 == '\\' && (syntax_bits & ((unsigned long int) 1))) {
  
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c2) = (unsigned char) *lexptr++; 
 --lexleft; 
 };



 { 
 if (! lexleft) {
 
if (gettext ("Unbalanced [") != 0) {
 
dfaerror(gettext ("Unbalanced [")); 
}
 else 
 {
return lasttok = END;
}

}
 (c1) = (unsigned char) *lexptr++; 
 --lexleft; 
 };
}
}
else {
c2 = c;
}
while (c <= c2) {

setbit(c, ccl);
if (case_fold){
if (  ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISupper)  ) {
setbit(tolower(c), ccl);
}










else{
if (  ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISlower)  ) {
setbit(toupper(c), ccl);
}
}
}









++c;
}
skip:
;
}
while ((c = c1) != ']');
if (invert){
notset(ccl);
if (syntax_bits & ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
clrbit(eolbyte_1, ccl);
}

}
laststart = 0;
return lasttok = CSET + charclass_index(ccl);
default:
normal_char:
laststart = 0;
if (case_fold &&   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISalpha)  ) {









zeroset(ccl);
setbit(c, ccl);
if (  ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISupper)  ) {
setbit(tolower(c), ccl);
}









else {
setbit(toupper(c), ccl);
}
return lasttok = CSET + charclass_index(ccl);
}
return c;
}
}
abort();
return END;
}
static token tok;
static int depth;
static void addtok(t) token t;


{

 if ((dfa->tindex) >= (dfa->talloc)) {
 
 while ((dfa->tindex) >= (dfa->talloc)) 
 (dfa->talloc) *= 2; 
 ((dfa->tokens) = (token *) xrealloc_1((ptr_t) (dfa->tokens), (dfa->talloc) * sizeof (token))); 
 };
dfa->tokens[dfa->tindex++] = t;
switch (t) {

case QMARK:
case STAR:
case PLUS:
break;
case CAT:
case OR:
case ORTOP:
--depth;
break;
default:
++dfa->nleaves;
case EMPTY:
++depth;
break;
}
if (depth > dfa->depth) {
dfa->depth = depth;
}

}

static void atom() {


if ((tok >= 0 && tok < (1 << 8)) || tok >= CSET || tok == BACKREF || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD) {



addtok(tok);
tok = lex();
}
else{
if (tok == LPAREN){
tok = lex();
regexp(0);
if (tok != RPAREN) {
dfaerror(gettext ("Unbalanced ("));
}

tok = lex();
}
else {
addtok(EMPTY);
}

}
}
static int nsubtoks(tindex) int tindex;


{
int ntoks1;
switch (dfa->tokens[tindex - 1]) {

default:
return 1;
case QMARK:
case STAR:
case PLUS:
return 1 + nsubtoks(tindex - 1);
case CAT:
case OR:
case ORTOP:
ntoks1 = nsubtoks(tindex - 1);
return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
}
}
static void copytoks(tindex, ntokens) int tindex, ntokens;


{
int i;
for (i = 0; i < ntokens; ++i) addtok(dfa->tokens[tindex + i]);

}
static void closure() {


int tindex, ntokens, i;
atom();
while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN){
if (tok == REPMN){

ntokens = nsubtoks(dfa->tindex);
tindex = dfa->tindex - ntokens;
if (maxrep < 0) {
addtok(PLUS);
}

if (minrep == 0) {
addtok(QMARK);
}

for (i = 1; i < minrep; ++i){
copytoks(tindex, ntokens);
addtok(CAT);
}
for (; i < maxrep; ++i){
copytoks(tindex, ntokens);
addtok(QMARK);
addtok(CAT);
}
tok = lex();
}
else {

addtok(tok);
tok = lex();
}}
}
static void branch() {


closure();
while (tok != RPAREN && tok != OR && tok >= 0) {

closure();
addtok(CAT);
}
}
static void regexp(toplevel) int toplevel;


{
branch();
while (tok == OR) {

tok = lex();
branch();
if (toplevel) {
addtok(ORTOP);
}

else {
addtok(OR);
}
}
}
void dfaparse(s, len, d) char *s;


size_t len;
struct dfa *d;
{
dfa = d;
lexstart = lexptr = s;
lexleft = len;
lasttok = END;
laststart = 1;
parens = 0;
if (! syntax_bits_set) {
dfaerror(gettext ("No syntax specified"));
}

tok = lex();
depth = d->depth;
regexp(1);
if (tok != END) {
dfaerror(gettext ("Unbalanced )"));
}

addtok(END - d->nregexps);
addtok(CAT);
if (d->nregexps) {
addtok(ORTOP);
}

++d->nregexps;
}
static void copy(src, dst) position_set *src;


position_set *dst;
{
int i;
for (i = 0; i < src->nelem; ++i) dst->elems[i] = src->elems[i];

dst->nelem = src->nelem;
}
static void insert(p, s) position p;


position_set *s;
{
int i;
position t1, t2;
for (i = 0; i < s->nelem && p.strchr < s->elems[i].strchr; ++i) continue;

if (i < s->nelem && p.strchr == s->elems[i].strchr) {
s->elems[i].constraint |= p.constraint;
}

else {

t1 = p;
++s->nelem;
while (i < s->nelem) {

t2 = s->elems[i];
s->elems[i++] = t1;
t1 = t2;
}
}
}
static void merge(s1, s2, m) position_set *s1;


position_set *s2;
position_set *m;
{
int i = 0, j = 0;
m->nelem = 0;
while (i < s1->nelem && j < s2->nelem){
if (s1->elems[i].strchr > s2->elems[j].strchr) {
m->elems[m->nelem++] = s1->elems[i++];
}


else{
if (s1->elems[i].strchr < s2->elems[j].strchr) {
m->elems[m->nelem++] = s2->elems[j++];
}

else {

m->elems[m->nelem] = s1->elems[i++];
m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
}
}}

while (i < s1->nelem) m->elems[m->nelem++] = s1->elems[i++];

while (j < s2->nelem) m->elems[m->nelem++] = s2->elems[j++];

}
static void delete(p, s) position p;


position_set *s;
{
int i;
for (i = 0; i < s->nelem; ++i){
if (p.strchr == s->elems[i].strchr) {
break;
}}


if (i < s->nelem) {
for (--s->nelem; i < s->nelem; ++i) s->elems[i] = s->elems[i + 1];
}


}
static int state_index(d, s, newline, letter) struct dfa *d;


position_set *s;
int newline;
int letter;
{
int hash = 0;
int constraint;
int i, j;
newline = newline ? 1 : 0;
letter = letter ? 1 : 0;
for (i = 0; i < s->nelem; ++i) hash ^= s->elems[i].strchr + s->elems[i].constraint;

for (i = 0; i < d->sindex; ++i){
if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem || newline != d->states[i].newline || letter != d->states[i].letter) {
continue;
}


for (j = 0; j < s->nelem; ++j){
if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint || s->elems[j].strchr != d->states[i].elems.elems[j].strchr) {
break;
}}




if (j == s->nelem) {
return i;
}

}

 if ((d->sindex) >= (d->salloc)) {
  
 while ((d->sindex) >= (d->salloc)) 
 (d->salloc) *= 2; 
 ((d->states) = (dfa_state *) xrealloc_1((ptr_t) (d->states), (d->salloc) * sizeof (dfa_state))); 
 };
d->states[i].hash = hash;
((d->states[i].elems.elems) = (position *) xmalloc_1((s->nelem) * sizeof (position)));
copy(s, &d->states[i].elems);
d->states[i].newline = newline;
d->states[i].letter = letter;
d->states[i].backref = 0;
d->states[i].constraint = 0;
d->states[i].first_end = 0;
for (j = 0; j < s->nelem; ++j){
if (d->tokens[s->elems[j].strchr] < 0){

constraint = s->elems[j].constraint;
if ((((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0))))) {
d->states[i].constraint |= constraint;
}




if (! d->states[i].first_end) {
d->states[i].first_end = d->tokens[s->elems[j].strchr];
}

}
else{
if (d->tokens[s->elems[j].strchr] == BACKREF){
d->states[i].constraint = 0xff;
d->states[i].backref = 1;
}
}}

++d->sindex;
return i;
}
static void epsclosure (position_set *s, struct dfa *d);
static void epsclosure(s, d) position_set *s;


struct dfa *d;
{
int i, j;
int *visited;
position p, old;
((visited) = (int *) xmalloc_1((d->tindex) * sizeof (int)));
for (i = 0; i < d->tindex; ++i) visited[i] = 0;

for (i = 0; i < s->nelem; ++i){
if (d->tokens[s->elems[i].strchr] >= (1 << 8) && d->tokens[s->elems[i].strchr] != BACKREF && d->tokens[s->elems[i].strchr] < CSET) {




old = s->elems[i];
p.constraint = old.constraint;
delete(s->elems[i], s);
if (visited[old.strchr]){
--i;
continue;
}
visited[old.strchr] = 1;
switch (d->tokens[old.strchr]) {

case BEGLINE:
p.constraint &= 0xcf;
break;
case ENDLINE:
p.constraint &= 0xaf;
break;
case BEGWORD:
p.constraint &= 0xf2;
break;
case ENDWORD:
p.constraint &= 0xf4;
break;
case LIMWORD:
p.constraint &= 0xf6;
break;
case NOTLIMWORD:
p.constraint &= 0xf9;
break;
default:
break;
}
for (j = 0; j < d->follows[old.strchr].nelem; ++j){
p.strchr = d->follows[old.strchr].elems[j].strchr;
insert(p, s);
}
i = -1;
}}
free(visited);
}

void dfaanalyze(d, searchflag) struct dfa *d;


int searchflag;
{
int *nullable;
int *nfirstpos;
position *firstpos;
int *nlastpos;
position *lastpos;
int *nalloc;
position_set tmp;
position_set merged;
int wants_newline;
int *o_nullable;
int *o_nfirst, *o_nlast;
position *o_firstpos, *o_lastpos;
int i, j;
position *pos;

d->searchflag = searchflag;
((nullable) = (int *) xmalloc_1((d->depth) * sizeof (int)));
o_nullable = nullable;
((nfirstpos) = (int *) xmalloc_1((d->depth) * sizeof (int)));
o_nfirst = nfirstpos;
((firstpos) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
o_firstpos = firstpos, firstpos += d->nleaves;
((nlastpos) = (int *) xmalloc_1((d->depth) * sizeof (int)));
o_nlast = nlastpos;
((lastpos) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
o_lastpos = lastpos, lastpos += d->nleaves;
((nalloc) = (int *) xmalloc_1((d->tindex) * sizeof (int)));
for (i = 0; i < d->tindex; ++i) nalloc[i] = 0;

((merged.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
((d->follows) = (position_set *) xcalloc((size_t)(d->tindex), sizeof (position_set)));
for (i = 0; i < d->tindex; ++i) switch (d->tokens[i]) {


case EMPTY:
*nullable++ = 1;
*nfirstpos++ = *nlastpos++ = 0;
break;
case STAR:
case PLUS:
tmp.nelem = nfirstpos[-1];
tmp.elems = firstpos;
pos = lastpos;
for (j = 0; j < nlastpos[-1]; ++j){
merge(&tmp, &d->follows[pos[j].strchr], &merged);

 if ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) {
  
 while ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) 
 (nalloc[pos[j].strchr]) *= 2; 
 ((d->follows[pos[j].strchr].elems) = (position *) xrealloc_1((ptr_t) (d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof (position))); 
 }
;
copy(&merged, &d->follows[pos[j].strchr]);
}
case QMARK:
if (d->tokens[i] != PLUS) {
nullable[-1] = 1;
}

break;
case CAT:
tmp.nelem = nfirstpos[-1];
tmp.elems = firstpos;
pos = lastpos + nlastpos[-1];
for (j = 0; j < nlastpos[-2]; ++j){
merge(&tmp, &d->follows[pos[j].strchr], &merged);

 if ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) {
  
 while ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) 
 (nalloc[pos[j].strchr]) *= 2; 
 ((d->follows[pos[j].strchr].elems) = (position *) xrealloc_1((ptr_t) (d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof (position))); 
 }
;
copy(&merged, &d->follows[pos[j].strchr]);
}
if (nullable[-2]) {
nfirstpos[-2] += nfirstpos[-1];
}

else {
firstpos += nfirstpos[-1];
}
--nfirstpos;
if (nullable[-1]) {
nlastpos[-2] += nlastpos[-1];
}

else {

pos = lastpos + nlastpos[-2];
for (j = nlastpos[-1] - 1; j >= 0; --j) pos[j] = lastpos[j];

lastpos += nlastpos[-2];
nlastpos[-2] = nlastpos[-1];
}
--nlastpos;
nullable[-2] = nullable[-1] && nullable[-2];
--nullable;
break;
case OR:
case ORTOP:
nfirstpos[-2] += nfirstpos[-1];
--nfirstpos;
nlastpos[-2] += nlastpos[-1];
--nlastpos;
nullable[-2] = nullable[-1] || nullable[-2];
--nullable;
break;
default:
*nullable++ = d->tokens[i] == BACKREF;
*nfirstpos++ = *nlastpos++ = 1;
--firstpos, --lastpos;
firstpos->strchr = lastpos->strchr = i;
firstpos->constraint = lastpos->constraint = 0xff;
nalloc[i] = 1;
((d->follows[i].elems) = (position *) xmalloc_1((nalloc[i]) * sizeof (position)));
break;
}

for (i = 0; i < d->tindex; ++i){
if (d->tokens[i] < (1 << 8) || d->tokens[i] == BACKREF || d->tokens[i] >= CSET) {




copy(&d->follows[i], &merged);
epsclosure(&merged, d);
if (d->follows[i].nelem < merged.nelem) {
((d->follows[i].elems) = (position *) xrealloc_1((ptr_t) (d->follows[i].elems), (merged.nelem) * sizeof (position)));
}

copy(&merged, &d->follows[i]);
}}
merged.nelem = 0;
for (i = 0; i < nfirstpos[-1]; ++i) insert(firstpos[i], &merged);

epsclosure(&merged, d);
wants_newline = 0;
for (i = 0; i < merged.nelem; ++i){
if ((((merged.elems[i].constraint) & 0xc0) >> 2 != ((merged.elems[i].constraint) & 0x30))) {
wants_newline = 1;
}}


d->salloc = 1;
d->sindex = 0;
((d->states) = (dfa_state *) xmalloc_1((d->salloc) * sizeof (dfa_state)));
state_index(d, &merged, wants_newline, 0);
free(o_nullable);
free(o_nfirst);
free(o_firstpos);
free(o_nlast);
free(o_lastpos);
free(nalloc);
free(merged.elems);
}

void dfastate(s, d, trans) int s;


struct dfa *d;
int trans[];
{
position_set grps[(1 << 8)];
charclass labels[(1 << 8)];
int ngrps = 0;
position pos;
charclass matches;
int matchesf;
charclass intersect;
int intersectf;
charclass leftovers;
int leftoversf;
static charclass letters;
static charclass newline;
position_set follows;
position_set tmp;
int state;
int wants_newline;
int state_newline;
int wants_letter;
int state_letter;
static int initialized;
int i, j, k;
if (! initialized){
initialized = 1;
for (i = 0; i < (1 << 8); ++i){
if ((  ((*__ctype_b_loc ())[(int) ((  i  ))] & (unsigned short int) _ISalnum)   || (i) == '_')) {
setbit(i, letters);
}}










setbit(eolbyte_1, newline);
}
zeroset(matches);
for (i = 0; i < d->states[s].elems.nelem; ++i){
pos = d->states[s].elems.elems[i];
if (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8)) {
setbit(d->tokens[pos.strchr], matches);
}

else{
if (d->tokens[pos.strchr] >= CSET) {
copyset(d->charclasses[d->tokens[pos.strchr] - CSET], matches);
}

else {
continue;
}

}
if (pos.constraint != 0xFF){
if (! ((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) ) {
clrbit(eolbyte_1, matches);
}


if (! ((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) ) {
for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j) matches[j] &= newline[j];
}



if (! ((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0))) ) {
for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j) matches[j] &= ~letters[j];
}



if (! ((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))) ) {
for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j) matches[j] &= letters[j];
}



for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))) && !matches[j]; ++j) continue;

if (j == (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) {
continue;
}

}
for (j = 0; j < ngrps; ++j){
if (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8) && !tstbit(d->tokens[pos.strchr], labels[j])) {
continue;
}


intersectf = 0;
for (k = 0; k < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++k) (intersect[k] = matches[k] & labels[j][k]) ? (intersectf = 1) : 0;

if (! intersectf) {
continue;
}

leftoversf = matchesf = 0;
for (k = 0; k < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++k){
int match = matches[k], label = labels[j][k];
(leftovers[k] = ~match & label) ? (leftoversf = 1) : 0;
(matches[k] = match & ~label) ? (matchesf = 1) : 0;
}
if (leftoversf){
copyset(leftovers, labels[ngrps]);
copyset(intersect, labels[j]);
((grps[ngrps].elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
copy(&grps[j], &grps[ngrps]);
++ngrps;
}
grps[j].elems[grps[j].nelem++] = pos;
if (! matchesf) {
break;
}

}
if (j == ngrps){
copyset(matches, labels[ngrps]);
zeroset(matches);
((grps[ngrps].elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
grps[ngrps].nelem = 1;
grps[ngrps].elems[0] = pos;
++ngrps;
}
}
((follows.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
((tmp.elems) = (position *) xmalloc_1((d->nleaves) * sizeof (position)));
if (d->searchflag){
wants_newline = 0;
wants_letter = 0;
for (i = 0; i < d->states[0].elems.nelem; ++i){
if ((((d->states[0].elems.elems[i].constraint) & 0xc0) >> 2 != ((d->states[0].elems.elems[i].constraint) & 0x30))) {
wants_newline = 1;
}

if ((((d->states[0].elems.elems[i].constraint) & 0x0c) >> 2 != ((d->states[0].elems.elems[i].constraint) & 0x03))) {
wants_letter = 1;
}

}
copy(&d->states[0].elems, &follows);
state = state_index(d, &follows, 0, 0);
if (wants_newline) {
state_newline = state_index(d, &follows, 1, 0);
}

else {
state_newline = state;
}
if (wants_letter) {
state_letter = state_index(d, &follows, 0, 1);
}

else {
state_letter = state;
}
for (i = 0; i < (1 << 8); ++i) trans[i] = ((  ((*__ctype_b_loc ())[(int) ((  i  ))] & (unsigned short int) _ISalnum)   || (i) == '_')) ? state_letter : state;









trans[eolbyte_1] = state_newline;
}
else {
for (i = 0; i < (1 << 8); ++i) trans[i] = -1;
}


for (i = 0; i < ngrps; ++i){
follows.nelem = 0;
for (j = 0; j < grps[i].nelem; ++j){
for (k = 0; k < d->follows[grps[i].elems[j].strchr].nelem; ++k){ insert(d->follows[grps[i].elems[j].strchr].elems[k], &follows);}}


if (d->searchflag) {
for (j = 0; j < d->states[0].elems.nelem; ++j) insert(d->states[0].elems.elems[j], &follows);
}


wants_newline = 0;
if (tstbit(eolbyte_1, labels[i])) {
for (j = 0; j < follows.nelem; ++j){
if ((((follows.elems[j].constraint) & 0xc0) >> 2 != ((follows.elems[j].constraint) & 0x30))) {
wants_newline = 1;
}}

}



wants_letter = 0;
for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j){
if (labels[i][j] & letters[j]) {
break;
}}


if (j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int)))) {
for (j = 0; j < follows.nelem; ++j){
if ((((follows.elems[j].constraint) & 0x0c) >> 2 != ((follows.elems[j].constraint) & 0x03))) {
wants_letter = 1;
}}

}



state = state_index(d, &follows, 0, 0);
if (wants_newline) {
state_newline = state_index(d, &follows, 1, 0);
}

else {
state_newline = state;
}
if (wants_letter) {
state_letter = state_index(d, &follows, 0, 1);
}

else {
state_letter = state;
}
for (j = 0; j < (((1 << 8) + (8 * sizeof (int)) - 1) / (8 * sizeof (int))); ++j){
for (k = 0; k < (8 * sizeof (int)); ++k){
if (labels[i][j] & 1 << k){


int c = j * (8 * sizeof (int)) + k;
if (c == eolbyte_1) {
trans[c] = state_newline;
}

else{
if ((  ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISalnum)   || (c) == '_')) {
trans[c] = state_letter;
}









else{
if (c < (1 << 8)) {
trans[c] = state;
}
}
}

}}}
}
for (i = 0; i < ngrps; ++i) free(grps[i].elems);

free(follows.elems);
free(tmp.elems);
}

static void build_state(s, d) int s;


struct dfa *d;
{
int *trans;
int i;
if (d->trcount >= 1024){
for (i = 0; i < d->tralloc; ++i){
if (d->trans[i]){

free((ptr_t) d->trans[i]);
d->trans[i] =   ((void *)0)  ;




}
else{
if (d->fails[i]){
free((ptr_t) d->fails[i]);
d->fails[i] =   ((void *)0)  ;




}
}}

d->trcount = 0;
}
++d->trcount;
d->success[s] = 0;
if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0)))) ) {
d->success[s] |= 4;
}


if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0)))) ) {
d->success[s] |= 2;
}


if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0)))) ) {
d->success[s] |= 1;
}


((trans) = (int *) xmalloc_1(((1 << 8)) * sizeof (int)));
dfastate(s, d, trans);
for (i = 0; i < (1 << 8); ++i){
if (trans[i] >= d->tralloc){

int oldalloc = d->tralloc;
while (trans[i] >= d->tralloc) d->tralloc *= 2;

((d->realtrans) = (int * *) xrealloc_1((ptr_t) (d->realtrans), (d->tralloc + 1) * sizeof (int *)));
d->trans = d->realtrans + 1;
((d->fails) = (int * *) xrealloc_1((ptr_t) (d->fails), (d->tralloc) * sizeof (int *)));
((d->success) = (int *) xrealloc_1((ptr_t) (d->success), (d->tralloc) * sizeof (int)));
((d->newlines) = (int *) xrealloc_1((ptr_t) (d->newlines), (d->tralloc) * sizeof (int)));
while (oldalloc < d->tralloc) {

d->trans[oldalloc] =   ((void *)0)  ;




d->fails[oldalloc++] =   ((void *)0)  ;




}
}}
d->newlines[s] = trans[eolbyte_1];
trans[eolbyte_1] = -1;
if (((*d).states[s].constraint)) {
d->fails[s] = trans;
}

else {
d->trans[s] = trans;
}
}
static void build_state_zero(d) struct dfa *d;


{
d->tralloc = 1;
d->trcount = 0;
((d->realtrans) = (int * *) xcalloc((size_t)(d->tralloc + 1), sizeof (int *)));
d->trans = d->realtrans + 1;
((d->fails) = (int * *) xcalloc((size_t)(d->tralloc), sizeof (int *)));
((d->success) = (int *) xmalloc_1((d->tralloc) * sizeof (int)));
((d->newlines) = (int *) xmalloc_1((d->tralloc) * sizeof (int)));
build_state(0, d);
}

char * dfaexec(d, begin, end, newline, count, backref) struct dfa *d;


char *begin;
char *end;
int newline;
int *count;
int *backref;
{
register int s, s1, tmp;
register unsigned char *p;
register int **trans, *t;
register unsigned char eol = eolbyte_1;
static int sbit[(1 << 8)];
static int sbit_init;
if (! sbit_init){
int i;
sbit_init = 1;
for (i = 0; i < (1 << 8); ++i) sbit[i] = ((  ((*__ctype_b_loc ())[(int) ((  i  ))] & (unsigned short int) _ISalnum)   || (i) == '_')) ? 2 : 1;









sbit[eol] = 4;
}
if (! d->tralloc) {
build_state_zero(d);
}

s = s1 = 0;
p = (unsigned char *) begin;
trans = d->trans;
*end = eol;
for (;;){
while ((t = trans[s]) != 0) {
s1 = t[*p++];
if ((t = trans[s1]) == 0) {
tmp = s ; s = s1 ; s1 = tmp ;
break;
}
s = t[*p++];
}
if (s >= 0 && p <= (unsigned char *) end && d->fails[s]){
if (d->success[s] & sbit[*p]){
if (backref) {
*backref = (d->states[s].backref != 0);
}

return (char *) p;
}
s1 = s;
s = d->fails[s][*p++];
continue;
}
if (count && (char *) p <= end && p[-1] == eol) {
++*count;
}

if ((char *) p > end) {
return   ((void *)0)  ;
}





if (s >= 0){
build_state(s, d);
trans = d->trans;
continue;
}
if (p[-1] == eol && newline){
s = d->newlines[s1];
continue;
}
s = 0;
}
}
void dfainit(d) struct dfa *d;


{
d->calloc = 1;
((d->charclasses) = (charclass *) xmalloc_1((d->calloc) * sizeof (charclass)));
d->cindex = 0;
d->talloc = 1;
((d->tokens) = (token *) xmalloc_1((d->talloc) * sizeof (token)));
d->tindex = d->depth = d->nleaves = d->nregexps = 0;
d->searchflag = 0;
d->tralloc = 0;
d->musts = 0;
}
void dfacomp(s, len, d, searchflag) char *s;


size_t len;
struct dfa *d;
int searchflag;
{
if (case_fold){
char *lcopy;
int i;
lcopy = malloc(len);
if (!lcopy) {
dfaerror(gettext ("out of memory"));
}

case_fold = 0;
for (i = 0; i < len; ++i){
if (  ((*__ctype_b_loc ())[(int) ((  (unsigned char) s[i]  ))] & (unsigned short int) _ISupper)  ) {
lcopy[i] = tolower ((unsigned char) s[i]);
}










else {
lcopy[i] = s[i];
}}
dfainit(d);
dfaparse(lcopy, len, d);
free(lcopy);
dfamust(d);
d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
case_fold = 1;
dfaparse(s, len, d);
dfaanalyze(d, searchflag);
}
else {

dfainit(d);
dfaparse(s, len, d);
dfamust(d);
dfaanalyze(d, searchflag);
}
}
void dfafree(d) struct dfa *d;


{
int i;
struct dfamust *dm, *ndm;
free((ptr_t) d->charclasses);
free((ptr_t) d->tokens);
for (i = 0; i < d->sindex; ++i) free((ptr_t) d->states[i].elems.elems);

free((ptr_t) d->states);
for (i = 0; i < d->tindex; ++i){
if (d->follows[i].elems) {
free((ptr_t) d->follows[i].elems);
}}


free((ptr_t) d->follows);
for (i = 0; i < d->tralloc; ++i){
if (d->trans[i]) {
free((ptr_t) d->trans[i]);
}


else{
if (d->fails[i]) {
free((ptr_t) d->fails[i]);
}

}}

if (d->realtrans) {
free((ptr_t) d->realtrans);
}
if (d->fails) {
free((ptr_t) d->fails);
}
if (d->newlines) {
free((ptr_t) d->newlines);
}
if (d->success) {
free((ptr_t) d->success);
}
for (dm = d->musts; dm; dm = ndm){
ndm = dm->next;
free(dm->must);
free((ptr_t) dm);
}
}

static char * icatalloc(old, new) char *old;


char *new;
{
char *result;
size_t oldsize, newsize;
newsize = (new ==   ((void *)0)  ) ? 0 : strlen(new);




if (old ==   ((void *)0)  ) {
oldsize = 0;
}





else{
if (newsize == 0) {
return old;
}

else {
oldsize = strlen(old);
}

}
if (old ==   ((void *)0)  ) {
result = (char *) malloc(newsize + 1);
}





else {
result = (char *) realloc((void *) old, oldsize + newsize + 1);
}
if (result !=   ((void *)0)   && new !=   ((void *)0)  ) {
(void) strcpy(result + oldsize, new);
}









return result;
}
static char * icpyalloc(string) char *string;


{
return icatalloc((char *)   ((void *)0)  , string);




}
static char * istrstr(lookin, lookfor) char *lookin;


char *lookfor;
{
char *cp;
size_t len;
len = strlen(lookfor);
for (cp = lookin; *cp != '\0'; ++cp){
if (strncmp(cp, lookfor, len) == 0) {
return cp;
}}


return   ((void *)0)  ;




}
static void ifree(cp) char *cp;


{
if (cp !=   ((void *)0)  ) {
free(cp);
}





}
static void freelist(cpp) char **cpp;


{
int i;
if (cpp ==   ((void *)0)  ) {
return;
}





for (i = 0; cpp[i] !=   ((void *)0)  ; ++i) {





free(cpp[i]);
cpp[i] =   ((void *)0)  ;




}
}
static char ** enlist(cpp, new, len) char **cpp;


char *new;
size_t len;
{
int i, j;
if (cpp ==   ((void *)0)  ) {
return   ((void *)0)  ;
}









if ((new = icpyalloc(new)) ==   ((void *)0)  ) {





freelist(cpp);
return   ((void *)0)  ;




}
new[len] = '\0';
for (i = 0; cpp[i] !=   ((void *)0)  ; ++i){
if (istrstr(cpp[i], new) !=   ((void *)0)  ) {










free(new);
return cpp;
}}
j = 0;
while (cpp[j] !=   ((void *)0)  ){
if (istrstr(new, cpp[j]) ==   ((void *)0)  ) {
++j;
}










else {

free(cpp[j]);
if (--i == j) {
break;
}

cpp[j] = cpp[i];
cpp[i] =   ((void *)0)  ;




}}
cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
if (cpp ==   ((void *)0)  ) {
return   ((void *)0)  ;
}









cpp[i] = new;
cpp[i + 1] =   ((void *)0)  ;




return cpp;
}
static char ** comsubs(left, right) char *left;


char *right;
{
char **cpp;
char *lcp;
char *rcp;
size_t i, len;
if (left ==   ((void *)0)   || right ==   ((void *)0)  ) {
return   ((void *)0)  ;
}













cpp = (char **) malloc(sizeof *cpp);
if (cpp ==   ((void *)0)  ) {
return   ((void *)0)  ;
}









cpp[0] =   ((void *)0)  ;




for (lcp = left; *lcp != '\0'; ++lcp){
len = 0;
rcp = strchr(right, *lcp);
while (rcp !=   ((void *)0)  ) {





for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i) continue;

if (i > len) {
len = i;
}

rcp = strchr(rcp + 1, *lcp);
}
if (len == 0) {
continue;
}

if ((cpp = enlist(cpp, lcp, len)) ==   ((void *)0)  ) {
break;
}





}
return cpp;
}
static char ** addlists(old, new) char **old;


char **new;
{
int i;
if (old ==   ((void *)0)   || new ==   ((void *)0)  ) {
return   ((void *)0)  ;
}













for (i = 0; new[i] !=   ((void *)0)  ; ++i) {





old = enlist(old, new[i], strlen(new[i]));
if (old ==   ((void *)0)  ) {
break;
}





}
return old;
}
static char ** inboth(left, right) char **left;


char **right;
{
char **both;
char **temp;
int lnum, rnum;
if (left ==   ((void *)0)   || right ==   ((void *)0)  ) {
return   ((void *)0)  ;
}













both = (char **) malloc(sizeof *both);
if (both ==   ((void *)0)  ) {
return   ((void *)0)  ;
}









both[0] =   ((void *)0)  ;




for (lnum = 0; left[lnum] !=   ((void *)0)  ; ++lnum) {





for (rnum = 0; right[rnum] !=   ((void *)0)  ; ++rnum) {





temp = comsubs(left[lnum], right[rnum]);
if (temp ==   ((void *)0)  ) {





freelist(both);
return   ((void *)0)  ;




}
both = addlists(both, temp);
freelist(temp);
free(temp);
if (both ==   ((void *)0)  ) {
return   ((void *)0)  ;
}









}
}
return both;
}
typedef struct {

char **in;
char *left;
char *right;
char *is;
} must;
static void resetmust(mp) must *mp;


{
mp->left[0] = mp->right[0] = mp->is[0] = '\0';
freelist(mp->in);
}
static void dfamust(dfa) struct dfa *dfa;


{
must *musts;
must *mp;
char *result;
int ri;
int i;
int exact;
token t;
static must must0;
struct dfamust *dm;
static char empty_string[] = "";
result = empty_string;
exact = 0;
musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
if (musts ==   ((void *)0)  ) {
return;
}





mp = musts;
for (i = 0; i <= dfa->tindex; ++i) mp[i] = must0;

for (i = 0; i <= dfa->tindex; ++i){
mp[i].in = (char **) malloc(sizeof *mp[i].in);
mp[i].left = malloc(2);
mp[i].right = malloc(2);
mp[i].is = malloc(2);
if (mp[i].in ==   ((void *)0)   || mp[i].left ==   ((void *)0)   || mp[i].right ==   ((void *)0)   || mp[i].is ==   ((void *)0)  ) {
goto done;
}


















mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
mp[i].in[0] =   ((void *)0)  ;




}

for (ri = 0; ri < dfa->tindex; ++ri){
switch (t = dfa->tokens[ri]) {

case LPAREN:
case RPAREN:
goto done;
case EMPTY:
case BEGLINE:
case ENDLINE:
case BEGWORD:
case ENDWORD:
case LIMWORD:
case NOTLIMWORD:
case BACKREF:
resetmust(mp);
break;
case STAR:
case QMARK:
if (mp <= musts) {
goto done;
}

--mp;
resetmust(mp);
break;
case OR:
case ORTOP:
if (mp < &musts[2]) {
goto done;
}

{
char **new;
must *lmp;
must *rmp;
int j, ln, rn, n;
rmp = --mp;
lmp = --mp;
if (strcmp(lmp->is, rmp->is) != 0) {
lmp->is[0] = '\0';
}

i = 0;
while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i]) ++i;

lmp->left[i] = '\0';
ln = strlen(lmp->right);
rn = strlen(rmp->right);
n = ln;
if (n > rn) {
n = rn;
}

for (i = 0; i < n; ++i){
if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1]) {
break;
}}


for (j = 0; j < i; ++j){ lmp->right[j] = lmp->right[(ln - i) + j];}

lmp->right[j] = '\0';
new = inboth(lmp->in, rmp->in);
if (new ==   ((void *)0)  ) {
goto done;
}





freelist(lmp->in);
free((char *) lmp->in);
lmp->in = new;
}
break;
case PLUS:
if (mp <= musts) {
goto done;
}

--mp;
mp->is[0] = '\0';
break;
case END:
if (mp != &musts[1]) {
goto done;
}

for (i = 0; musts[0].in[i] !=   ((void *)0)  ; ++i){
if (strlen(musts[0].in[i]) > strlen(result)) {
result = musts[0].in[i];
}}






if (strcmp(result, musts[0].is) == 0) {
exact = 1;
}

goto done;
case CAT:
if (mp < &musts[2]) {
goto done;
}

{
must *lmp;
must *rmp;
rmp = --mp;
lmp = --mp;
lmp->in = addlists(lmp->in, rmp->in);
if (lmp->in ==   ((void *)0)  ) {
goto done;
}





if (lmp->right[0] != '\0' && rmp->left[0] != '\0') {


char *tp;
tp = icpyalloc(lmp->right);
if (tp ==   ((void *)0)  ) {
goto done;
}





tp = icatalloc(tp, rmp->left);
if (tp ==   ((void *)0)  ) {
goto done;
}





lmp->in = enlist(lmp->in, tp, strlen(tp));
free(tp);
if (lmp->in ==   ((void *)0)  ) {
goto done;
}





}
if (lmp->is[0] != '\0'){
lmp->left = icatalloc(lmp->left, rmp->left);
if (lmp->left ==   ((void *)0)  ) {
goto done;
}





}
if (rmp->is[0] == '\0') {
lmp->right[0] = '\0';
}

lmp->right = icatalloc(lmp->right, rmp->right);
if (lmp->right ==   ((void *)0)  ) {
goto done;
}





if (lmp->is[0] != '\0' && rmp->is[0] != '\0'){
lmp->is = icatalloc(lmp->is, rmp->is);
if (lmp->is ==   ((void *)0)  ) {
goto done;
}





}
else {
lmp->is[0] = '\0';
}
}
break;
default:
if (t < END){
goto done;
}
else{
if (t == '\0'){
goto done;
}
else{
if (t >= CSET){
resetmust(mp);
}
else {

resetmust(mp);
mp->is[0] = mp->left[0] = mp->right[0] = t;
mp->is[1] = mp->left[1] = mp->right[1] = '\0';
mp->in = enlist(mp->in, mp->is, (size_t)1);
if (mp->in ==   ((void *)0)  ) {
goto done;
}





}
}
}
break;
}

++mp;
}
done:
if (strlen(result)){
dm = (struct dfamust *) malloc(sizeof (struct dfamust));
dm->exact = exact;
dm->must = malloc(strlen(result) + 1);
strcpy(dm->must, result);
dm->next = dfa->musts;
dfa->musts = dm;
}
mp = musts;
for (i = 0; i <= dfa->tindex; ++i){
freelist(mp[i].in);
ifree((char *) mp[i].in);
ifree(mp[i].left);
ifree(mp[i].right);
ifree(mp[i].is);
}
free((char *) mp);
}



struct kwsmatch {

int strchr;
char *beg[1];
size_t size[1];
};
typedef ptr_t kwset_t;
extern kwset_t kwsalloc (char *);
extern char *kwsincr (kwset_t, char *, size_t);
extern char *kwsprep (kwset_t);
extern char *kwsexec (kwset_t, char *, size_t, struct kwsmatch *);
extern void kwsfree (kwset_t);



struct _obstack_chunk {

char *limit;
struct _obstack_chunk *prev;
char contents[4];
};
struct obstack {

long chunk_size;
struct _obstack_chunk *chunk;
char *object_base;
char *next_free;
char *chunk_limit;
ptrdiff_t temp;
int alignment_mask;
struct _obstack_chunk *(*chunkfun) (void *, long);
void (*freefun) (void *, struct _obstack_chunk *);
void *extra_arg;
unsigned use_extra_arg:1;
unsigned maybe_empty_object:1;
unsigned alloc_failed:1;
};
extern void _obstack_newchunk (struct obstack *, int);
extern void _obstack_free (struct obstack *, void *);
extern int _obstack_begin (struct obstack *, int, int, void *(*) (long), void (*) (void *));
extern int _obstack_begin_1 (struct obstack *, int, int, void *(*) (void *, long), void (*) (void *, void *), void *);
extern int _obstack_memory_used (struct obstack *);

void obstack_init (struct obstack *obstack);
void * obstack_alloc (struct obstack *obstack, int size);
void * obstack_copy (struct obstack *obstack, void *address, int size);
void * obstack_copy0 (struct obstack *obstack, void *address, int size);
void obstack_free (struct obstack *obstack, void *block);
void obstack_blank (struct obstack *obstack, int size);
void obstack_grow (struct obstack *obstack, void *data, int size);
void obstack_grow0 (struct obstack *obstack, void *data, int size);
void obstack_1grow (struct obstack *obstack, int data_char);
void obstack_ptr_grow (struct obstack *obstack, void *data);
void obstack_int_grow (struct obstack *obstack, int data);
void * obstack_finish (struct obstack *obstack);
int obstack_object_size (struct obstack *obstack);
int obstack_room (struct obstack *obstack);
void obstack_make_room (struct obstack *obstack, int size);
void obstack_1grow_fast (struct obstack *obstack, int data_char);
void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
void obstack_int_grow_fast (struct obstack *obstack, int data);
void obstack_blank_fast (struct obstack *obstack, int size);
void * obstack_base (struct obstack *obstack);
void * obstack_next_free (struct obstack *obstack);
int obstack_alignment_mask (struct obstack *obstack);
int obstack_chunk_size (struct obstack *obstack);
int obstack_memory_used (struct obstack *obstack);

extern void (*obstack_alloc_failed_handler) (void);
extern int obstack_exit_failure;

extern char *xmalloc();

struct tree {

struct tree *llink;
struct tree *rlink;
struct trie *trie;
unsigned char label;
char balance;
};
struct trie {

unsigned int accepting;
struct tree *links;
struct trie *parent;
struct trie *next;
struct trie *fail;
int depth;
int shift;
int maxshift;
};
struct kwset {

struct obstack obstack;
int words;
struct trie *trie;
int mind;
int maxd;
unsigned char delta[(  (0x7f * 2 + 1)   + 1)];




struct trie *next[(  (0x7f * 2 + 1)   + 1)];




char *target;
int mind2;
char *trans;
};
static void enqueue (struct tree *, struct trie **);
static void treefails (register struct tree *, struct trie *, struct trie *);
static void treedelta (register struct tree *,register unsigned int, unsigned char *);
static int hasevery (register struct tree *, register struct tree *);
static void treenext (struct tree *, struct trie **);
static char * bmexec (kwset_t, char *, size_t);
static char * cwexec (kwset_t, char *, size_t, struct kwsmatch *);
kwset_t kwsalloc(trans) char *trans;


{
struct kwset *kwset;
kwset = (struct kwset *) xmalloc(sizeof (struct kwset));
if (!kwset) {
return 0;
}

_obstack_begin ((&kwset->obstack), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
kwset->words = 0;
kwset->trie = (struct trie *) __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((sizeof (struct trie))); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); });
if (!kwset->trie){
kwsfree((kwset_t) kwset);
return 0;
}
kwset->trie->accepting = 0;
kwset->trie->links = 0;
kwset->trie->parent = 0;
kwset->trie->next = 0;
kwset->trie->fail = 0;
kwset->trie->depth = 0;
kwset->trie->shift = 0;
kwset->mind = 0x7fffffff;
kwset->maxd = -1;
kwset->target = 0;
kwset->trans = trans;
return (kwset_t) kwset;
}
char * kwsincr(kws, text, len) kwset_t kws;


char *text;
size_t len;
{
struct kwset *kwset;
register struct trie *trie;
register unsigned char label;
register struct tree *link;
register int depth;
struct tree *links[12];
enum { L, R } dirs[12];
struct tree *t, *r, *l, *rl, *lr;
kwset = (struct kwset *) kws;
trie = kwset->trie;
text += len;
while (len--) {

label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
link = trie->links;
links[0] = (struct tree *) &trie->links;
dirs[0] = L;
depth = 1;
while (link && label != link->label) {

links[depth] = link;
if (label < link->label) {
dirs[depth++] = L, link = link->llink;
}

else {
dirs[depth++] = R, link = link->rlink;
}
}
if (!link){
link = (struct tree *) __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((sizeof (struct tree))); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); }) ;


if (!link) {
return gettext ("memory exhausted");
}

link->llink = 0;
link->rlink = 0;
link->trie = (struct trie *) __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((sizeof (struct trie))); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); }) ;


if (!link->trie) {
return gettext ("memory exhausted");
}

link->trie->accepting = 0;
link->trie->links = 0;
link->trie->parent = trie;
link->trie->next = 0;
link->trie->fail = 0;
link->trie->depth = trie->depth + 1;
link->trie->shift = 0;
link->label = label;
link->balance = 0;
if (dirs[--depth] == L) {
links[depth]->llink = link;
}

else {
links[depth]->rlink = link;
}
while (depth && !links[depth]->balance) {

if (dirs[depth] == L) {
--links[depth]->balance;
}

else {
++links[depth]->balance;
}
--depth;
}
if (depth && ((dirs[depth] == L && --links[depth]->balance) || (dirs[depth] == R && ++links[depth]->balance))) {


switch (links[depth]->balance) {

case (char) -2:
switch (dirs[depth + 1]) {

case L:
r = links[depth], t = r->llink, rl = t->rlink;
t->rlink = r, r->llink = rl;
t->balance = r->balance = 0;
break;
case R:
r = links[depth], l = r->llink, t = l->rlink;
rl = t->rlink, lr = t->llink;
t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
l->balance = t->balance != 1 ? 0 : -1;
r->balance = t->balance != (char) -1 ? 0 : 1;
t->balance = 0;
break;
default:
abort ();
}
break;
case 2:
switch (dirs[depth + 1]) {

case R:
l = links[depth], t = l->rlink, lr = t->llink;
t->llink = l, l->rlink = lr;
t->balance = l->balance = 0;
break;
case L:
l = links[depth], r = l->rlink, t = r->llink;
lr = t->llink, rl = t->rlink;
t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
l->balance = t->balance != 1 ? 0 : -1;
r->balance = t->balance != (char) -1 ? 0 : 1;
t->balance = 0;
break;
default:
abort ();
}
break;
default:
abort ();
}
if (dirs[depth - 1] == L) {
links[depth - 1]->llink = t;
}

else {
links[depth - 1]->rlink = t;
}
}
}
trie = link->trie;
}
if (!trie->accepting) {
trie->accepting = 1 + 2 * kwset->words;
}

++kwset->words;
if (trie->depth < kwset->mind) {
kwset->mind = trie->depth;
}

if (trie->depth > kwset->maxd) {
kwset->maxd = trie->depth;
}

return 0;
}
static void enqueue(tree, last) struct tree *tree;


struct trie **last;
{
if (!tree) {
return;
}

enqueue(tree->llink, last);
enqueue(tree->rlink, last);
(*last) = (*last)->next = tree->trie;
}
static void treefails(tree, fail, recourse) register struct tree *tree;


struct trie *fail;
struct trie *recourse;
{
register struct tree *link;
if (!tree) {
return;
}

treefails(tree->llink, fail, recourse);
treefails(tree->rlink, fail, recourse);
while (fail) {

link = fail->links;
while (link && tree->label != link->label){
if (tree->label < link->label) {
link = link->llink;
}


else {
link = link->rlink;
}}
if (link){
tree->trie->fail = link->trie;
return;
}
fail = fail->fail;
}
tree->trie->fail = recourse;
}
static void treedelta(tree, depth, delta) register struct tree *tree;


register unsigned int depth;
unsigned char delta[];
{
if (!tree) {
return;
}

treedelta(tree->llink, depth, delta);
treedelta(tree->rlink, depth, delta);
if (depth < delta[tree->label]) {
delta[tree->label] = depth;
}

}
static int hasevery(a, b) register struct tree *a;


register struct tree *b;
{
if (!b) {
return 1;
}

if (!hasevery(a, b->llink)) {
return 0;
}

if (!hasevery(a, b->rlink)) {
return 0;
}

while (a && b->label != a->label){
if (b->label < a->label) {
a = a->llink;
}


else {
a = a->rlink;
}}
return !!a;
}
static void treenext(tree, next) struct tree *tree;


struct trie *next[];
{
if (!tree) {
return;
}

treenext(tree->llink, next);
treenext(tree->rlink, next);
next[tree->label] = tree->trie;
}
char * kwsprep(kws) kwset_t kws;


{
register struct kwset *kwset;
register int i;
register struct trie *curr, *fail;
register char *trans;
unsigned char delta[(  (0x7f * 2 + 1)   + 1)];




struct trie *last, *next[(  (0x7f * 2 + 1)   + 1)];




kwset = (struct kwset *) kws;
if (kwset->mind < 256) {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) delta[i] = kwset->mind;
}






else {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) delta[i] = 255;
}






if (kwset->words == 1 && kwset->trans == 0){
kwset->target = __extension__ ({ struct obstack *__h = (&kwset->obstack); __extension__ ({ struct obstack *__o = (__h); int __len = ((kwset->mind)); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); __o->next_free += __len; (void) 0; }); __extension__ ({ struct obstack *__o1 = (__h); void *value; value = (void *) __o1->object_base; if (__o1->next_free == value) __o1->maybe_empty_object = 1; __o1->next_free = (((((__o1->next_free) - (char *) 0)+__o1->alignment_mask) & ~ (__o1->alignment_mask)) + (char *) 0); if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; value; }); });
for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i){
kwset->target[i] = curr->links->label;
curr = curr->links->trie;
}
for (i = 0; i < kwset->mind; ++i) delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);

kwset->mind2 = kwset->mind;
for (i = 0; i < kwset->mind - 1; ++i){
if (kwset->target[i] == kwset->target[kwset->mind - 1]) {
kwset->mind2 = kwset->mind - (i + 1);
}}


}
else {

for (curr = last = kwset->trie; curr; curr = curr->next){
enqueue(curr->links, &last);
curr->shift = kwset->mind;
curr->maxshift = kwset->mind;
treedelta(curr->links, curr->depth, delta);
treefails(curr->links, curr->fail, kwset->trie);
for (fail = curr->fail; fail; fail = fail->fail){
if (!hasevery(fail->links, curr->links)){
if (curr->depth - fail->depth < fail->shift) {
fail->shift = curr->depth - fail->depth;
}

}


if (curr->accepting && fail->maxshift > curr->depth - fail->depth) {
fail->maxshift = curr->depth - fail->depth;
}

}
}
for (curr = kwset->trie->next; curr; curr = curr->next){
if (curr->maxshift > curr->parent->maxshift) {
curr->maxshift = curr->parent->maxshift;
}

if (curr->shift > curr->maxshift) {
curr->shift = curr->maxshift;
}

}
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) next[i] = 0;





treenext(kwset->trie->links, next);
if ((trans = kwset->trans) != 0) {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) kwset->next[i] = next[(unsigned char) trans[i]];
}






else {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) kwset->next[i] = next[i];
}






}
if ((trans = kwset->trans) != 0) {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) kwset->delta[i] = delta[(unsigned char) trans[i]];
}






else {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) kwset->delta[i] = delta[i];
}






return 0;
}
static char * bmexec(kws, text, size) kwset_t kws;


char *text;
size_t size;
{
struct kwset *kwset;
register unsigned char *d1;
register char *ep, *sp, *tp;
register int d, gc, i, len, md2;
kwset = (struct kwset *) kws;
len = kwset->mind;
if (len == 0) {
return text;
}

if (len > size) {
return 0;
}

if (len == 1) {
return memchr(text, kwset->target[0], size);
}

d1 = kwset->delta;
sp = kwset->target + len;
gc = ((unsigned char) (sp[-2]));
md2 = kwset->mind2;
tp = text + len;
if (size > 12 * len) {
for (ep = text + size - 11 * len;;){

while (tp <= ep) {

d = d1[((unsigned char) (tp[-1]))], tp += d;
d = d1[((unsigned char) (tp[-1]))], tp += d;
if (d == 0) {
goto found;
}

d = d1[((unsigned char) (tp[-1]))], tp += d;
d = d1[((unsigned char) (tp[-1]))], tp += d;
d = d1[((unsigned char) (tp[-1]))], tp += d;
if (d == 0) {
goto found;
}

d = d1[((unsigned char) (tp[-1]))], tp += d;
d = d1[((unsigned char) (tp[-1]))], tp += d;
d = d1[((unsigned char) (tp[-1]))], tp += d;
if (d == 0) {
goto found;
}

d = d1[((unsigned char) (tp[-1]))], tp += d;
d = d1[((unsigned char) (tp[-1]))], tp += d;
}
break;
found:
if (((unsigned char) (tp[-2])) == gc){
for (i = 3; i <= len && ((unsigned char) (tp[-i])) == ((unsigned char) (sp[-i])); ++i) ;

if (i > len) {
return tp - len;
}

}
tp += md2;
}
}

ep = text + size;
d = d1[((unsigned char) (tp[-1]))];
while (d <= ep - tp) {

d = d1[((unsigned char) ((tp += d)[-1]))];
if (d != 0) {
continue;
}

if (((unsigned char) (tp[-2])) == gc){
for (i = 3; i <= len && ((unsigned char) (tp[-i])) == ((unsigned char) (sp[-i])); ++i) ;

if (i > len) {
return tp - len;
}

}
d = md2;
}
return 0;
}
static char * cwexec(kws, text, len, kwsmatch) kwset_t kws;


char *text;
size_t len;
struct kwsmatch *kwsmatch;
{
struct kwset *kwset;
struct trie **next, *trie, *accept;
char *beg, *lim, *mch, *lmch;
register unsigned char c, *delta;
register int d;
register char *end, *qlim;
register struct tree *tree;
register char *trans;
kwset = (struct kwset *) kws;
if (len < kwset->mind) {
return 0;
}

next = kwset->next;
delta = kwset->delta;
trans = kwset->trans;
lim = text + len;
end = text;
if ((d = kwset->mind) != 0) {
mch = 0;
}

else {

mch = text, accept = kwset->trie;
goto match;
}
if (len >= 4 * kwset->mind) {
qlim = lim - 4 * kwset->mind;
}

else {
qlim = 0;
}
while (lim - end >= d) {

if (qlim && end <= qlim){
end += d - 1;
while ((d = delta[c = *end]) && end < qlim) {

end += d;
end += delta[(unsigned char) *end];
end += delta[(unsigned char) *end];
}
++end;
}
else {
d = delta[c = (end += d)[-1]];
}
if (d) {
continue;
}

beg = end - 1;
trie = next[c];
if (trie->accepting){
mch = beg;
accept = trie;
}
d = trie->shift;
while (beg > text) {

c = trans ? trans[(unsigned char) *--beg] : *--beg;
tree = trie->links;
while (tree && c != tree->label){
if (c < tree->label) {
tree = tree->llink;
}


else {
tree = tree->rlink;
}}
if (tree){
trie = tree->trie;
if (trie->accepting){
mch = beg;
accept = trie;
}
}
else {
break;
}
d = trie->shift;
}
if (mch) {
goto match;
}

}
return 0;
match:
if (lim - mch > kwset->maxd) {
lim = mch + kwset->maxd;
}

lmch = 0;
d = 1;
while (lim - end >= d) {

if ((d = delta[c = (end += d)[-1]]) != 0) {
continue;
}

beg = end - 1;
if (!(trie = next[c])){
d = 1;
continue;
}
if (trie->accepting && beg <= mch){
lmch = beg;
accept = trie;
}
d = trie->shift;
while (beg > text) {

c = trans ? trans[(unsigned char) *--beg] : *--beg;
tree = trie->links;
while (tree && c != tree->label){
if (c < tree->label) {
tree = tree->llink;
}


else {
tree = tree->rlink;
}}
if (tree){
trie = tree->trie;
if (trie->accepting && beg <= mch){
lmch = beg;
accept = trie;
}
}
else {
break;
}
d = trie->shift;
}
if (lmch){
mch = lmch;
goto match;
}
if (!d) {
d = 1;
}

}
if (kwsmatch){
kwsmatch->strchr = accept->accepting / 2;
kwsmatch->beg[0] = mch;
kwsmatch->size[0] = accept->depth;
}
return mch;
}

char * kwsexec(kws, text, size, kwsmatch) kwset_t kws;


char *text;
size_t size;
struct kwsmatch *kwsmatch;
{
struct kwset *kwset;
char *ret;
kwset = (struct kwset *) kws;
if (kwset->words == 1 && kwset->trans == 0){
ret = bmexec(kws, text, size);
if (kwsmatch != 0 && ret != 0){
kwsmatch->strchr = 0;
kwsmatch->beg[0] = ret;
kwsmatch->size[0] = kwset->mind;
}
return ret;
}
else {
return cwexec(kws, text, size, kwsmatch);
}
}
void kwsfree(kws) kwset_t kws;


{
struct kwset *kwset;
kwset = (struct kwset *) kws;
__extension__ ({ struct obstack *__o = (&kwset->obstack); void *__obj = (0); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = __obj; else (obstack_free) (__o, __obj); });
free(kws);
}







static char re_syntax_table[256];
static void init_syntax_once () {


register int c;
static int done = 0;
if (done) {
return;
}

(memset (re_syntax_table, '\0', sizeof re_syntax_table), (re_syntax_table));
for (c = 0; c < 256; c++){
if ((1 &&   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISalnum)  )) {
re_syntax_table[c] = 1;
}}










re_syntax_table['_'] = 1;
done = 1;
}

typedef char boolean;
static int re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct re_registers *regs, int stop) ;

typedef enum {

no_op = 0, succeed, exactn, anychar, charset, charset_not,  start_memory,  stop_memory, duplicate, begline, endline, begbuf, endbuf, jump, jump_past_alt, on_failure_jump, on_failure_keep_string_jump, pop_failure_jump,  maybe_pop_jump, dummy_failure_jump, push_dummy_failure, succeed_n, jump_n, set_number_at, wordchar, notwordchar, wordbeg, wordend, wordbound, notwordbound  } re_opcode_t;



































reg_syntax_t re_syntax_options;

reg_syntax_t re_set_syntax (syntax) reg_syntax_t syntax;


{
reg_syntax_t ret = re_syntax_options;
re_syntax_options = syntax;
return ret;
}

static const char *re_error_msgid[] = {

"Success", "No match", "Invalid regular expression", "Invalid collation character", "Invalid character class name", "Trailing backslash", "Invalid back reference", "Unmatched [ or [^", "Unmatched ( or \\(", "Unmatched \\{", "Invalid content of \\{\\}", "Invalid range end", "Memory exhausted", "Invalid preceding regular expression", "Premature end of regular expression", "Regular expression too big", "Unmatched ) or \\)", };


















int re_max_failures = 20000;
union fail_stack_elt {

unsigned char *pointer;
int integer;
};
typedef union fail_stack_elt fail_stack_elt_t;
typedef struct {

fail_stack_elt_t *stack;
unsigned size;
unsigned avail;
} fail_stack_type;

typedef union {

fail_stack_elt_t word;
struct {

unsigned match_null_string_p : 2;
unsigned is_active : 1;
unsigned matched_something : 1;
unsigned ever_matched_something : 1;
} bits;
} register_info_type;

static char reg_unset_dummy;
static reg_errcode_t regex_compile (const char *pattern, size_t size, reg_syntax_t syntax, struct re_pattern_buffer *bufp) ;

static void store_op1 (re_opcode_t op, unsigned char *loc, int arg);
static void store_op2 (re_opcode_t op, unsigned char *loc, int arg1, int arg2) ;

static void insert_op1 (re_opcode_t op, unsigned char *loc, int arg, unsigned char *end) ;

static void insert_op2 (re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end) ;

static boolean at_begline_loc_p (const char *pattern, const char *p, reg_syntax_t syntax) ;

static boolean at_endline_loc_p (const char *p, const char *pend, reg_syntax_t syntax) ;

static reg_errcode_t compile_range (const char **p_ptr, const char *pend, char *translate, reg_syntax_t syntax, unsigned char *b) ;


typedef unsigned regnum_t;
typedef long pattern_offset_t;
typedef struct {

pattern_offset_t begalt_offset;
pattern_offset_t fixup_alt_jump;
pattern_offset_t inner_group_offset;
pattern_offset_t laststart_offset;
regnum_t regnum;
} compile_stack_elt_t;
typedef struct {

compile_stack_elt_t *stack;
unsigned size;
unsigned avail;
} compile_stack_type;

static boolean group_in_compile_stack (compile_stack_type compile_stack, regnum_t regnum) ;


static reg_errcode_t regex_compile (pattern, size, syntax, bufp) const char *pattern;


size_t size;
reg_syntax_t syntax;
struct re_pattern_buffer *bufp;
{
register unsigned char c, c1;
const char *p1;
register unsigned char *b;
compile_stack_type compile_stack;
const char *p = pattern;
const char *pend = pattern + size;
char * translate = bufp->translate;
unsigned char *pending_exact = 0;
unsigned char *laststart = 0;
unsigned char *begalt;
const char *beg_interval;
unsigned char *fixup_alt_jump = 0;
regnum_t regnum = 0;

compile_stack.stack = ((compile_stack_elt_t *) xmalloc ((32) * sizeof (compile_stack_elt_t)));
if (compile_stack.stack ==   ((void *)0)  ) {
return REG_ESPACE;
}





compile_stack.size = 32;
compile_stack.avail = 0;
bufp->syntax = syntax;
bufp->fastmap_accurate = 0;
bufp->not_bol = bufp->not_eol = 0;
bufp->used = 0;
bufp->re_nsub = 0;
init_syntax_once ();
if (bufp->allocated == 0){
if (bufp->buffer){
((bufp->buffer) = (unsigned char *) realloc (bufp->buffer, (32) * sizeof (unsigned char)));
}
else {

bufp->buffer = ((unsigned char *) xmalloc ((32) * sizeof (unsigned char)));
}
if (!bufp->buffer) {
 
return (free (compile_stack.stack), REG_ESPACE);
}
bufp->allocated = 32;
}
begalt = b = bufp->buffer;
while (p != pend) {


 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
switch (c) {

case '^':
{
if ( p == pattern + 1 || syntax & (((((unsigned long int) 1) << 1) << 1) << 1) || at_begline_loc_p (pattern, p, syntax)) {
 
do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (begline); 
 } while (0);
}









else {
goto normal_char;
}
}
break;
case '$':
{
if ( p == pend || syntax & (((((unsigned long int) 1) << 1) << 1) << 1) || at_endline_loc_p (p, pend, syntax)) {
 
do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)){ 
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
  
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (endline); 
 } while (0);
}









else {
goto normal_char;
}
}
break;
case '+':
case '?':
if ((syntax & (((unsigned long int) 1) << 1)) || (syntax & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
goto normal_char;
}


handle_plus:
case '*':
if (!laststart){
if (syntax & (((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1)) {
 
return (free (compile_stack.stack), REG_BADRPT);
}

else{
if (!(syntax & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1))) {
goto normal_char;
}

}

}
{
boolean keep_string_p = 0;
char zero_times_ok = 0, many_times_ok = 0;
for (;;){
zero_times_ok |= c != '+';
many_times_ok |= c != '?';
if (p == pend) {
break;
}


 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
if (c == '*' || (!(syntax & (((unsigned long int) 1) << 1)) && (c == '+' || c == '?'))) {
;
}


else{
if (syntax & (((unsigned long int) 1) << 1) && c == '\\'){
if (p == pend) {
 
return (free (compile_stack.stack), REG_EESCAPE);
}

 do {if (p == pend) {
return REG_EEND; 
}
 c1 = (unsigned char) *p++; 
 if (translate) {
c1 = (unsigned char) translate[c1]; 
}
 } while (0);
if (!(c1 == '+' || c1 == '?')){
p--;
p--;
break;
}
c = c1;
}
else {

p--;
break;
}
}

}
if (!laststart) {
break;
}

if (many_times_ok){

;

 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
  
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);




if (
 (translate ? (char) translate[(unsigned char) (*(p - 2))] : (*(p - 2))) == 
 (translate ? (char) translate[(unsigned char) ('.')] : ('.')) && zero_times_ok && p < pend && 
 (translate ? (char) translate[(unsigned char) (*p)] : (*p)) == 
 (translate ? (char) translate[(unsigned char) ('\n')] : ('\n')) && !(syntax & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1))) {





 store_op1 (jump, b, (int) ((laststart) - (b) - 3));
keep_string_p = 1;
}
else 
 {
store_op1 (maybe_pop_jump, b, (int) ((laststart - 3) - (b) - 3));
}
b += 3;
}

 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
  
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);





 insert_op1 (keep_string_p ? on_failure_keep_string_jump : on_failure_jump, laststart, (int) ((b + 3) - (laststart) - 3), b) ;

pending_exact = 0;
b += 3;
if (!zero_times_ok){

 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
  
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);





 insert_op1 (dummy_failure_jump, laststart, (int) ((laststart + 6) - (laststart) - 3), b);
b += 3;
}
}
break;
case '.':
laststart = b;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
  
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (anychar); 
 } while (0);




break;
case '[':
{
boolean had_char_class = 0;
if (p == pend) {
 
return (free (compile_stack.stack), REG_EBRACK);
}

 while ((unsigned long) (b - bufp->buffer + (34)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)){ 
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
  
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);




laststart = b;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (*p == '^' ? charset_not : charset); 
 } while (0);




if (*p == '^') {
p++;
}

p1 = p;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16)) {
 
return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)) {
 
bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ) {
 
return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer) {
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {
 
fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart) {
 
laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact) {
 
pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) ((1 << 8) / 8); 
 } while (0);




(memset (b, '\0', (1 << 8) / 8), (b));
if ((re_opcode_t) b[-2] == charset_not && (syntax & ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
 
(b[((unsigned char) ('\n')) / 8] 
 |= 1 << (((unsigned char) '\n') % 8));
}



for (;;){
if (p == pend) {
 
return (free (compile_stack.stack), REG_EBRACK);
}

 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
if ((syntax & ((unsigned long int) 1)) && c == '\\'){
if (p == pend) {
 
return (free (compile_stack.stack), REG_EESCAPE);
}

 do {if (p == pend) {
return REG_EEND; 
}
 c1 = (unsigned char) *p++; 
 if (translate) {
c1 = (unsigned char) translate[c1]; 
}
 } while (0);

 (b[((unsigned char) (c1)) / 8] 
 |= 1 << (((unsigned char) c1) % 8));
continue;
}
if (c == ']' && p != p1 + 1) {
break;
}

if (had_char_class && c == '-' && *p != ']'){ 
 
return (free (compile_stack.stack), REG_ERANGE);
}

if (c == '-' && !(p - 2 >= pattern && p[-2] == '[') && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^') && *p != ']') {




reg_errcode_t ret = compile_range (&p, pend, translate, syntax, b);
if (ret != REG_NOERROR) {
 
return (free (compile_stack.stack), ret);
}
}
else{
if (p[0] == '-' && p[1] != ']'){
reg_errcode_t ret;

 do {if (p == pend) {
return REG_EEND; 
}
 c1 = (unsigned char) *p++; 
 if (translate) {
c1 = (unsigned char) translate[c1]; 
}
 } while (0);
ret = compile_range (&p, pend, translate, syntax, b);
if (ret != REG_NOERROR) {
 
return (free (compile_stack.stack), ret);
}
}
else{
if (syntax & ((((unsigned long int) 1) << 1) << 1) && c == '[' && *p == ':'){
char str[6 + 1];

 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
c1 = 0;
if (p == pend) {
 
return (free (compile_stack.stack), REG_EBRACK);
}
for (;;){

 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
if ((c == ':' && *p == ']') || p == pend) {
break;
}

if (c1 < 6) {
str[c1++] = c;
}

else {
str[0] = '\0';
}
}
str[c1] = '\0';
if (c == ':' && *p == ']'){

int ch;
boolean is_alnum = ((strcmp (str, "alnum") == 0));
boolean is_alpha = ((strcmp (str, "alpha") == 0));
boolean is_blank = ((strcmp (str, "blank") == 0));
boolean is_cntrl = ((strcmp (str, "cntrl") == 0));
boolean is_digit = ((strcmp (str, "digit") == 0));
boolean is_graph = ((strcmp (str, "graph") == 0));
boolean is_lower = ((strcmp (str, "lower") == 0));
boolean is_print = ((strcmp (str, "print") == 0));
boolean is_punct = ((strcmp (str, "punct") == 0));
boolean is_space = ((strcmp (str, "space") == 0));
boolean is_upper = ((strcmp (str, "upper") == 0));
boolean is_xdigit = ((strcmp (str, "xdigit") == 0));
if (!
 (((strcmp (str, "alpha") == 0)) || ((strcmp (str, "upper") == 0)) 
 || ((strcmp (str, "lower") == 0)) || ((strcmp (str, "digit") == 0)) 
 || ((strcmp (str, "alnum") == 0)) || ((strcmp (str, "xdigit") == 0)) 
 || ((strcmp (str, "space") == 0)) || ((strcmp (str, "print") == 0)) 
 || ((strcmp (str, "punct") == 0)) || ((strcmp (str, "graph") == 0)) 
 || ((strcmp (str, "cntrl") == 0)) || ((strcmp (str, "blank") == 0)))) {
 
return (free (compile_stack.stack), REG_ECTYPE);
}


 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
if (p == pend) {
 
return (free (compile_stack.stack), REG_EBRACK);
}
for (ch = 0; ch < 1 << 8; ch++){
if ( (is_alnum && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISalnum)  )) || (is_alpha && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISalpha)  )) || (is_blank && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISblank)  )) || (is_cntrl && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _IScntrl)  ))) {
 
(b[((unsigned char) (ch)) / 8] 
 |= 1 << (((unsigned char) ch) % 8));
}





































if ( (is_digit && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISdigit)  )) || (is_graph && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISgraph)  )) || (is_lower && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISlower)  )) || (is_print && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISprint)  ))) {
 
(b[((unsigned char) (ch)) / 8] 
 |= 1 << (((unsigned char) ch) % 8));
}





































if ( (is_punct && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISpunct)  )) || (is_space && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISspace)  )) || (is_upper && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISupper)  )) || (is_xdigit && (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISxdigit)  ))){ 
 
(b[((unsigned char) (ch)) / 8] 
 |= 1 << (((unsigned char) ch) % 8));
}





































if ( translate && (is_upper || is_lower) && ((1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISupper)  ) || (1 &&   ((*__ctype_b_loc ())[(int) ((  ch  ))] & (unsigned short int) _ISlower)  ))) {
 
(b[((unsigned char) (ch)) / 8] 
 |= 1 << (((unsigned char) ch) % 8));
}



















}
had_char_class = 1;
}
else {

c1++;
while (c1--) p--;


 (b[((unsigned char) ('[')) / 8] 
 |= 1 << (((unsigned char) '[') % 8));

 (b[((unsigned char) (':')) / 8] 
 |= 1 << (((unsigned char) ':') % 8));
had_char_class = 0;
}
}
else {

had_char_class = 0;

 (b[((unsigned char) (c)) / 8] 
 |= 1 << (((unsigned char) c) % 8));
}
}
}
}
while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) b[-1]--;

b += b[-1];
}
break;
case '(':
if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto handle_open;
}

else {
goto normal_char;
}
case ')':
if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto handle_close;
}

else {
goto normal_char;
}
case '\n':
if (syntax & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto handle_alt;
}

else {
goto normal_char;
}
case '|':
if (syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto handle_alt;
}

else {
goto normal_char;
}
case '{':
if (syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto handle_interval;
}

else {
goto normal_char;
}
case '\\':
if (p == pend) {
 
return (free (compile_stack.stack), REG_EESCAPE);
}

 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 } while (0);
switch (c) {

case '(':
if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_backslash;
}

handle_open:
bufp->re_nsub++;
regnum++;
if ((compile_stack.avail == compile_stack.size)){
((compile_stack.stack) = (compile_stack_elt_t *) realloc (compile_stack.stack, (compile_stack.size << 1) * sizeof (compile_stack_elt_t))) ;

if (compile_stack.stack ==   ((void *)0)  ) {
return REG_ESPACE;
}




compile_stack.size <<= 1;
}
(compile_stack.stack[compile_stack.avail]).begalt_offset = begalt - bufp->buffer;
(compile_stack.stack[compile_stack.avail]).fixup_alt_jump = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
(compile_stack.stack[compile_stack.avail]).laststart_offset = b - bufp->buffer;
(compile_stack.stack[compile_stack.avail]).regnum = regnum;
if (regnum <= 255){
(compile_stack.stack[compile_stack.avail]).inner_group_offset = b - bufp->buffer + 2;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (start_memory); 
 *b++ = (unsigned char) (regnum); 
 *b++ = (unsigned char) (0); 
 } while (0);




}
compile_stack.avail++;
fixup_alt_jump = 0;
laststart = 0;
begalt = b;
pending_exact = 0;
break;
case ')':
if (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_backslash;
}
if ((compile_stack.avail == 0)){
if (syntax & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_backslash;
}

else 
 {
return (free (compile_stack.stack), REG_ERPAREN);
}
}
handle_close:
if (fixup_alt_jump){

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (push_dummy_failure); 
 } while (0);





 store_op1 (jump_past_alt, fixup_alt_jump, (int) ((b - 1) - (fixup_alt_jump) - 3));
}
if ((compile_stack.avail == 0)){
if (syntax & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

else 
 {
return (free (compile_stack.stack), REG_ERPAREN);
}
}
;
{
regnum_t this_group_regnum;
compile_stack.avail--;
begalt = bufp->buffer + (compile_stack.stack[compile_stack.avail]).begalt_offset;
fixup_alt_jump = (compile_stack.stack[compile_stack.avail]).fixup_alt_jump ? bufp->buffer + (compile_stack.stack[compile_stack.avail]).fixup_alt_jump - 1 : 0;
laststart = bufp->buffer + (compile_stack.stack[compile_stack.avail]).laststart_offset;
this_group_regnum = (compile_stack.stack[compile_stack.avail]).regnum;
pending_exact = 0;
if (this_group_regnum <= 255){
unsigned char *inner_group_loc = bufp->buffer + (compile_stack.stack[compile_stack.avail]).inner_group_offset;
*inner_group_loc = regnum - this_group_regnum;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (stop_memory); 
 *b++ = (unsigned char) (this_group_regnum); 
 *b++ = (unsigned char) (regnum - this_group_regnum); 
 } while (0) ;





}
}
break;
case '|':
if (syntax & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_backslash;
}

handle_alt:
if (syntax & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);





 insert_op1 (on_failure_jump, begalt, (int) ((b + 6) - (begalt) - 3), b);
pending_exact = 0;
b += 3;

if (fixup_alt_jump) {

store_op1 (jump_past_alt, fixup_alt_jump, (int) ((b) - (fixup_alt_jump) - 3));
}

fixup_alt_jump = b;

 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);




b += 3;
laststart = 0;
begalt = b;
break;
case '{':
if (!(syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) || ((syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) || (p - 2 == pattern && p == pend)) {
goto normal_backslash;
}



handle_interval:
{
int lower_bound = -1, upper_bound = -1;
beg_interval = p - 1;
if (p == pend){
if (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto unfetch_interval;
}

else 
 {
return (free (compile_stack.stack), REG_EBRACE);
}
}

 { if (p != pend) 
 { 
 
 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0); 
 while ((1 &&   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  )) 
 { 
 if (lower_bound < 0)  {

lower_bound = 0; 
}
 lower_bound = lower_bound * 10 + c - '0'; 
 if (p == pend)  {

break; 
}
 
 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0); 
 } 
 } 
 };








if (c == ','){

 { if (p != pend) 
 { 
 
 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0); 
 while ((1 &&   ((*__ctype_b_loc ())[(int) ((  c  ))] & (unsigned short int) _ISdigit)  )) 
 { 
 if (upper_bound < 0)  {

upper_bound = 0; 
}
 upper_bound = upper_bound * 10 + c - '0'; 
 if (p == pend)  {

break; 
}
 
 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0); 
 } 
 } 
 };








if (upper_bound < 0) {
upper_bound = (0x7fff);
}
}
else {
upper_bound = lower_bound;
}
if (lower_bound < 0 || upper_bound > (0x7fff) || lower_bound > upper_bound) {


if (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto unfetch_interval;
}

else 
 {
return (free (compile_stack.stack), REG_BADBR);
}
}
if (!(syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))){
if (c != '\\')  {

return (free (compile_stack.stack), REG_EBRACE);
}

 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
}
if (c != '}'){
if (syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto unfetch_interval;
}

else 
 {
return (free (compile_stack.stack), REG_BADBR);
}
}
if (!laststart){
if (syntax & (((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1))  {

return (free (compile_stack.stack), REG_BADRPT);
}

else{
if (syntax & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) {
laststart = b;
}

else {
goto unfetch_interval;
}

}
}
if (upper_bound == 0){

 while ((unsigned long) (b - bufp->buffer + (3)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);





 insert_op1 (jump, laststart, (int) ((b + 3) - (laststart) - 3), b);
b += 3;
}

else {

unsigned nbytes = 10 + (upper_bound > 1) * 10;

 while ((unsigned long) (b - bufp->buffer + (nbytes)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0);





 insert_op2 (succeed_n, laststart, (int) ((b + 5 + (upper_bound > 1) * 5) - (laststart) - 3), lower_bound, b) ;

b += 5;
insert_op2 (set_number_at, laststart, 5, lower_bound, b);
b += 5;
if (upper_bound > 1){

 store_op2 (jump_n, b, (int) ((laststart + 5) - (b) - 3), upper_bound - 1) ;

b += 5;

insert_op2 (set_number_at, laststart, b - laststart, upper_bound - 1, b);
b += 5;
}
}
pending_exact = 0;
beg_interval =   ((void *)0)  ;




}
break;
unfetch_interval:
;
p = beg_interval;
beg_interval =   ((void *)0)  ;





 do {if (p == pend) {
return REG_EEND; 
}
 c = (unsigned char) *p++; 
 if (translate) {
c = (unsigned char) translate[c]; 
}
 } while (0);
if (!(syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))){
if (p > pattern && p[-1] == '\\') {
goto normal_backslash;
}

}
goto normal_char;

case 'w':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

laststart = b;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (wordchar); 
 } while (0);




break;
case 'W':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

laststart = b;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (notwordchar); 
 } while (0);




break;
case '<':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (wordbeg); 
 } while (0);




break;
case '>':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (wordend); 
 } while (0);




break;
case 'b':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (wordbound); 
 } while (0);




break;
case 'B':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (notwordbound); 
 } while (0);




break;
case '`':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (begbuf); 
 } while (0);




break;
case '\'':
if (syntax & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}


 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (endbuf); 
 } while (0);




break;
case '1': case '2': case '3': case '4': case '5':
case '6': case '7': case '8': case '9':
if (syntax & ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
goto normal_char;
}

c1 = c - '0';
if (c1 > regnum)  {

return (free (compile_stack.stack), REG_ESUBREG);
}

if (group_in_compile_stack (compile_stack, (regnum_t) c1)) {
goto normal_char;
}

laststart = b;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (2)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (duplicate); 
 *b++ = (unsigned char) (c1); 
 } while (0);




break;
case '+':
case '?':
if (syntax & (((unsigned long int) 1) << 1)) {
goto handle_plus;
}

else {
goto normal_backslash;
}
default:
normal_backslash:
c = 
 (translate ? (char) translate[(unsigned char) (c)] : (c));
goto normal_char;
}
break;
default:
normal_char:
if (!pending_exact || pending_exact + *pending_exact + 1 != b || *pending_exact == (1 << 8) - 1 || *p == '*' || *p == '^' || ((syntax & (((unsigned long int) 1) << 1)) ? *p == '\\' && (p[1] == '+' || p[1] == '?') : (*p == '+' || *p == '?')) || ((syntax & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && ((syntax & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) ? *p == '{' : (p[0] == '\\' && p[1] == '{')))) {











laststart = b;

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (2)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (exactn); 
 *b++ = (unsigned char) (0); 
 } while (0);




pending_exact = b - 1;
}

 do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (c); 
 } while (0);




(*pending_exact)++;
break;
}
}
if (fixup_alt_jump) {

store_op1 (jump_past_alt, fixup_alt_jump, (int) ((b) - (fixup_alt_jump) - 3));
}

if (!(compile_stack.avail == 0))  {

return (free (compile_stack.stack), REG_EPAREN);
}

if (syntax & ((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))  {

do { 
 
 while ((unsigned long) (b - bufp->buffer + (1)) > bufp->allocated) 
 
 do { 
 unsigned char *old_buffer = bufp->buffer; 
 if (bufp->allocated == (1L << 16))  {

return REG_ESIZE; 
}
 bufp->allocated <<= 1; 
 if (bufp->allocated > (1L << 16)){

bufp->allocated = (1L << 16); 
}
 bufp->buffer = (unsigned char *) realloc ((bufp->buffer), (bufp->allocated));
 if (bufp->buffer ==   ((void *)0)  ){

return REG_ESPACE; 
}
 
 if (old_buffer != bufp->buffer){
 
 b = (b - old_buffer) + bufp->buffer; 
 begalt = (begalt - old_buffer) + bufp->buffer; 
 if (fixup_alt_jump) {

fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
}
 if (laststart){

laststart = (laststart - old_buffer) + bufp->buffer; 
}
 if (pending_exact){

pending_exact = (pending_exact - old_buffer) + bufp->buffer; 
}
 } 
 } while (0); 
 *b++ = (unsigned char) (succeed); 
 } while (0);
}






free (compile_stack.stack);
bufp->used = b - bufp->buffer;

return REG_NOERROR;
}
static void store_op1 (op, loc, arg) re_opcode_t op;


unsigned char *loc;
int arg;
{
*loc = (unsigned char) op;

 do { 
 (loc + 1)[0] = (arg) & 0377; 
 (loc + 1)[1] = (arg) >> 8; 
 } while (0);
}
static void store_op2 (op, loc, arg1, arg2) re_opcode_t op;


unsigned char *loc;
int arg1, arg2;
{
*loc = (unsigned char) op;

 do { 
 (loc + 1)[0] = (arg1) & 0377; 
 (loc + 1)[1] = (arg1) >> 8; 
 } while (0);

 do { 
 (loc + 3)[0] = (arg2) & 0377; 
 (loc + 3)[1] = (arg2) >> 8; 
 } while (0);
}
static void insert_op1 (op, loc, arg, end) re_opcode_t op;


unsigned char *loc;
int arg;
unsigned char *end;
{
register unsigned char *pfrom = end;
register unsigned char *pto = end + 3;
while (pfrom != loc) *--pto = *--pfrom;

store_op1 (op, loc, arg);
}
static void insert_op2 (op, loc, arg1, arg2, end) re_opcode_t op;


unsigned char *loc;
int arg1, arg2;
unsigned char *end;
{
register unsigned char *pfrom = end;
register unsigned char *pto = end + 5;
while (pfrom != loc) *--pto = *--pfrom;

store_op2 (op, loc, arg1, arg2);
}
static boolean at_begline_loc_p (pattern, p, syntax) const char *pattern, *p;


reg_syntax_t syntax;
{
const char *prev = p - 2;
boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
return (*prev == '(' && (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || prev_prev_backslash)) || (*prev == '|' && (syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || prev_prev_backslash));


}
static boolean at_endline_loc_p (p, pend, syntax) const char *p, *pend;


reg_syntax_t syntax;
{
const char *next = p;
boolean next_backslash = *next == '\\';
const char *next_next = p + 1 < pend ? p + 1 : 0;
return (syntax & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? *next == ')' : next_backslash && next_next && *next_next == ')') || (syntax & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? *next == '|' : next_backslash && next_next && *next_next == '|');



}
static boolean group_in_compile_stack (compile_stack, regnum) compile_stack_type compile_stack;


regnum_t regnum;
{
int this_element;
for (this_element = compile_stack.avail - 1;
this_element >= 0;
this_element--) if (compile_stack.stack[this_element].regnum == regnum) {
return 1;
}


return 0;
}

static reg_errcode_t compile_range (p_ptr, pend, translate, syntax, b) const char **p_ptr, *pend;


char * translate;
reg_syntax_t syntax;
unsigned char *b;
{
unsigned this_char;
const char *p = *p_ptr;
unsigned int range_start, range_end;
if (p == pend) {
return REG_ERANGE;
}


range_start = ((const unsigned char *) p)[-2];
range_end = ((const unsigned char *) p)[0];
(*p_ptr)++;
if (range_start > range_end) {
return syntax & ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? REG_ERANGE : REG_NOERROR;
}

for (this_char = range_start; this_char <= range_end; this_char++){

 (b[((unsigned char) (
 (translate ? (char) translate[(unsigned char) (this_char)] : (this_char)))) / 8] 
 |= 1 << (((unsigned char) 
 (translate ? (char) translate[(unsigned char) (this_char)] : (this_char))) % 8));
}
return REG_NOERROR;
}

int re_compile_fastmap (bufp) struct re_pattern_buffer *bufp;


{
int j, k;
fail_stack_type fail_stack;
char *destination;
register char *fastmap = bufp->fastmap;
unsigned char *pattern = bufp->buffer;
unsigned char *p = pattern;
register unsigned char *pend = pattern + bufp->used;

boolean path_can_be_null = 1;
boolean succeed_n_p = 0;
;

 do { 
 fail_stack.stack = (fail_stack_elt_t *) 
   __builtin_alloca (  5 * sizeof (fail_stack_elt_t)  )  ; 
 
 if (fail_stack.stack ==   ((void *)0)  )  {

return -2; 
}
 
 fail_stack.size = 5; 
 fail_stack.avail = 0; 
 } while (0);












(memset (fastmap, '\0', 1 << 8), (fastmap));
bufp->fastmap_accurate = 1;
bufp->can_be_null = 0;
while (1) {

if (p == pend || *p == succeed){
if (!(fail_stack.avail == 0)){
bufp->can_be_null |= path_can_be_null;
path_can_be_null = 1;
p = fail_stack.stack[--fail_stack.avail].pointer;
continue;
}
else {
break;
}
}
;
switch (((re_opcode_t) *p++)) {

case duplicate:
bufp->can_be_null = 1;
goto done;
case exactn:
fastmap[p[1]] = 1;
break;
case charset:
for (j = *p++ * 8 - 1; j >= 0; j--){
if (p[j / 8] & (1 << (j % 8))) {
fastmap[j] = 1;
}}


break;
case charset_not:
for (j = *p * 8; j < (1 << 8); j++) fastmap[j] = 1;

for (j = *p++ * 8 - 1; j >= 0; j--){
if (!(p[j / 8] & (1 << (j % 8)))) {
fastmap[j] = 1;
}}


break;
case wordchar:
for (j = 0; j < (1 << 8); j++){
if (re_syntax_table[((j) & 0xFF)] == 1) {
fastmap[j] = 1;
}}


break;
case notwordchar:
for (j = 0; j < (1 << 8); j++){
if (re_syntax_table[((j) & 0xFF)] != 1) {
fastmap[j] = 1;
}}


break;
case anychar:
{
int fastmap_newline = fastmap['\n'];
for (j = 0; j < (1 << 8); j++) fastmap[j] = 1;

if (!(bufp->syntax & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
fastmap['\n'] = fastmap_newline;
}

else{
if (bufp->can_be_null) {
goto done;
}

}

break;
}

case no_op:
case begline:
case endline:
case begbuf:
case endbuf:
case wordbound:
case notwordbound:
case wordbeg:
case wordend:
case push_dummy_failure:
continue;
case jump_n:
case pop_failure_jump:
case maybe_pop_jump:
case jump:
case jump_past_alt:
case dummy_failure_jump:

 do { 
 
 do { 
 (j) = *(p) & 0377; 
 (j) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
p += j;
if (j > 0) {
continue;
}

if ((re_opcode_t) *p != on_failure_jump && (re_opcode_t) *p != succeed_n) {
continue;
}


p++;

 do { 
 
 do { 
 (j) = *(p) & 0377; 
 (j) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
p += j;
if (!(fail_stack.avail == 0) && fail_stack.stack[fail_stack.avail - 1].pointer == p) {
fail_stack.avail--;
}


continue;
case on_failure_jump:
case on_failure_keep_string_jump:
handle_on_failure_jump:

 do { 
 
 do { 
 (j) = *(p) & 0377; 
 (j) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);

if (p + j < pend){
if (!
 (((fail_stack.avail == fail_stack.size) 
 && !
 ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) 
 ? 0 
 : ((fail_stack).stack = (fail_stack_elt_t *) 
 
 
 (destination = (char *)   __builtin_alloca (  
 ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)  )  , 
 memcpy (destination, (fail_stack).stack, 
 (fail_stack).size * sizeof (fail_stack_elt_t))), 
 
 (fail_stack).stack ==   ((void *)0)   
 ? 0 
 : ((fail_stack).size <<= 1, 
 1)))) 
 ? 0 
 : ((fail_stack).stack[(fail_stack).avail++].pointer = p + j, 
 1))) {













;
return -2;
}
}
else {
bufp->can_be_null = 1;
}
if (succeed_n_p){

 do { 
 
 do { 
 (k) = *(p) & 0377; 
 (k) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
succeed_n_p = 0;
}
continue;
case succeed_n:
p += 2;

 do { 
 
 do { 
 (k) = *(p) & 0377; 
 (k) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
if (k == 0){
p -= 4;
succeed_n_p = 1;
goto handle_on_failure_jump;
}
continue;
case set_number_at:
p += 4;
continue;
case start_memory:
case stop_memory:
p += 2;
continue;
default:
abort ();
}
path_can_be_null = 0;
p = pend;
}
bufp->can_be_null |= path_can_be_null;
done:
;
return 0;
}

void re_set_registers (bufp, regs, num_regs, starts, ends) struct re_pattern_buffer *bufp;


struct re_registers *regs;
unsigned num_regs;
regoff_t *starts, *ends;
{
if (num_regs){
bufp->regs_allocated = 1;
regs->num_regs = num_regs;
regs->start = starts;
regs->end = ends;
}
else {

bufp->regs_allocated = 0;
regs->num_regs = 0;
regs->start = regs->end = (regoff_t *) 0;
}
}

int re_search (bufp, string, size, startpos, range, regs) struct re_pattern_buffer *bufp;


const char *string;
int size, startpos, range;
struct re_registers *regs;
{
return re_search_2 (bufp,   ((void *)0)  , 0, string, size, startpos, range, regs, size);




}

int re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop) struct re_pattern_buffer *bufp;


const char *string1, *string2;
int size1, size2;
int startpos;
int range;
struct re_registers *regs;
int stop;
{
int val;
register char *fastmap = bufp->fastmap;
register char * translate = bufp->translate;
int total_size = size1 + size2;
int endpos = startpos + range;
if (startpos < 0 || startpos > total_size) {
return -1;
}

if (endpos < 0) {
range = 0 - startpos;
}

else{
if (endpos > total_size) {
range = total_size - startpos;
}

}

if (bufp->used > 0 && range > 0 && ((re_opcode_t) bufp->buffer[0] == begbuf || ((re_opcode_t) bufp->buffer[0] == begline && !bufp->newline_anchor))) {




if (startpos > 0) {
return -1;
}

else {
range = 1;
}
}

if (fastmap && !bufp->fastmap_accurate){
if (re_compile_fastmap (bufp) == -2) {
return -2;
}

}


for (;;){
if (fastmap && startpos < total_size && !bufp->can_be_null){
if (range > 0){
register const char *d;
register int lim = 0;
int irange = range;
if (startpos < size1 && startpos + range >= size1) {
lim = range - (size1 - startpos);
}

d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
if (translate) {
while (range > lim && !fastmap[(unsigned char) translate[(unsigned char) *d++]]) range--;
}




else {
while (range > lim && !fastmap[(unsigned char) *d++]) range--;
}


startpos += irange - range;
}
else {

register char c = (size1 == 0 || startpos >= size1 ? string2[startpos - size1] : string1[startpos]);
if (!fastmap[(unsigned char) 
 (translate ? (char) translate[(unsigned char) (c)] : (c))]) {
goto advance;
}

}
}
if (range >= 0 && startpos == total_size && fastmap && !bufp->can_be_null) {
return -1;
}


val = re_match_2_internal (bufp, string1, size1, string2, size2, startpos, regs, stop);
if (val >= 0) {
return startpos;
}

if (val == -2) {
return -2;
}

advance:
if (!range) {
break;
}

else{
if (range > 0){
range--;
startpos++;
}
else {

range++;
startpos--;
}
}

}
return -1;
}

int re_match (bufp, string, size, pos, regs) struct re_pattern_buffer *bufp;


const char *string;
int size, pos;
struct re_registers *regs;
{
int result = re_match_2_internal (bufp,   ((void *)0)  , 0, string, size, pos, regs, size);




return result;
}
static boolean group_match_null_string_p (unsigned char **p, unsigned char *end, register_info_type *reg_info) ;

static boolean alt_match_null_string_p (unsigned char *p, unsigned char *end, register_info_type *reg_info) ;

static boolean common_op_match_null_string_p (unsigned char **p, unsigned char *end, register_info_type *reg_info) ;

static int bcmp_translate (const char *s1, const char *s2, int len, char *translate) ;


int re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop) struct re_pattern_buffer *bufp;


const char *string1, *string2;
int size1, size2;
int pos;
struct re_registers *regs;
int stop;
{
int result = re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop);
return result;
}
static int re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop) struct re_pattern_buffer *bufp;


const char *string1, *string2;
int size1, size2;
int pos;
struct re_registers *regs;
int stop;
{
int mcnt;
unsigned char *p1;
const char *end1, *end2;
const char *end_match_1, *end_match_2;
const char *d, *dend;
unsigned char *p = bufp->buffer;
register unsigned char *pend = p + bufp->used;
unsigned char *just_past_start_mem = 0;
char * translate = bufp->translate;

fail_stack_type fail_stack;

size_t num_regs = bufp->re_nsub + 1;
active_reg_t lowest_active_reg = ((1 << 8) + 1);
active_reg_t highest_active_reg = (1 << 8);

const char **regstart, **regend;

const char **old_regstart, **old_regend;

register_info_type *reg_info;
unsigned best_regs_set = 0;
const char **best_regstart, **best_regend;

const char *match_end =   ((void *)0)  ;




int set_regs_matched_done = 0;
const char **reg_dummy;
register_info_type *reg_info_dummy;
;

 do { 
 fail_stack.stack = (fail_stack_elt_t *) 
   __builtin_alloca (  5 * sizeof (fail_stack_elt_t)  )  ; 
 
 if (fail_stack.stack ==   ((void *)0)  )  {

return -2; 
}
 
 fail_stack.size = 5; 
 fail_stack.avail = 0; 
 } while (0);












if (bufp->re_nsub){
regstart = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








regend = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








old_regstart = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








old_regend = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








best_regstart = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








best_regend = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








reg_info = ((register_info_type *)   __builtin_alloca (  (num_regs) * sizeof (register_info_type)  )  );








reg_dummy = ((const char * *)   __builtin_alloca (  (num_regs) * sizeof (const char *)  )  );








reg_info_dummy = ((register_info_type *)   __builtin_alloca (  (num_regs) * sizeof (register_info_type)  )  );








if (!(regstart && regend && old_regstart && old_regend && reg_info && best_regstart && best_regend && reg_dummy && reg_info_dummy)) {



 do { 
 ; 
 if (regstart) {
((void)0); regstart =   ((void *)0)  ; 
}
 if (regend) {
((void)0); regend =   ((void *)0)  ; 
}
 if (old_regstart) {
((void)0); old_regstart =   ((void *)0)  ; 
}
 if (old_regend) {
((void)0); old_regend =   ((void *)0)  ; 
}
 if (best_regstart) {
((void)0); best_regstart =   ((void *)0)  ; 
}
 if (best_regend) {
((void)0); best_regend =   ((void *)0)  ; 
}
 if (reg_info) {
((void)0); reg_info =   ((void *)0)  ; 
}
 if (reg_dummy) {
((void)0); reg_dummy =   ((void *)0)  ; 
}
 if (reg_info_dummy) {
((void)0); reg_info_dummy =   ((void *)0)  ; 
}
 } while (0);




































return -2;
}
}
else {

regstart = regend = old_regstart = old_regend = best_regstart = best_regend = reg_dummy =   ((void *)0)  ;





reg_info = reg_info_dummy = (register_info_type *)   ((void *)0)  ;




}
if (pos < 0 || pos > size1 + size2){

 do { 
 ; 
 if (regstart) {
((void)0); regstart =   ((void *)0)  ; 
}
 if (regend) {
((void)0); regend =   ((void *)0)  ; 
}
 if (old_regstart) {
((void)0); old_regstart =   ((void *)0)  ; 
}
 if (old_regend) {
((void)0); old_regend =   ((void *)0)  ; 
}
 if (best_regstart) {
((void)0); best_regstart =   ((void *)0)  ; 
}
 if (best_regend) {
((void)0); best_regend =   ((void *)0)  ; 
}
 if (reg_info) {
((void)0); reg_info =   ((void *)0)  ; 
}
 if (reg_dummy) {
((void)0); reg_dummy =   ((void *)0)  ; 
}
 if (reg_info_dummy) {
((void)0); reg_info_dummy =   ((void *)0)  ; 
}
 } while (0);




































return -1;
}
for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++){
regstart[mcnt] = regend[mcnt] = old_regstart[mcnt] = old_regend[mcnt] = (&reg_unset_dummy);
((reg_info[mcnt]).bits.match_null_string_p) = 3;
((reg_info[mcnt]).bits.is_active) = 0;
((reg_info[mcnt]).bits.matched_something) = 0;
((reg_info[mcnt]).bits.ever_matched_something) = 0;
}
if (size2 == 0 && string1 !=   ((void *)0)  ) {





string2 = string1;
size2 = size1;
string1 = 0;
size1 = 0;
}
end1 = string1 + size1;
end2 = string2 + size2;
if (stop <= size1){
end_match_1 = string1 + stop;
end_match_2 = string2;
}
else {

end_match_1 = end1;
end_match_2 = string2 + stop - size1;
}
if (size1 > 0 && pos <= size1){
d = string1 + pos;
dend = end_match_1;
}
else {

d = string2 + pos - size1;
dend = end_match_2;
}
;
;
;
;
;
for (;;){
;
if (p == pend){
;
if (d != end_match_2){
boolean same_str_p = (
 (size1 && string1 <= (match_end) && (match_end) <= string1 + size1) == (dend == end_match_1));

boolean best_match_p;
if (same_str_p) {
best_match_p = d > match_end;
}

else {
best_match_p = !(dend == end_match_1);
}
;
if (!(fail_stack.avail == 0)){
if (!best_regs_set || best_match_p){
best_regs_set = 1;
match_end = d;
;
for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++){
best_regstart[mcnt] = regstart[mcnt];
best_regend[mcnt] = regend[mcnt];
}
}
goto fail;
}
else{
if (best_regs_set && !best_match_p){
restore_best_regs:
;
d = match_end;
dend = ((d >= string1 && d <= end1) ? end_match_1 : end_match_2);

for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++){
regstart[mcnt] = best_regstart[mcnt];
regend[mcnt] = best_regend[mcnt];
}
}
}

}
succeed_label:
;
if (regs && !bufp->no_sub){
if (bufp->regs_allocated == 0){
regs->num_regs = ((30) > (num_regs + 1) ? (30) : (num_regs + 1));
regs->start = ((regoff_t *) xmalloc ((regs->num_regs) * sizeof (regoff_t)));
regs->end = ((regoff_t *) xmalloc ((regs->num_regs) * sizeof (regoff_t)));
if (regs->start ==   ((void *)0)   || regs->end ==   ((void *)0)  ) {










 do { 
 ; 
 if (regstart) {
((void)0); regstart =   ((void *)0)  ; 
}
 if (regend) {
((void)0); regend =   ((void *)0)  ; 
}
 if (old_regstart) {
((void)0); old_regstart =   ((void *)0)  ; 
}
 if (old_regend) {
((void)0); old_regend =   ((void *)0)  ; 
}
 if (best_regstart) {
((void)0); best_regstart =   ((void *)0)  ; 
}
 if (best_regend) {
((void)0); best_regend =   ((void *)0)  ; 
}
 if (reg_info) {
((void)0); reg_info =   ((void *)0)  ; 
}
 if (reg_dummy) {
((void)0); reg_dummy =   ((void *)0)  ; 
}
 if (reg_info_dummy) {
((void)0); reg_info_dummy =   ((void *)0)  ; 
}
 } while (0);




































return -2;
}
bufp->regs_allocated = 1;
}
else{
if (bufp->regs_allocated == 1){
if (regs->num_regs < num_regs + 1){
regs->num_regs = num_regs + 1;
((regs->start) = (regoff_t *) realloc (regs->start, (regs->num_regs) * sizeof (regoff_t)));
((regs->end) = (regoff_t *) realloc (regs->end, (regs->num_regs) * sizeof (regoff_t)));
if (regs->start ==   ((void *)0)   || regs->end ==   ((void *)0)  ) {










 do { 
 ; 
 if (regstart) {
((void)0); regstart =   ((void *)0)  ; 
}
 if (regend) {
((void)0); regend =   ((void *)0)  ; 
}
 if (old_regstart) {
((void)0); old_regstart =   ((void *)0)  ; 
}
 if (old_regend) {
((void)0); old_regend =   ((void *)0)  ; 
}
 if (best_regstart) {
((void)0); best_regstart =   ((void *)0)  ; 
}
 if (best_regend) {
((void)0); best_regend =   ((void *)0)  ; 
}
 if (reg_info) {
((void)0); reg_info =   ((void *)0)  ; 
}
 if (reg_dummy) {
((void)0); reg_dummy =   ((void *)0)  ; 
}
 if (reg_info_dummy) {
((void)0); reg_info_dummy =   ((void *)0)  ; 
}
 } while (0);




































return -2;
}
}
}
else {

;
}
}

if (regs->num_regs > 0){
regs->start[0] = pos;
regs->end[0] = ((dend == end_match_1) ? ((regoff_t) (d - string1)) : ((regoff_t) (d - string2 + size1)));


}
for (mcnt = 1; (unsigned) mcnt < ((num_regs) < (regs->num_regs) ? (num_regs) : (regs->num_regs));
mcnt++) {

if (((regstart[mcnt]) == (&reg_unset_dummy)) || ((regend[mcnt]) == (&reg_unset_dummy))) {
regs->start[mcnt] = regs->end[mcnt] = -1;
}

else {

regs->start[mcnt] = (regoff_t) 
 (
 (size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1) 
 ? ((regoff_t) ((regstart[mcnt]) - string1)) 
 : ((regoff_t) ((regstart[mcnt]) - string2 + size1)));
regs->end[mcnt] = (regoff_t) 
 (
 (size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1) 
 ? ((regoff_t) ((regend[mcnt]) - string1)) 
 : ((regoff_t) ((regend[mcnt]) - string2 + size1)));
}
}
for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++) regs->start[mcnt] = regs->end[mcnt] = -1;

}
;
;
mcnt = d - pos - ((dend == end_match_1) ? string1 : string2 - size1);

;

 do { 
 ; 
 if (regstart) {
((void)0); regstart =   ((void *)0)  ; 
}
 if (regend) {
((void)0); regend =   ((void *)0)  ; 
}
 if (old_regstart) {
((void)0); old_regstart =   ((void *)0)  ; 
}
 if (old_regend) {
((void)0); old_regend =   ((void *)0)  ; 
}
 if (best_regstart) {
((void)0); best_regstart =   ((void *)0)  ; 
}
 if (best_regend) {
((void)0); best_regend =   ((void *)0)  ; 
}
 if (reg_info) {
((void)0); reg_info =   ((void *)0)  ; 
}
 if (reg_dummy) {
((void)0); reg_dummy =   ((void *)0)  ; 
}
 if (reg_info_dummy) {
((void)0); reg_info_dummy =   ((void *)0)  ; 
}
 } while (0);




































return mcnt;
}
switch (((re_opcode_t) *p++)) {

case no_op:
;
break;
case succeed:
;
goto succeed_label;
case exactn:
mcnt = *p++;
;
if (translate){
do {


 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
if ((unsigned char) translate[(unsigned char) *d++] != (unsigned char) *p++) {
goto fail;
}


}
while (--mcnt);
}
else {

do {


 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
if (*d++ != (char) *p++) {
goto fail;
}
}
while (--mcnt);
}

 do 
 { 
 if (!set_regs_matched_done){
 
 active_reg_t r; 
 set_regs_matched_done = 1; 
 for (r = lowest_active_reg; r <= highest_active_reg; r++) 
 { 
 ((reg_info[r]).bits.matched_something) 
 = ((reg_info[r]).bits.ever_matched_something) 
 = 1; 
 } 
 } 
 } 
 while (0);
break;
case anychar:
;

 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
if ((!(bufp->syntax & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)) && 
 (translate ? (char) translate[(unsigned char) (*d)] : (*d)) == '\n') || (bufp->syntax & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && 
 (translate ? (char) translate[(unsigned char) (*d)] : (*d)) == '\000')) {
goto fail;
}



 do 
 { 
 if (!set_regs_matched_done){
 
 active_reg_t r; 
 set_regs_matched_done = 1; 
 for (r = lowest_active_reg; r <= highest_active_reg; r++) 
 { 
 ((reg_info[r]).bits.matched_something) 
 = ((reg_info[r]).bits.ever_matched_something) 
 = 1; 
 } 
 } 
 } 
 while (0);
;
d++;
break;
case charset:
case charset_not:
{
register unsigned char c;
boolean not = (re_opcode_t) *(p - 1) == charset_not;
;

 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
c = 
 (translate ? (char) translate[(unsigned char) (*d)] : (*d));
if (c < (unsigned) (*p * 8) && p[1 + c / 8] & (1 << (c % 8))) {
not = !not;
}


p += 1 + *p;
if (!not) {
goto fail;
}

 do 
 { 
 if (!set_regs_matched_done){
 
 active_reg_t r; 
 set_regs_matched_done = 1; 
 for (r = lowest_active_reg; r <= highest_active_reg; r++) 
 { 
 ((reg_info[r]).bits.matched_something) 
 = ((reg_info[r]).bits.ever_matched_something) 
 = 1; 
 } 
 } 
 } 
 while (0);
d++;
break;
}
case start_memory:
;
p1 = p;
if (((reg_info[*p]).bits.match_null_string_p) == 3) {
((reg_info[*p]).bits.match_null_string_p) = group_match_null_string_p (&p1, pend, reg_info);
}


old_regstart[*p] = ((reg_info[*p]).bits.match_null_string_p) ? ((regstart[*p]) == (&reg_unset_dummy)) ? d : regstart[*p] : regstart[*p];

;
regstart[*p] = d;
;
((reg_info[*p]).bits.is_active) = 1;
((reg_info[*p]).bits.matched_something) = 0;
set_regs_matched_done = 0;
highest_active_reg = *p;
if (lowest_active_reg == ((1 << 8) + 1)) {
lowest_active_reg = *p;
}

p += 2;
just_past_start_mem = p;
break;
case stop_memory:
;
old_regend[*p] = ((reg_info[*p]).bits.match_null_string_p) ? ((regend[*p]) == (&reg_unset_dummy)) ? d : regend[*p] : regend[*p];

;
regend[*p] = d;
;
((reg_info[*p]).bits.is_active) = 0;
set_regs_matched_done = 0;
if (lowest_active_reg == highest_active_reg){
lowest_active_reg = ((1 << 8) + 1);
highest_active_reg = (1 << 8);
}
else {

unsigned char r = *p - 1;
while (r > 0 && !((reg_info[r]).bits.is_active)) r--;


if (r == 0){
lowest_active_reg = ((1 << 8) + 1);
highest_active_reg = (1 << 8);
}
else {
highest_active_reg = r;
}
}
if ((!((reg_info[*p]).bits.matched_something) || just_past_start_mem == p - 1) && (p + 2) < pend) {



boolean is_a_jump_n = 0;
p1 = p + 2;
mcnt = 0;
switch ((re_opcode_t) *p1++) {

case jump_n:
is_a_jump_n = 1;
case pop_failure_jump:
case maybe_pop_jump:
case jump:
case dummy_failure_jump:

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
if (is_a_jump_n) {
p1 += 2;
}

break;
default:
;
}
p1 += mcnt;
if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump && (re_opcode_t) p1[3] == start_memory && p1[4] == *p) {



if (((reg_info[*p]).bits.ever_matched_something)){
unsigned r;
((reg_info[*p]).bits.ever_matched_something) = 0;
for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
r++) {

regstart[r] = old_regstart[r];
if (old_regend[r] >= regstart[r]) {
regend[r] = old_regend[r];
}

}
}
p1++;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);

 do { 
 char *destination; 
 
 
 active_reg_t this_reg; 
 
 ; 
 ; 
 ; 
 ;
 ;
 
 ; 
 ; 
 
 
 while (((fail_stack).size - (fail_stack).avail) < 
 (((0 
 ? 0 : highest_active_reg - lowest_active_reg + 1) 
 * 3) 
 + 4)) 
 { 
 if (!
 ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) 
 ? 0 
 : ((fail_stack).stack = (fail_stack_elt_t *) 
 
 
 (destination = (char *)   __builtin_alloca (  
 ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)  )  , 
 memcpy (destination, (fail_stack).stack, 
 (fail_stack).size * sizeof (fail_stack_elt_t))), 
 
 (fail_stack).stack ==   ((void *)0)   
 ? 0 
 : ((fail_stack).size <<= 1, 
 1))))  {

return -2; 
}
 
 ; 
 ;
 } 
 
 
 ; 
 
 if (1){

for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; 
 this_reg++) 
 { 
 ; 
 ; 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); 
 
 ; 
 ; 
 ; 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); 
 }
}

 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); 
 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); 
 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (p1 + mcnt); 
 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (d); 
 
 ; 
 ; 
 } while (0);












goto fail;
}
}
p += 2;
break;
case duplicate:
{
register const char *d2, *dend2;
int regno = *p++;
;
if (((regstart[regno]) == (&reg_unset_dummy)) || ((regend[regno]) == (&reg_unset_dummy))) {
goto fail;
}

d2 = regstart[regno];
dend2 = ((
 (size1 && string1 <= (regstart[regno]) && (regstart[regno]) <= string1 + size1) == 
 (size1 && string1 <= (regend[regno]) && (regend[regno]) <= string1 + size1)) ? regend[regno] : end_match_1);


for (;;){
while (d2 == dend2) {

if (dend2 == end_match_2) {
break;
}
if (dend2 == regend[regno]) {
break;
}
d2 = string2;
dend2 = regend[regno];
}
if (d2 == dend2) {
break;
}

 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
mcnt = dend - d;
if (mcnt > dend2 - d2) {
mcnt = dend2 - d2;
}

if (translate ? bcmp_translate (d, d2, mcnt, translate) : memcmp (d, d2, mcnt)) {
goto fail;
}



d += mcnt, d2 += mcnt;

 do 
 { 
 if (!set_regs_matched_done){
 
 active_reg_t r; 
 set_regs_matched_done = 1; 
 for (r = lowest_active_reg; r <= highest_active_reg; r++) 
 { 
 ((reg_info[r]).bits.matched_something) 
 = ((reg_info[r]).bits.ever_matched_something) 
 = 1; 
 } 
 } 
 } 
 while (0);
}
}
break;
case begline:
;
if (((d) == (size1 ? string1 : string2) || !size2)){
if (!bufp->not_bol) {
break;
}
}
else{
if (d[-1] == '\n' && bufp->newline_anchor){
break;
}
}

goto fail;
case endline:
;
if (((d) == end2)){
if (!bufp->not_eol) {
break;
}
}
else{
if ((d == end1 ? *string2 : *d) == '\n' && bufp->newline_anchor) {


break;
}
}

goto fail;
case begbuf:
;
if (((d) == (size1 ? string1 : string2) || !size2)) {
break;
}

goto fail;
case endbuf:
;
if (((d) == end2)) {
break;
}

goto fail;

case on_failure_keep_string_jump:
;

 do { 
 
 do { 
 (mcnt) = *(p) & 0377; 
 (mcnt) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
;

 do { 
 char *destination; 
 
 
 active_reg_t this_reg; 
 
 ; 
 ; 
 ; 
 ;
 ;
 
 ; 
 ; 
 
 
 while (((fail_stack).size - (fail_stack).avail) < 
 (((0 
 ? 0 : highest_active_reg - lowest_active_reg + 1) 
 * 3) 
 + 4)) 
 { 
 if (!
 ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) 
 ? 0 
 : ((fail_stack).stack = (fail_stack_elt_t *) 
 
 
 (destination = (char *)   __builtin_alloca (  
 ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)  )  , 
 memcpy (destination, (fail_stack).stack, 
 (fail_stack).size * sizeof (fail_stack_elt_t))), 
 
 (fail_stack).stack ==   ((void *)0)   
 ? 0 
 : ((fail_stack).size <<= 1, 
 1))))  {

return -2; 
}
 
 ; 
 ;
 } 
 
 
 ; 
 
 if (1)  {

for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; 
 this_reg++) 
 { 
 ; 
 ; 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); 
 
 ; 
 ; 
 ; 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); 
 }
}

 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); 
 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); 
 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (p + mcnt); 
 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (  ((void *)0)  ); 
 
 ; 
 ; 
 } while (0);
















break;

case on_failure_jump:
on_failure:
;

 do { 
 
 do { 
 (mcnt) = *(p) & 0377; 
 (mcnt) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
;

p1 = p;
while (p1 < pend && (re_opcode_t) *p1 == no_op) p1++;

if (p1 < pend && (re_opcode_t) *p1 == start_memory){
highest_active_reg = *(p1 + 1) + *(p1 + 2);
if (lowest_active_reg == ((1 << 8) + 1)) {
lowest_active_reg = *(p1 + 1);
}

}
;

 do { 
 char *destination; 
 
 
 active_reg_t this_reg; 
 
 ; 
 ; 
 ; 
 ;
 ;
 
 ; 
 ; 
 
 
 while (((fail_stack).size - (fail_stack).avail) < 
 (((0 
 ? 0 : highest_active_reg - lowest_active_reg + 1) 
 * 3) 
 + 4)) 
 { 
 if (!
 ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) 
 ? 0 
 : ((fail_stack).stack = (fail_stack_elt_t *) 
 
 
 (destination = (char *)   __builtin_alloca (  
 ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)  )  , 
 memcpy (destination, (fail_stack).stack, 
 (fail_stack).size * sizeof (fail_stack_elt_t))), 
 
 (fail_stack).stack ==   ((void *)0)   
 ? 0 
 : ((fail_stack).size <<= 1, 
 1))))  {

return -2; 
}
 
 ; 
 ;
 } 
 
 
 ; 
 
 if (1)  {

for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; 
 this_reg++) 
 { 
 ; 
 ; 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); 
 
 ; 
 ; 
 ; 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); 
 }
}

 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); 
 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); 
 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (p + mcnt); 
 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (d); 
 
 ; 
 ; 
 } while (0);












break;
case maybe_pop_jump:

 do { 
 
 do { 
 (mcnt) = *(p) & 0377; 
 (mcnt) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
;
{
register unsigned char *p2 = p;

while (1) {

if (p2 + 2 < pend && ((re_opcode_t) *p2 == stop_memory || (re_opcode_t) *p2 == start_memory)) {
p2 += 3;
}



else{
if (p2 + 6 < pend && (re_opcode_t) *p2 == dummy_failure_jump) {
p2 += 6;
}


else {
break;
}

}
}
p1 = p + mcnt;
if (p2 == pend){
p[-3] = (unsigned char) pop_failure_jump;
;
}
else{
if ((re_opcode_t) *p2 == exactn || (bufp->newline_anchor && (re_opcode_t) *p2 == endline)) {


register unsigned char c = *p2 == (unsigned char) endline ? '\n' : p2[2];
if ((re_opcode_t) p1[3] == exactn && p1[5] != c){
p[-3] = (unsigned char) pop_failure_jump;
;
}
else{
if ((re_opcode_t) p1[3] == charset || (re_opcode_t) p1[3] == charset_not) {


int not = (re_opcode_t) p1[3] == charset_not;
if (c < (unsigned char) (p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8))) {
not = !not;
}


if (!not){
p[-3] = (unsigned char) pop_failure_jump;
;
}
}
}

}
else{
if ((re_opcode_t) *p2 == charset){
if ((re_opcode_t) p1[3] == exactn && ! ((int) p2[1] * 8 > (int) p1[5] && (p2[2 + p1[5] / 8] & (1 << (p1[5] % 8))))) {




p[-3] = (unsigned char) pop_failure_jump;
;
}
else{
if ((re_opcode_t) p1[3] == charset_not){
int idx;
for (idx = 0; idx < (int) p2[1]; idx++){
if (! (p2[2 + idx] == 0 || (idx < (int) p1[4] && ((p2[2 + idx] & ~ p1[5 + idx]) == 0)))) {
break;
}}




if (idx == p2[1]){
p[-3] = (unsigned char) pop_failure_jump;
;
}
}
else{
if ((re_opcode_t) p1[3] == charset){
int idx;
for (idx = 0;
idx < (int) p2[1] && idx < (int) p1[4];
idx++) if ((p2[2 + idx] & p1[5 + idx]) != 0) {
break;
}


if (idx == p2[1] || idx == p1[4]){
p[-3] = (unsigned char) pop_failure_jump;
;
}
}
}
}
}
}
}
}
p -= 2;
if ((re_opcode_t) p[-1] != pop_failure_jump){
p[-1] = (unsigned char) jump;
;
goto unconditional_jump;
}

case pop_failure_jump:
{
active_reg_t dummy_low_reg, dummy_high_reg;
unsigned char *pdummy;
const char *sdummy;
;

{ 
 
 active_reg_t this_reg; 
 const unsigned char *string_temp; 
 
 ; 
 
 
 ; 
 ; 
 ; 
 
 ; 
 
 ; 
 ; 
 
 
 string_temp = fail_stack.stack[--fail_stack.avail].pointer; 
 if (string_temp !=   ((void *)0)  )  {

sdummy = (const char *) string_temp; 
}
 
 ; 
 ; 
 ; 
 
 pdummy = (unsigned char *) fail_stack.stack[--fail_stack.avail].pointer; 
 ; 
 ; 
 
 
 dummy_high_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; 
 ; 
 
 dummy_low_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; 
 ; 
 
 if (1)  {

for (this_reg = dummy_high_reg; this_reg >= dummy_low_reg; this_reg--) 
 { 
 ; 
 
 reg_info_dummy[this_reg].word = fail_stack.stack[--fail_stack.avail]; 
 ; 
 
 reg_dummy[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; 
 ; 
 
 reg_dummy[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; 
 ; 
 }
}

 else 
 { 
 for (this_reg = highest_active_reg; this_reg > dummy_high_reg; this_reg--) 
 { 
 reg_info_dummy[this_reg].word.integer = 0; 
 reg_dummy[this_reg] = 0; 
 reg_dummy[this_reg] = 0; 
 } 
 highest_active_reg = dummy_high_reg; 
 } 
 
 set_regs_matched_done = 0; 
 ; 
}




;
}
unconditional_jump:
;
case jump:

 do { 
 
 do { 
 (mcnt) = *(p) & 0377; 
 (mcnt) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
;
p += mcnt;
;
break;
case jump_past_alt:
;
goto unconditional_jump;
case dummy_failure_jump:
;

 do { 
 char *destination; 
 
 
 active_reg_t this_reg; 
 
 ; 
 ; 
 ; 
 ;
 ;
 
 ; 
 ; 
 
 
 while (((fail_stack).size - (fail_stack).avail) < 
 (((0 
 ? 0 : highest_active_reg - lowest_active_reg + 1) 
 * 3) 
 + 4)) 
 { 
 if (!
 ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) 
 ? 0 
 : ((fail_stack).stack = (fail_stack_elt_t *) 
 
 
 (destination = (char *)   __builtin_alloca (  
 ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)  )  , 
 memcpy (destination, (fail_stack).stack, 
 (fail_stack).size * sizeof (fail_stack_elt_t))), 
 
 (fail_stack).stack ==   ((void *)0)   
 ? 0 
 : ((fail_stack).size <<= 1, 
 1))))  {

return -2; 
}
 
 ; 
 ;
 } 
 
 
 ; 
 
 if (1) {

for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; 
 this_reg++) 
 { 
 ; 
 ; 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); 
 
 ; 
 ; 
 ; 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); 
 }
}

 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); 
 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); 
 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (  ((void *)0)  ); 
 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (  ((void *)0)  ); 
 
 ; 
 ; 
 } while (0);




















goto unconditional_jump;
case push_dummy_failure:
;

 do { 
 char *destination; 
 
 
 active_reg_t this_reg; 
 
 ; 
 ; 
 ; 
 ;
 ;
 
 ; 
 ; 
 
 
 while (((fail_stack).size - (fail_stack).avail) < 
 (((0 
 ? 0 : highest_active_reg - lowest_active_reg + 1) 
 * 3) 
 + 4)) 
 { 
 if (!
 ((fail_stack).size > (unsigned) (re_max_failures * (5 * 3 + 4)) 
 ? 0 
 : ((fail_stack).stack = (fail_stack_elt_t *) 
 
 
 (destination = (char *)   __builtin_alloca (  
 ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)  )  , 
 memcpy (destination, (fail_stack).stack, 
 (fail_stack).size * sizeof (fail_stack_elt_t))), 
 
 (fail_stack).stack ==   ((void *)0)   
 ? 0 
 : ((fail_stack).size <<= 1, 
 1))))  {

return -2; 
}
 
 ; 
 ;
 } 
 
 
 ; 
 
 if (1){

for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; 
 this_reg++) 
 { 
 ; 
 ; 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regstart[this_reg]); 
 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (regend[this_reg]); 
 
 ; 
 ; 
 ; 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++] = (reg_info[this_reg].word); 
 }
}

 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (lowest_active_reg); 
 
 ;
 
 fail_stack.stack[fail_stack.avail++].integer = (highest_active_reg); 
 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (  ((void *)0)  ); 
 
 ; 
 ; 
 ; 
 
 fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (  ((void *)0)  ); 
 
 ; 
 ; 
 } while (0);




















break;
case succeed_n:

 do { 
 (mcnt) = *(p + 2) & 0377; 
 (mcnt) += ((signed char) (*((p + 2) + 1))) << 8; 
 } while (0);
;
;
if (mcnt > 0){
mcnt--;
p += 2;

 do { 
 
 do { 
 (p)[0] = (mcnt) & 0377; 
 (p)[1] = (mcnt) >> 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
;
}
else{
if (mcnt == 0){
;
p[2] = (unsigned char) no_op;
p[3] = (unsigned char) no_op;
goto on_failure;
}
}

break;
case jump_n:

 do { 
 (mcnt) = *(p + 2) & 0377; 
 (mcnt) += ((signed char) (*((p + 2) + 1))) << 8; 
 } while (0);
;
if (mcnt){
mcnt--;

 do { 
 (p + 2)[0] = (mcnt) & 0377; 
 (p + 2)[1] = (mcnt) >> 8; 
 } while (0);
;
goto unconditional_jump;
}
else {
p += 4;
}
break;
case set_number_at:
{
;

 do { 
 
 do { 
 (mcnt) = *(p) & 0377; 
 (mcnt) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
p1 = p + mcnt;

 do { 
 
 do { 
 (mcnt) = *(p) & 0377; 
 (mcnt) += ((signed char) (*((p) + 1))) << 8; 
 } while (0); 
 (p) += 2; 
 } while (0);
;

 do { 
 (p1)[0] = (mcnt) & 0377; 
 (p1)[1] = (mcnt) >> 8; 
 } while (0);
break;
}

case wordbound:
{
boolean prevchar, thischar;
;
if (((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2)) {
break;
}

prevchar = 
 (re_syntax_table[(((d - 1) == end1 ? *string2 
 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] 
 == 1);
thischar = 
 (re_syntax_table[(((d) == end1 ? *string2 
 : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] 
 == 1);
if (prevchar != thischar) {
break;
}

goto fail;
}
case notwordbound:
{
boolean prevchar, thischar;
;
if (((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2)) {
goto fail;
}

prevchar = 
 (re_syntax_table[(((d - 1) == end1 ? *string2 
 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] 
 == 1);
thischar = 
 (re_syntax_table[(((d) == end1 ? *string2 
 : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] 
 == 1);
if (prevchar != thischar) {
goto fail;
}

break;
}
case wordbeg:
;
if (
 (re_syntax_table[(((d) == end1 ? *string2 
 : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] 
 == 1) && (((d) == (size1 ? string1 : string2) || !size2) || !
 (re_syntax_table[(((d - 1) == end1 ? *string2 
 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] 
 == 1))) {
break;
}

goto fail;
case wordend:
;
if (!((d) == (size1 ? string1 : string2) || !size2) && 
 (re_syntax_table[(((d - 1) == end1 ? *string2 
 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)) & 0xFF)] 
 == 1) && (!
 (re_syntax_table[(((d) == end1 ? *string2 
 : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] 
 == 1) || ((d) == end2))) {
break;
}


goto fail;

case wordchar:
;

 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
if (!
 (re_syntax_table[(((d) == end1 ? *string2 
 : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] 
 == 1)) {
goto fail;
}


 do 
 { 
 if (!set_regs_matched_done){
 
 active_reg_t r; 
 set_regs_matched_done = 1; 
 for (r = lowest_active_reg; r <= highest_active_reg; r++) 
 { 
 ((reg_info[r]).bits.matched_something) 
 = ((reg_info[r]).bits.ever_matched_something) 
 = 1; 
 } 
 } 
 } 
 while (0);
d++;
break;
case notwordchar:
;

 while (d == dend) 
 { 
 
 if (dend == end_match_2){

goto fail; 
}
 
 d = string2; 
 dend = end_match_2; 
 };
if (
 (re_syntax_table[(((d) == end1 ? *string2 
 : (d) == string2 - 1 ? *(end1 - 1) : *(d)) & 0xFF)] 
 == 1)) {
goto fail;
}


 do 
 { 
 if (!set_regs_matched_done){
 
 active_reg_t r; 
 set_regs_matched_done = 1; 
 for (r = lowest_active_reg; r <= highest_active_reg; r++) 
 { 
 ((reg_info[r]).bits.matched_something) 
 = ((reg_info[r]).bits.ever_matched_something) 
 = 1; 
 } 
 } 
 } 
 while (0);
d++;
break;
default:
abort ();
}
continue;
fail:
if (!(fail_stack.avail == 0)){
;

{ 
 
 active_reg_t this_reg; 
 const unsigned char *string_temp; 
 
 ; 
 
 
 ; 
 ; 
 ; 
 
 ; 
 
 ; 
 ; 
 
 
 string_temp = fail_stack.stack[--fail_stack.avail].pointer; 
 if (string_temp !=   ((void *)0)  ){

d = (const char *) string_temp; 
}
 
 ; 
 ; 
 ; 
 
 p = (unsigned char *) fail_stack.stack[--fail_stack.avail].pointer; 
 ; 
 ; 
 
 
 highest_active_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; 
 ; 
 
 lowest_active_reg = (active_reg_t) fail_stack.stack[--fail_stack.avail].integer; 
 ; 
 
 if (1){

for (this_reg = highest_active_reg; this_reg >= lowest_active_reg; this_reg--) 
 { 
 ; 
 
 reg_info[this_reg].word = fail_stack.stack[--fail_stack.avail]; 
 ; 
 
 regend[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; 
 ; 
 
 regstart[this_reg] = (const char *) fail_stack.stack[--fail_stack.avail].pointer; 
 ; 
 }
}

 else 
 { 
 for (this_reg = highest_active_reg; this_reg > highest_active_reg; this_reg--) 
 { 
 reg_info[this_reg].word.integer = 0; 
 regend[this_reg] = 0; 
 regstart[this_reg] = 0; 
 } 
 highest_active_reg = highest_active_reg; 
 } 
 
 set_regs_matched_done = 0; 
 ; 
}




;
if (!p) {
goto fail;
}

;
if (p < pend){
boolean is_a_jump_n = 0;
switch ((re_opcode_t) *p) {

case jump_n:
is_a_jump_n = 1;
case maybe_pop_jump:
case pop_failure_jump:
case jump:
p1 = p + 1;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
p1 += mcnt;
if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n) || (!is_a_jump_n && (re_opcode_t) *p1 == on_failure_jump)) {
goto fail;
}



break;
default:
;
}
}
if (d >= string1 && d <= end1) {
dend = end_match_1;
}

}
else {
break;
}
}
if (best_regs_set) {
goto restore_best_regs;
}


 do { 
 ; 
 if (regstart) {
((void)0); regstart =   ((void *)0)  ; 
}
 if (regend) {
((void)0); regend =   ((void *)0)  ; 
}
 if (old_regstart) {
((void)0); old_regstart =   ((void *)0)  ; 
}
 if (old_regend) {
((void)0); old_regend =   ((void *)0)  ; 
}
 if (best_regstart) {
((void)0); best_regstart =   ((void *)0)  ; 
}
 if (best_regend) {
((void)0); best_regend =   ((void *)0)  ; 
}
 if (reg_info) {
((void)0); reg_info =   ((void *)0)  ; 
}
 if (reg_dummy) {
((void)0); reg_dummy =   ((void *)0)  ; 
}
 if (reg_info_dummy) {
((void)0); reg_info_dummy =   ((void *)0)  ; 
}
 } while (0);




































return -1;
}

static boolean group_match_null_string_p (p, end, reg_info) unsigned char **p, *end;


register_info_type *reg_info;
{
int mcnt;
unsigned char *p1 = *p + 2;
while (p1 < end) {

switch ((re_opcode_t) *p1) {

case on_failure_jump:
p1++;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
if (mcnt >= 0){

while ((re_opcode_t) p1[mcnt-3] == jump_past_alt) {

if (!alt_match_null_string_p (p1, p1 + mcnt - 3, reg_info)) {
return 0;
}


p1 += mcnt;
if ((re_opcode_t) *p1 != on_failure_jump) {
break;
}

p1++;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
if ((re_opcode_t) p1[mcnt-3] != jump_past_alt){
p1 -= 3;
break;
}
}

 do { 
 (mcnt) = *(p1 - 2) & 0377; 
 (mcnt) += ((signed char) (*((p1 - 2) + 1))) << 8; 
 } while (0);
if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info)) {
return 0;
}

p1 += mcnt;
}
break;
case stop_memory:
;
*p = p1 + 2;
return 1;
default:
if (!common_op_match_null_string_p (&p1, end, reg_info)) {
return 0;
}

}
}
return 0;
}
static boolean alt_match_null_string_p (p, end, reg_info) unsigned char *p, *end;


register_info_type *reg_info;
{
int mcnt;
unsigned char *p1 = p;
while (p1 < end) {

switch ((re_opcode_t) *p1) {

case on_failure_jump:
p1++;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
p1 += mcnt;
break;
default:
if (!common_op_match_null_string_p (&p1, end, reg_info)) {
return 0;
}

}
}
return 1;
}
static boolean common_op_match_null_string_p (p, end, reg_info) unsigned char **p, *end;


register_info_type *reg_info;
{
int mcnt;
boolean ret;
int reg_no;
unsigned char *p1 = *p;
switch ((re_opcode_t) *p1++) {

case no_op:
case begline:
case endline:
case begbuf:
case endbuf:
case wordbeg:
case wordend:
case wordbound:
case notwordbound:
break;
case start_memory:
reg_no = *p1;
;
ret = group_match_null_string_p (&p1, end, reg_info);
if (((reg_info[reg_no]).bits.match_null_string_p) == 3) {
((reg_info[reg_no]).bits.match_null_string_p) = ret;
}

if (!ret) {
return 0;
}

break;
case jump:

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
if (mcnt >= 0) {
p1 += mcnt;
}

else {
return 0;
}
break;
case succeed_n:
p1 += 2;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
if (mcnt == 0){
p1 -= 4;

 do { 
 
 do { 
 (mcnt) = *(p1) & 0377; 
 (mcnt) += ((signed char) (*((p1) + 1))) << 8; 
 } while (0); 
 (p1) += 2; 
 } while (0);
p1 += mcnt;
}
else {
return 0;
}
break;
case duplicate:
if (!((reg_info[*p1]).bits.match_null_string_p)) {
return 0;
}

break;
case set_number_at:
p1 += 4;
default:
return 0;
}
*p = p1;
return 1;
}
static int bcmp_translate (s1, s2, len, translate) const char *s1, *s2;


register int len;
char * translate;
{
register const unsigned char *p1 = (const unsigned char *) s1;
register const unsigned char *p2 = (const unsigned char *) s2;
while (len) {

if (translate[*p1++] != translate[*p2++]) {
return 1;
}
len--;
}
return 0;
}

const char * re_compile_pattern (pattern, length, bufp) const char *pattern;


size_t length;
struct re_pattern_buffer *bufp;
{
reg_errcode_t ret;
bufp->regs_allocated = 0;
bufp->no_sub = 0;
bufp->newline_anchor = 1;
ret = regex_compile (pattern, length, re_syntax_options, bufp);
if (!ret) {
return   ((void *)0)  ;
}





return gettext (re_error_msgid[(int) ret]);
}

int regcomp (preg, pattern, cflags) regex_t *preg;


const char *pattern;
int cflags;
{
reg_errcode_t ret;
reg_syntax_t syntax = (cflags & 1) ? ((((((unsigned long int) 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((unsigned long int) 1) << 1) << 1) << 1) | ((((((unsigned long int) 1) << 1) << 1) << 1) << 1) | ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) : ((((((unsigned long int) 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((unsigned long int) 1) << 1));
preg->buffer = 0;
preg->allocated = 0;
preg->used = 0;
preg->fastmap = (char *) xmalloc (1 << 8);
if (cflags & (1 << 1)){
unsigned i;
preg->translate = (char *) xmalloc (256 * sizeof (*(char *)0));
if (preg->translate ==   ((void *)0)  ) {
return (int) REG_ESPACE;
}





for (i = 0; i < 256; i++) preg->translate[i] = (1 &&   ((*__ctype_b_loc ())[(int) ((  i  ))] & (unsigned short int) _ISupper)  ) ? tolower (i) : i;









}
else {
preg->translate =   ((void *)0)  ;
}





if (cflags & ((1 << 1) << 1)){
syntax &= ~((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1);
syntax |= ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
preg->newline_anchor = 1;
}
else {
preg->newline_anchor = 0;
}
preg->no_sub = !!(cflags & (((1 << 1) << 1) << 1));
ret = regex_compile (pattern, strlen (pattern), syntax, preg);
if (ret == REG_ERPAREN) {
ret = REG_EPAREN;
}
if (ret == REG_NOERROR && preg->fastmap){
if (re_compile_fastmap (preg) == -2){
free (preg->fastmap);
preg->fastmap =   ((void *)0)  ;




}
}
return (int) ret;
}

int regexec (preg, string, nmatch, pmatch, eflags) const regex_t *preg;


const char *string;
size_t nmatch;
regmatch_t pmatch[];
int eflags;
{
int ret;
struct re_registers regs;
regex_t private_preg;
int len = strlen (string);
boolean want_reg_info = !preg->no_sub && nmatch > 0;
private_preg = *preg;
private_preg.not_bol = !!(eflags & 1);
private_preg.not_eol = !!(eflags & (1 << 1));
private_preg.regs_allocated = 2;
if (want_reg_info){
regs.num_regs = nmatch;
regs.start = ((regoff_t *) xmalloc ((nmatch * 2) * sizeof (regoff_t)));
if (regs.start ==   ((void *)0)  ) {
return (int) REG_NOMATCH;
}





regs.end = regs.start + nmatch;
}
ret = re_search (&private_preg, string, len, 0, len, want_reg_info ? &regs : (struct re_registers *) 0);
if (want_reg_info){
if (ret >= 0){
unsigned r;
for (r = 0; r < nmatch; r++){
pmatch[r].rm_so = regs.start[r];
pmatch[r].rm_eo = regs.end[r];
}
}
free (regs.start);
}
return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
}

size_t regerror (errcode, preg, errbuf, errbuf_size) int errcode;


const regex_t *preg;
char *errbuf;
size_t errbuf_size;
{
const char *msg;
size_t msg_size;
if (errcode < 0 || errcode >= (int) (sizeof (re_error_msgid) / sizeof (re_error_msgid[0]))) {
abort ();
}



msg = gettext (re_error_msgid[errcode]);
msg_size = strlen (msg) + 1;
if (errbuf_size != 0){
if (msg_size > errbuf_size){
memcpy (errbuf, msg, errbuf_size - 1);
errbuf[errbuf_size - 1] = 0;
}
else {
memcpy (errbuf, msg, msg_size);
}
}
return msg_size;
}
void regfree (preg) regex_t *preg;


{
if (preg->buffer !=   ((void *)0)  ) {
free (preg->buffer);
}





preg->buffer =   ((void *)0)  ;




preg->allocated = 0;
preg->used = 0;
if (preg->fastmap !=   ((void *)0)  ) {
free (preg->fastmap);
}





preg->fastmap =   ((void *)0)  ;




preg->fastmap_accurate = 0;
if (preg->translate !=   ((void *)0)  ) {
free (preg->translate);
}





preg->translate =   ((void *)0)  ;




}







struct dirent {

__ino_t d_ino;
__off_t d_off;
unsigned short int d_reclen;
unsigned char d_type;
char d_name[256];
};


enum {

DT_UNKNOWN = 0, DT_FIFO = 1, DT_CHR = 2, DT_DIR = 4, DT_BLK = 6, DT_REG = 8, DT_LNK = 10, DT_SOCK = 12, DT_WHT = 14 };










typedef struct __dirstream DIR;
extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));
extern DIR *fdopendir (int __fd);
extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));

extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));

extern int readdir_r (DIR *__restrict __dirp, struct dirent *__restrict __entry, struct dirent **__restrict __result) __attribute__ ((__nonnull__ (1, 2, 3)));




extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int scandir (const char *__restrict __dir, struct dirent ***__restrict __namelist, int (*__selector) (const struct dirent *), int (*__cmp) (const struct dirent **, const struct dirent **)) __attribute__ ((__nonnull__ (1, 2)));






extern int alphasort (const struct dirent **__e1, const struct dirent **__e2) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern __ssize_t getdirentries (int __fd, char *__restrict __buf, size_t __nbytes, __off_t *__restrict __basep) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));







char *stpcpy ();

char * savedir (dir, name_size) const char *dir;


unsigned int name_size;
{
DIR *dirp;
struct dirent *dp;
char *name_space;
char *namep;
dirp = opendir (dir);
if (dirp ==   ((void *)0)  ) {
return   ((void *)0)  ;
}









name_space = (char *) xmalloc (name_size);
if (name_space ==   ((void *)0)  ) {





closedir (dirp);
return   ((void *)0)  ;




}
namep = name_space;
while ((dp = readdir (dirp)) !=   ((void *)0)  ) {





if (dp->d_name[0] != '.' || (dp->d_name[1] != '\0' && (dp->d_name[1] != '.' || dp->d_name[2] != '\0'))) {



unsigned size_needed = (namep - name_space) + strlen((dp)->d_name) + 2;
if (size_needed > name_size){
char *new_name_space;
while (size_needed > name_size) name_size += 1024;

new_name_space = realloc (name_space, name_size);
if (new_name_space ==   ((void *)0)  ) {





closedir (dirp);
return   ((void *)0)  ;




}
namep += new_name_space - name_space;
name_space = new_name_space;
}
namep = stpcpy (namep, dp->d_name) + 1;
}
}
*namep = '\0';
if (closedir (dirp)){
free (name_space);
return   ((void *)0)  ;




}
return name_space;
}

static void Gcompile (char *, size_t);
static void Ecompile (char *, size_t);
static char *EGexecute (char *, size_t, char **);
static void Fcompile (char *, size_t);
static char *Fexecute (char *, size_t, char **);
static void kwsinit (void);
struct matcher matchers[] = {
{ "default", Gcompile, EGexecute }, { "grep", Gcompile, EGexecute }, { "egrep", Ecompile, EGexecute }, { "awk", Ecompile, EGexecute }, { "fgrep", Fcompile, Fexecute }, { 0, 0, 0 }, };






static struct dfa dfa_1;
static struct re_pattern_buffer regexbuf;
static kwset_t kwset;
static int lastexact;
void dfaerror(mesg) const char *mesg;


{
fatal(mesg, 0);
}
static void kwsinit() {


static char trans[(  (0x7f * 2 + 1)   + 1)];




int i;
if (match_icase) {
for (i = 0; i < (  (0x7f * 2 + 1)   + 1); ++i) trans[i] = ((1 &&   ((*__ctype_b_loc ())[(int) ((  i  ))] & (unsigned short int) _ISupper)  ) ? tolower(i) : (i));
}














if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0))) {
fatal("memory exhausted", 0);
}

}
static void kwsmusts() {


struct dfamust *dm;
char *err;
if (dfa_1.musts){
kwsinit();
for (dm = dfa_1.musts; dm; dm = dm->next){
if (!dm->exact) {
continue;
}

++lastexact;
if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0) {
fatal(err, 0);
}

}
for (dm = dfa_1.musts; dm; dm = dm->next){
if (dm->exact) {
continue;
}

if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0) {
fatal(err, 0);
}

}
if ((err = kwsprep(kwset)) != 0) {
fatal(err, 0);
}

}
}
static void Gcompile(pattern, size) char *pattern;


size_t size;
{
const char *err;
re_set_syntax(((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
dfasyntax(((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), match_icase, eolbyte);
if ((err = re_compile_pattern(pattern, size, &regexbuf)) != 0) {
fatal(err, 0);
}

if (match_words || match_lines){
char *n = xmalloc(size + 50);
int i = 0;
strcpy(n, "");
if (match_lines) {
strcpy(n, "^\\(");
}

if (match_words) {
strcpy(n, "\\(^\\|[^[:alnum:]_]\\)\\(");
}

i = strlen(n);
memcpy(n + i, pattern, size);
i += size;
if (match_words) {
strcpy(n + i, "\\)\\([^[:alnum:]_]\\|$\\)");
}

if (match_lines) {
strcpy(n + i, "\\)$");
}

i += strlen(n + i);
dfacomp(n, i, &dfa_1, 1);
}
else {
dfacomp(pattern, size, &dfa_1, 1);
}
kwsmusts();
}
static void Ecompile(pattern, size) char *pattern;


size_t size;
{
const char *err;
if (strcmp(matcher, "awk") == 0){
re_set_syntax((((unsigned long int) 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
dfasyntax((((unsigned long int) 1) | (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase, eolbyte);
}
else {

re_set_syntax (((((((unsigned long int) 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | ((((((unsigned long int) 1) << 1) << 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
dfasyntax (((((((unsigned long int) 1) << 1) << 1) | (((((unsigned long int) 1) << 1) << 1) << 1) | ((((((unsigned long int) 1) << 1) << 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase, eolbyte);
}
if ((err = re_compile_pattern(pattern, size, &regexbuf)) != 0) {
fatal(err, 0);
}

if (match_words || match_lines){
char *n = xmalloc(size + 50);
int i = 0;
strcpy(n, "");
if (match_lines) {
strcpy(n, "^(");
}

if (match_words) {
strcpy(n, "(^|[^[:alnum:]_])(");
}

i = strlen(n);
memcpy(n + i, pattern, size);
i += size;
if (match_words) {
strcpy(n + i, ")([^[:alnum:]_]|$)");
}

if (match_lines) {
strcpy(n + i, ")$");
}

i += strlen(n + i);
dfacomp(n, i, &dfa_1, 1);
}
else {
dfacomp(pattern, size, &dfa_1, 1);
}
kwsmusts();
}
static char * EGexecute(buf, size, endp) char *buf;


size_t size;
char **endp;
{
register char *buflim, *beg, *end, save;
char eol = eolbyte;
int backref, start, len;
struct kwsmatch kwsm;
static struct re_registers regs;
buflim = buf + size;
for (beg = end = buf; end < buflim; beg = end + 1){
if (kwset){
beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
if (!beg) {
goto failure;
}

end = memchr(beg, eol, buflim - beg);
if (!end) {
end = buflim;
}

while (beg > buf && beg[-1] != eol) --beg;

save = *end;
if (kwsm.strchr < lastexact) {
goto success;
}

if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref)){
*end = save;
continue;
}
*end = save;
if (!backref) {
goto success;
}

}
else {

save = *buflim;
beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
*buflim = save;
if (!beg) {
goto failure;
}

end = memchr(beg, eol, buflim - beg);
if (!end) {
end = buflim;
}

while (beg > buf && beg[-1] != eol) --beg;

if (!backref) {
goto success;
}

}
regexbuf.not_eol = 0;
if ((start = re_search(&regexbuf, beg, end - beg, 0, end - beg, &regs)) >= 0){
len = regs.end[0] - start;
if ((!match_lines && !match_words) || (match_lines && len == end - beg)) {
goto success;
}


if (match_words) {
while (start >= 0) {


if ((start == 0 || !((1 &&   ((*__ctype_b_loc ())[(int) ((  (unsigned char) beg[start - 1]  ))] & (unsigned short int) _ISalnum)  ) || ((unsigned char) beg[start - 1]) == '_')) && (len == end - beg || !((1 &&   ((*__ctype_b_loc ())[(int) ((  (unsigned char) beg[start + len]  ))] & (unsigned short int) _ISalnum)  ) || ((unsigned char) beg[start + len]) == '_'))) {
goto success;
}



















if (len > 0){
--len;
regexbuf.not_eol = 1;
len = re_match(&regexbuf, beg, start + len, start, &regs);
}
if (len <= 0){
if (start == end - beg) {
break;
}

++start;
regexbuf.not_eol = 0;
start = re_search(&regexbuf, beg, end - beg, start, end - beg - start, &regs);
len = regs.end[0] - start;
}
}
}

}
}
failure:
return 0;
success:
*endp = end < buflim ? end + 1 : end;
return beg;
}
static void Fcompile(pattern, size) char *pattern;


size_t size;
{
char *beg, *lim, *err;
kwsinit();
beg = pattern;
do {

for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim) ;

if ((err = kwsincr(kwset, beg, lim - beg)) != 0) {
fatal(err, 0);
}

if (lim < pattern + size) {
++lim;
}

beg = lim;
}
while (beg < pattern + size);
if ((err = kwsprep(kwset)) != 0) {
fatal(err, 0);
}

}
static char * Fexecute(buf, size, endp) char *buf;


size_t size;
char **endp;
{
register char *beg, *try, *end;
register size_t len;
char eol = eolbyte;
struct kwsmatch kwsmatch;
for (beg = buf; beg <= buf + size; ++beg){
if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch))) {
return 0;
}

len = kwsmatch.size[0];
if (match_lines){
if (beg > buf && beg[-1] != eol) {
continue;
}

if (beg + len < buf + size && beg[len] != eol) {
continue;
}

goto success;
}
else{
if (match_words) {
for (try = beg; len && try;){

if (try > buf && ((1 &&   ((*__ctype_b_loc ())[(int) ((  (unsigned char) try[-1]  ))] & (unsigned short int) _ISalnum)  ) || ((unsigned char) try[-1]) == '_')) {
break;
}









if (try + len < buf + size && ((1 &&   ((*__ctype_b_loc ())[(int) ((  (unsigned char) try[len]  ))] & (unsigned short int) _ISalnum)  ) || ((unsigned char) try[len]) == '_')) {









try = kwsexec(kwset, beg, --len, &kwsmatch);
len = kwsmatch.size[0];
}
else {
goto success;
}
}
}

else {
goto success;
}

}
}
return 0;
success:
if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != 0) {
++end;
}

else {
end = buf + size;
}
*endp = end;
while (beg > buf && beg[-1] != '\n') --beg;

return beg;
}

char const *matcher;

char * stpcpy (dest, src) char *dest;


const char *src;
{
register char *d = dest;
register const char *s = src;
do *d++ = *s;

while (*s++ != '\0');
return d - 1;
}
